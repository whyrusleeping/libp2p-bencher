(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
  var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
    get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
  }) : x)(function(x) {
    if (typeof require !== "undefined")
      return require.apply(this, arguments);
    throw new Error('Dynamic require of "' + x + '" is not supported');
  });
  var __esm = (fn, res) => function __init() {
    return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
  };
  var __commonJS = (cb, mod2) => function __require2() {
    return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
  };
  var __export = (target, all) => {
    __markAsModule(target);
    for (var name in all)
      __defProp(target, name, { get: all[name], enumerable: true });
  };
  var __reExport = (target, module2, desc) => {
    if (module2 && typeof module2 === "object" || typeof module2 === "function") {
      for (let key of __getOwnPropNames(module2))
        if (!__hasOwnProp.call(target, key) && key !== "default")
          __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
    }
    return target;
  };
  var __toModule = (module2) => {
    return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
  };

  // (disabled):node_modules/ws/browser.js
  var require_browser = __commonJS({
    "(disabled):node_modules/ws/browser.js"() {
    }
  });

  // node_modules/it-ws/web-socket.js
  var require_web_socket = __commonJS({
    "node_modules/it-ws/web-socket.js"(exports2, module2) {
      module2.exports = typeof WebSocket === "undefined" ? require_browser() : WebSocket;
    }
  });

  // node_modules/base64-js/index.js
  var require_base64_js = __commonJS({
    "node_modules/base64-js/index.js"(exports2) {
      "use strict";
      exports2.byteLength = byteLength;
      exports2.toByteArray = toByteArray;
      exports2.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
      for (i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }
      var i;
      var len;
      revLookup["-".charCodeAt(0)] = 62;
      revLookup["_".charCodeAt(0)] = 63;
      function getLens(b64) {
        var len2 = b64.length;
        if (len2 % 4 > 0) {
          throw new Error("Invalid string. Length must be a multiple of 4");
        }
        var validLen = b64.indexOf("=");
        if (validLen === -1)
          validLen = len2;
        var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;
        var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i2;
        for (i2 = 0; i2 < len2; i2 += 4) {
          tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
          arr[curByte++] = tmp >> 16 & 255;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
          arr[curByte++] = tmp & 255;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 255;
          arr[curByte++] = tmp & 255;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i2 = start; i2 < end; i2 += 3) {
          tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
          output.push(tripletToBase64(tmp));
        }
        return output.join("");
      }
      function fromByteArray(uint8) {
        var tmp;
        var len2 = uint8.length;
        var extraBytes = len2 % 3;
        var parts = [];
        var maxChunkLength = 16383;
        for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
          parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
        }
        if (extraBytes === 1) {
          tmp = uint8[len2 - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
        } else if (extraBytes === 2) {
          tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
        }
        return parts.join("");
      }
    }
  });

  // node_modules/ieee754/index.js
  var require_ieee754 = __commonJS({
    "node_modules/ieee754/index.js"(exports2) {
      exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
        }
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
        }
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
        }
        buffer[offset + i - d] |= s * 128;
      };
    }
  });

  // node_modules/buffer/index.js
  var require_buffer = __commonJS({
    "node_modules/buffer/index.js"(exports2) {
      "use strict";
      var base642 = require_base64_js();
      var ieee754 = require_ieee754();
      var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
      exports2.Buffer = Buffer2;
      exports2.SlowBuffer = SlowBuffer;
      exports2.INSPECT_MAX_BYTES = 50;
      var K_MAX_LENGTH = 2147483647;
      exports2.kMaxLength = K_MAX_LENGTH;
      Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
      if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
        console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
      }
      function typedArraySupport() {
        try {
          const arr = new Uint8Array(1);
          const proto = { foo: function() {
            return 42;
          } };
          Object.setPrototypeOf(proto, Uint8Array.prototype);
          Object.setPrototypeOf(arr, proto);
          return arr.foo() === 42;
        } catch (e) {
          return false;
        }
      }
      Object.defineProperty(Buffer2.prototype, "parent", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.buffer;
        }
      });
      Object.defineProperty(Buffer2.prototype, "offset", {
        enumerable: true,
        get: function() {
          if (!Buffer2.isBuffer(this))
            return void 0;
          return this.byteOffset;
        }
      });
      function createBuffer(length2) {
        if (length2 > K_MAX_LENGTH) {
          throw new RangeError('The value "' + length2 + '" is invalid for option "size"');
        }
        const buf = new Uint8Array(length2);
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function Buffer2(arg, encodingOrOffset, length2) {
        if (typeof arg === "number") {
          if (typeof encodingOrOffset === "string") {
            throw new TypeError('The "string" argument must be of type string. Received type number');
          }
          return allocUnsafe(arg);
        }
        return from3(arg, encodingOrOffset, length2);
      }
      Buffer2.poolSize = 8192;
      function from3(value, encodingOrOffset, length2) {
        if (typeof value === "string") {
          return fromString3(value, encodingOrOffset);
        }
        if (ArrayBuffer.isView(value)) {
          return fromArrayView(value);
        }
        if (value == null) {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
          return fromArrayBuffer(value, encodingOrOffset, length2);
        }
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type number');
        }
        const valueOf = value.valueOf && value.valueOf();
        if (valueOf != null && valueOf !== value) {
          return Buffer2.from(valueOf, encodingOrOffset, length2);
        }
        const b = fromObject(value);
        if (b)
          return b;
        if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
          return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length2);
        }
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      Buffer2.from = function(value, encodingOrOffset, length2) {
        return from3(value, encodingOrOffset, length2);
      };
      Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
      Object.setPrototypeOf(Buffer2, Uint8Array);
      function assertSize(size) {
        if (typeof size !== "number") {
          throw new TypeError('"size" argument must be of type number');
        } else if (size < 0) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
      }
      function alloc(size, fill, encoding) {
        assertSize(size);
        if (size <= 0) {
          return createBuffer(size);
        }
        if (fill !== void 0) {
          return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
        }
        return createBuffer(size);
      }
      Buffer2.alloc = function(size, fill, encoding) {
        return alloc(size, fill, encoding);
      };
      function allocUnsafe(size) {
        assertSize(size);
        return createBuffer(size < 0 ? 0 : checked(size) | 0);
      }
      Buffer2.allocUnsafe = function(size) {
        return allocUnsafe(size);
      };
      Buffer2.allocUnsafeSlow = function(size) {
        return allocUnsafe(size);
      };
      function fromString3(string2, encoding) {
        if (typeof encoding !== "string" || encoding === "") {
          encoding = "utf8";
        }
        if (!Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        const length2 = byteLength(string2, encoding) | 0;
        let buf = createBuffer(length2);
        const actual = buf.write(string2, encoding);
        if (actual !== length2) {
          buf = buf.slice(0, actual);
        }
        return buf;
      }
      function fromArrayLike(array) {
        const length2 = array.length < 0 ? 0 : checked(array.length) | 0;
        const buf = createBuffer(length2);
        for (let i = 0; i < length2; i += 1) {
          buf[i] = array[i] & 255;
        }
        return buf;
      }
      function fromArrayView(arrayView) {
        if (isInstance(arrayView, Uint8Array)) {
          const copy = new Uint8Array(arrayView);
          return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
        }
        return fromArrayLike(arrayView);
      }
      function fromArrayBuffer(array, byteOffset, length2) {
        if (byteOffset < 0 || array.byteLength < byteOffset) {
          throw new RangeError('"offset" is outside of buffer bounds');
        }
        if (array.byteLength < byteOffset + (length2 || 0)) {
          throw new RangeError('"length" is outside of buffer bounds');
        }
        let buf;
        if (byteOffset === void 0 && length2 === void 0) {
          buf = new Uint8Array(array);
        } else if (length2 === void 0) {
          buf = new Uint8Array(array, byteOffset);
        } else {
          buf = new Uint8Array(array, byteOffset, length2);
        }
        Object.setPrototypeOf(buf, Buffer2.prototype);
        return buf;
      }
      function fromObject(obj) {
        if (Buffer2.isBuffer(obj)) {
          const len = checked(obj.length) | 0;
          const buf = createBuffer(len);
          if (buf.length === 0) {
            return buf;
          }
          obj.copy(buf, 0, 0, len);
          return buf;
        }
        if (obj.length !== void 0) {
          if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
            return createBuffer(0);
          }
          return fromArrayLike(obj);
        }
        if (obj.type === "Buffer" && Array.isArray(obj.data)) {
          return fromArrayLike(obj.data);
        }
      }
      function checked(length2) {
        if (length2 >= K_MAX_LENGTH) {
          throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
        }
        return length2 | 0;
      }
      function SlowBuffer(length2) {
        if (+length2 != length2) {
          length2 = 0;
        }
        return Buffer2.alloc(+length2);
      }
      Buffer2.isBuffer = function isBuffer(b) {
        return b != null && b._isBuffer === true && b !== Buffer2.prototype;
      };
      Buffer2.compare = function compare(a, b) {
        if (isInstance(a, Uint8Array))
          a = Buffer2.from(a, a.offset, a.byteLength);
        if (isInstance(b, Uint8Array))
          b = Buffer2.from(b, b.offset, b.byteLength);
        if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
          throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        }
        if (a === b)
          return 0;
        let x = a.length;
        let y = b.length;
        for (let i = 0, len = Math.min(x, y); i < len; ++i) {
          if (a[i] !== b[i]) {
            x = a[i];
            y = b[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      Buffer2.isEncoding = function isEncoding(encoding) {
        switch (String(encoding).toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "latin1":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return true;
          default:
            return false;
        }
      };
      Buffer2.concat = function concat2(list, length2) {
        if (!Array.isArray(list)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        }
        if (list.length === 0) {
          return Buffer2.alloc(0);
        }
        let i;
        if (length2 === void 0) {
          length2 = 0;
          for (i = 0; i < list.length; ++i) {
            length2 += list[i].length;
          }
        }
        const buffer = Buffer2.allocUnsafe(length2);
        let pos = 0;
        for (i = 0; i < list.length; ++i) {
          let buf = list[i];
          if (isInstance(buf, Uint8Array)) {
            if (pos + buf.length > buffer.length) {
              if (!Buffer2.isBuffer(buf))
                buf = Buffer2.from(buf);
              buf.copy(buffer, pos);
            } else {
              Uint8Array.prototype.set.call(buffer, buf, pos);
            }
          } else if (!Buffer2.isBuffer(buf)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          } else {
            buf.copy(buffer, pos);
          }
          pos += buf.length;
        }
        return buffer;
      };
      function byteLength(string2, encoding) {
        if (Buffer2.isBuffer(string2)) {
          return string2.length;
        }
        if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {
          return string2.byteLength;
        }
        if (typeof string2 !== "string") {
          throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);
        }
        const len = string2.length;
        const mustMatch = arguments.length > 2 && arguments[2] === true;
        if (!mustMatch && len === 0)
          return 0;
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "ascii":
            case "latin1":
            case "binary":
              return len;
            case "utf8":
            case "utf-8":
              return utf8ToBytes(string2).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return len * 2;
            case "hex":
              return len >>> 1;
            case "base64":
              return base64ToBytes(string2).length;
            default:
              if (loweredCase) {
                return mustMatch ? -1 : utf8ToBytes(string2).length;
              }
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.byteLength = byteLength;
      function slowToString(encoding, start, end) {
        let loweredCase = false;
        if (start === void 0 || start < 0) {
          start = 0;
        }
        if (start > this.length) {
          return "";
        }
        if (end === void 0 || end > this.length) {
          end = this.length;
        }
        if (end <= 0) {
          return "";
        }
        end >>>= 0;
        start >>>= 0;
        if (end <= start) {
          return "";
        }
        if (!encoding)
          encoding = "utf8";
        while (true) {
          switch (encoding) {
            case "hex":
              return hexSlice(this, start, end);
            case "utf8":
            case "utf-8":
              return utf8Slice(this, start, end);
            case "ascii":
              return asciiSlice(this, start, end);
            case "latin1":
            case "binary":
              return latin1Slice(this, start, end);
            case "base64":
              return base64Slice(this, start, end);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return utf16leSlice(this, start, end);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = (encoding + "").toLowerCase();
              loweredCase = true;
          }
        }
      }
      Buffer2.prototype._isBuffer = true;
      function swap(b, n, m) {
        const i = b[n];
        b[n] = b[m];
        b[m] = i;
      }
      Buffer2.prototype.swap16 = function swap16() {
        const len = this.length;
        if (len % 2 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 16-bits");
        }
        for (let i = 0; i < len; i += 2) {
          swap(this, i, i + 1);
        }
        return this;
      };
      Buffer2.prototype.swap32 = function swap32() {
        const len = this.length;
        if (len % 4 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 32-bits");
        }
        for (let i = 0; i < len; i += 4) {
          swap(this, i, i + 3);
          swap(this, i + 1, i + 2);
        }
        return this;
      };
      Buffer2.prototype.swap64 = function swap64() {
        const len = this.length;
        if (len % 8 !== 0) {
          throw new RangeError("Buffer size must be a multiple of 64-bits");
        }
        for (let i = 0; i < len; i += 8) {
          swap(this, i, i + 7);
          swap(this, i + 1, i + 6);
          swap(this, i + 2, i + 5);
          swap(this, i + 3, i + 4);
        }
        return this;
      };
      Buffer2.prototype.toString = function toString3() {
        const length2 = this.length;
        if (length2 === 0)
          return "";
        if (arguments.length === 0)
          return utf8Slice(this, 0, length2);
        return slowToString.apply(this, arguments);
      };
      Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
      Buffer2.prototype.equals = function equals5(b) {
        if (!Buffer2.isBuffer(b))
          throw new TypeError("Argument must be a Buffer");
        if (this === b)
          return true;
        return Buffer2.compare(this, b) === 0;
      };
      Buffer2.prototype.inspect = function inspect() {
        let str = "";
        const max = exports2.INSPECT_MAX_BYTES;
        str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
        if (this.length > max)
          str += " ... ";
        return "<Buffer " + str + ">";
      };
      if (customInspectSymbol) {
        Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
      }
      Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
        if (isInstance(target, Uint8Array)) {
          target = Buffer2.from(target, target.offset, target.byteLength);
        }
        if (!Buffer2.isBuffer(target)) {
          throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
        }
        if (start === void 0) {
          start = 0;
        }
        if (end === void 0) {
          end = target ? target.length : 0;
        }
        if (thisStart === void 0) {
          thisStart = 0;
        }
        if (thisEnd === void 0) {
          thisEnd = this.length;
        }
        if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
          throw new RangeError("out of range index");
        }
        if (thisStart >= thisEnd && start >= end) {
          return 0;
        }
        if (thisStart >= thisEnd) {
          return -1;
        }
        if (start >= end) {
          return 1;
        }
        start >>>= 0;
        end >>>= 0;
        thisStart >>>= 0;
        thisEnd >>>= 0;
        if (this === target)
          return 0;
        let x = thisEnd - thisStart;
        let y = end - start;
        const len = Math.min(x, y);
        const thisCopy = this.slice(thisStart, thisEnd);
        const targetCopy = target.slice(start, end);
        for (let i = 0; i < len; ++i) {
          if (thisCopy[i] !== targetCopy[i]) {
            x = thisCopy[i];
            y = targetCopy[i];
            break;
          }
        }
        if (x < y)
          return -1;
        if (y < x)
          return 1;
        return 0;
      };
      function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
        if (buffer.length === 0)
          return -1;
        if (typeof byteOffset === "string") {
          encoding = byteOffset;
          byteOffset = 0;
        } else if (byteOffset > 2147483647) {
          byteOffset = 2147483647;
        } else if (byteOffset < -2147483648) {
          byteOffset = -2147483648;
        }
        byteOffset = +byteOffset;
        if (numberIsNaN(byteOffset)) {
          byteOffset = dir ? 0 : buffer.length - 1;
        }
        if (byteOffset < 0)
          byteOffset = buffer.length + byteOffset;
        if (byteOffset >= buffer.length) {
          if (dir)
            return -1;
          else
            byteOffset = buffer.length - 1;
        } else if (byteOffset < 0) {
          if (dir)
            byteOffset = 0;
          else
            return -1;
        }
        if (typeof val === "string") {
          val = Buffer2.from(val, encoding);
        }
        if (Buffer2.isBuffer(val)) {
          if (val.length === 0) {
            return -1;
          }
          return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
        } else if (typeof val === "number") {
          val = val & 255;
          if (typeof Uint8Array.prototype.indexOf === "function") {
            if (dir) {
              return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
            } else {
              return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
            }
          }
          return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
        }
        throw new TypeError("val must be string, number or Buffer");
      }
      function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
        let indexSize = 1;
        let arrLength = arr.length;
        let valLength = val.length;
        if (encoding !== void 0) {
          encoding = String(encoding).toLowerCase();
          if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
            if (arr.length < 2 || val.length < 2) {
              return -1;
            }
            indexSize = 2;
            arrLength /= 2;
            valLength /= 2;
            byteOffset /= 2;
          }
        }
        function read2(buf, i2) {
          if (indexSize === 1) {
            return buf[i2];
          } else {
            return buf.readUInt16BE(i2 * indexSize);
          }
        }
        let i;
        if (dir) {
          let foundIndex = -1;
          for (i = byteOffset; i < arrLength; i++) {
            if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
              if (foundIndex === -1)
                foundIndex = i;
              if (i - foundIndex + 1 === valLength)
                return foundIndex * indexSize;
            } else {
              if (foundIndex !== -1)
                i -= i - foundIndex;
              foundIndex = -1;
            }
          }
        } else {
          if (byteOffset + valLength > arrLength)
            byteOffset = arrLength - valLength;
          for (i = byteOffset; i >= 0; i--) {
            let found = true;
            for (let j = 0; j < valLength; j++) {
              if (read2(arr, i + j) !== read2(val, j)) {
                found = false;
                break;
              }
            }
            if (found)
              return i;
          }
        }
        return -1;
      }
      Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
        return this.indexOf(val, byteOffset, encoding) !== -1;
      };
      Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
      };
      Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
        return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
      };
      function hexWrite(buf, string2, offset, length2) {
        offset = Number(offset) || 0;
        const remaining = buf.length - offset;
        if (!length2) {
          length2 = remaining;
        } else {
          length2 = Number(length2);
          if (length2 > remaining) {
            length2 = remaining;
          }
        }
        const strLen = string2.length;
        if (length2 > strLen / 2) {
          length2 = strLen / 2;
        }
        let i;
        for (i = 0; i < length2; ++i) {
          const parsed = parseInt(string2.substr(i * 2, 2), 16);
          if (numberIsNaN(parsed))
            return i;
          buf[offset + i] = parsed;
        }
        return i;
      }
      function utf8Write(buf, string2, offset, length2) {
        return blitBuffer(utf8ToBytes(string2, buf.length - offset), buf, offset, length2);
      }
      function asciiWrite(buf, string2, offset, length2) {
        return blitBuffer(asciiToBytes(string2), buf, offset, length2);
      }
      function base64Write(buf, string2, offset, length2) {
        return blitBuffer(base64ToBytes(string2), buf, offset, length2);
      }
      function ucs2Write(buf, string2, offset, length2) {
        return blitBuffer(utf16leToBytes(string2, buf.length - offset), buf, offset, length2);
      }
      Buffer2.prototype.write = function write(string2, offset, length2, encoding) {
        if (offset === void 0) {
          encoding = "utf8";
          length2 = this.length;
          offset = 0;
        } else if (length2 === void 0 && typeof offset === "string") {
          encoding = offset;
          length2 = this.length;
          offset = 0;
        } else if (isFinite(offset)) {
          offset = offset >>> 0;
          if (isFinite(length2)) {
            length2 = length2 >>> 0;
            if (encoding === void 0)
              encoding = "utf8";
          } else {
            encoding = length2;
            length2 = void 0;
          }
        } else {
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        }
        const remaining = this.length - offset;
        if (length2 === void 0 || length2 > remaining)
          length2 = remaining;
        if (string2.length > 0 && (length2 < 0 || offset < 0) || offset > this.length) {
          throw new RangeError("Attempt to write outside buffer bounds");
        }
        if (!encoding)
          encoding = "utf8";
        let loweredCase = false;
        for (; ; ) {
          switch (encoding) {
            case "hex":
              return hexWrite(this, string2, offset, length2);
            case "utf8":
            case "utf-8":
              return utf8Write(this, string2, offset, length2);
            case "ascii":
            case "latin1":
            case "binary":
              return asciiWrite(this, string2, offset, length2);
            case "base64":
              return base64Write(this, string2, offset, length2);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return ucs2Write(this, string2, offset, length2);
            default:
              if (loweredCase)
                throw new TypeError("Unknown encoding: " + encoding);
              encoding = ("" + encoding).toLowerCase();
              loweredCase = true;
          }
        }
      };
      Buffer2.prototype.toJSON = function toJSON() {
        return {
          type: "Buffer",
          data: Array.prototype.slice.call(this._arr || this, 0)
        };
      };
      function base64Slice(buf, start, end) {
        if (start === 0 && end === buf.length) {
          return base642.fromByteArray(buf);
        } else {
          return base642.fromByteArray(buf.slice(start, end));
        }
      }
      function utf8Slice(buf, start, end) {
        end = Math.min(buf.length, end);
        const res = [];
        let i = start;
        while (i < end) {
          const firstByte = buf[i];
          let codePoint = null;
          let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
          if (i + bytesPerSequence <= end) {
            let secondByte, thirdByte, fourthByte, tempCodePoint;
            switch (bytesPerSequence) {
              case 1:
                if (firstByte < 128) {
                  codePoint = firstByte;
                }
                break;
              case 2:
                secondByte = buf[i + 1];
                if ((secondByte & 192) === 128) {
                  tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                  if (tempCodePoint > 127) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 3:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                  if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                    codePoint = tempCodePoint;
                  }
                }
                break;
              case 4:
                secondByte = buf[i + 1];
                thirdByte = buf[i + 2];
                fourthByte = buf[i + 3];
                if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                  tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                  if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                    codePoint = tempCodePoint;
                  }
                }
            }
          }
          if (codePoint === null) {
            codePoint = 65533;
            bytesPerSequence = 1;
          } else if (codePoint > 65535) {
            codePoint -= 65536;
            res.push(codePoint >>> 10 & 1023 | 55296);
            codePoint = 56320 | codePoint & 1023;
          }
          res.push(codePoint);
          i += bytesPerSequence;
        }
        return decodeCodePointsArray(res);
      }
      var MAX_ARGUMENTS_LENGTH = 4096;
      function decodeCodePointsArray(codePoints) {
        const len = codePoints.length;
        if (len <= MAX_ARGUMENTS_LENGTH) {
          return String.fromCharCode.apply(String, codePoints);
        }
        let res = "";
        let i = 0;
        while (i < len) {
          res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
        }
        return res;
      }
      function asciiSlice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i] & 127);
        }
        return ret;
      }
      function latin1Slice(buf, start, end) {
        let ret = "";
        end = Math.min(buf.length, end);
        for (let i = start; i < end; ++i) {
          ret += String.fromCharCode(buf[i]);
        }
        return ret;
      }
      function hexSlice(buf, start, end) {
        const len = buf.length;
        if (!start || start < 0)
          start = 0;
        if (!end || end < 0 || end > len)
          end = len;
        let out = "";
        for (let i = start; i < end; ++i) {
          out += hexSliceLookupTable[buf[i]];
        }
        return out;
      }
      function utf16leSlice(buf, start, end) {
        const bytes = buf.slice(start, end);
        let res = "";
        for (let i = 0; i < bytes.length - 1; i += 2) {
          res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
        }
        return res;
      }
      Buffer2.prototype.slice = function slice(start, end) {
        const len = this.length;
        start = ~~start;
        end = end === void 0 ? len : ~~end;
        if (start < 0) {
          start += len;
          if (start < 0)
            start = 0;
        } else if (start > len) {
          start = len;
        }
        if (end < 0) {
          end += len;
          if (end < 0)
            end = 0;
        } else if (end > len) {
          end = len;
        }
        if (end < start)
          end = start;
        const newBuf = this.subarray(start, end);
        Object.setPrototypeOf(newBuf, Buffer2.prototype);
        return newBuf;
      };
      function checkOffset(offset, ext, length2) {
        if (offset % 1 !== 0 || offset < 0)
          throw new RangeError("offset is not uint");
        if (offset + ext > length2)
          throw new RangeError("Trying to access beyond buffer length");
      }
      Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          checkOffset(offset, byteLength2, this.length);
        }
        let val = this[offset + --byteLength2];
        let mul = 1;
        while (byteLength2 > 0 && (mul *= 256)) {
          val += this[offset + --byteLength2] * mul;
        }
        return val;
      };
      Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        return this[offset];
      };
      Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] | this[offset + 1] << 8;
      };
      Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        return this[offset] << 8 | this[offset + 1];
      };
      Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
      };
      Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
      };
      Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
        const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
        return BigInt(lo) + (BigInt(hi) << BigInt(32));
      });
      Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
        return (BigInt(hi) << BigInt(32)) + BigInt(lo);
      });
      Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let val = this[offset];
        let mul = 1;
        let i = 0;
        while (++i < byteLength2 && (mul *= 256)) {
          val += this[offset + i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert)
          checkOffset(offset, byteLength2, this.length);
        let i = byteLength2;
        let mul = 1;
        let val = this[offset + --i];
        while (i > 0 && (mul *= 256)) {
          val += this[offset + --i] * mul;
        }
        mul *= 128;
        if (val >= mul)
          val -= Math.pow(2, 8 * byteLength2);
        return val;
      };
      Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 1, this.length);
        if (!(this[offset] & 128))
          return this[offset];
        return (255 - this[offset] + 1) * -1;
      };
      Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset] | this[offset + 1] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 2, this.length);
        const val = this[offset + 1] | this[offset] << 8;
        return val & 32768 ? val | 4294901760 : val;
      };
      Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
      };
      Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
      };
      Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
        return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
      });
      Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
        offset = offset >>> 0;
        validateNumber(offset, "offset");
        const first = this[offset];
        const last = this[offset + 7];
        if (first === void 0 || last === void 0) {
          boundsError(offset, this.length - 8);
        }
        const val = (first << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
        return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
      });
      Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, true, 23, 4);
      };
      Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 4, this.length);
        return ieee754.read(this, offset, false, 23, 4);
      };
      Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, true, 52, 8);
      };
      Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
        offset = offset >>> 0;
        if (!noAssert)
          checkOffset(offset, 8, this.length);
        return ieee754.read(this, offset, false, 52, 8);
      };
      function checkInt(buf, value, offset, ext, max, min) {
        if (!Buffer2.isBuffer(buf))
          throw new TypeError('"buffer" argument must be a Buffer instance');
        if (value > max || value < min)
          throw new RangeError('"value" argument is out of bounds');
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
      }
      Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let mul = 1;
        let i = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        byteLength2 = byteLength2 >>> 0;
        if (!noAssert) {
          const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
          checkInt(this, value, offset, byteLength2, maxBytes, 0);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          this[offset + i] = value / mul & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 255, 0);
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 65535, 0);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset + 3] = value >>> 24;
        this[offset + 2] = value >>> 16;
        this[offset + 1] = value >>> 8;
        this[offset] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 4294967295, 0);
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      function wrtBigUInt64LE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        lo = lo >> 8;
        buf[offset++] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        hi = hi >> 8;
        buf[offset++] = hi;
        return offset;
      }
      function wrtBigUInt64BE(buf, value, offset, min, max) {
        checkIntBI(value, min, max, buf, offset, 7);
        let lo = Number(value & BigInt(4294967295));
        buf[offset + 7] = lo;
        lo = lo >> 8;
        buf[offset + 6] = lo;
        lo = lo >> 8;
        buf[offset + 5] = lo;
        lo = lo >> 8;
        buf[offset + 4] = lo;
        let hi = Number(value >> BigInt(32) & BigInt(4294967295));
        buf[offset + 3] = hi;
        hi = hi >> 8;
        buf[offset + 2] = hi;
        hi = hi >> 8;
        buf[offset + 1] = hi;
        hi = hi >> 8;
        buf[offset] = hi;
        return offset + 8;
      }
      Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
      });
      Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = 0;
        let mul = 1;
        let sub = 0;
        this[offset] = value & 255;
        while (++i < byteLength2 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          const limit = Math.pow(2, 8 * byteLength2 - 1);
          checkInt(this, value, offset, byteLength2, limit - 1, -limit);
        }
        let i = byteLength2 - 1;
        let mul = 1;
        let sub = 0;
        this[offset + i] = value & 255;
        while (--i >= 0 && (mul *= 256)) {
          if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
            sub = 1;
          }
          this[offset + i] = (value / mul >> 0) - sub & 255;
        }
        return offset + byteLength2;
      };
      Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 1, 127, -128);
        if (value < 0)
          value = 255 + value + 1;
        this[offset] = value & 255;
        return offset + 1;
      };
      Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        return offset + 2;
      };
      Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 2, 32767, -32768);
        this[offset] = value >>> 8;
        this[offset + 1] = value & 255;
        return offset + 2;
      };
      Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        this[offset] = value & 255;
        this[offset + 1] = value >>> 8;
        this[offset + 2] = value >>> 16;
        this[offset + 3] = value >>> 24;
        return offset + 4;
      };
      Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert)
          checkInt(this, value, offset, 4, 2147483647, -2147483648);
        if (value < 0)
          value = 4294967295 + value + 1;
        this[offset] = value >>> 24;
        this[offset + 1] = value >>> 16;
        this[offset + 2] = value >>> 8;
        this[offset + 3] = value & 255;
        return offset + 4;
      };
      Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
        return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
        return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
      });
      function checkIEEE754(buf, value, offset, ext, max, min) {
        if (offset + ext > buf.length)
          throw new RangeError("Index out of range");
        if (offset < 0)
          throw new RangeError("Index out of range");
      }
      function writeFloat(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
        }
        ieee754.write(buf, value, offset, littleEndian, 23, 4);
        return offset + 4;
      }
      Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
        return writeFloat(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
        return writeFloat(this, value, offset, false, noAssert);
      };
      function writeDouble(buf, value, offset, littleEndian, noAssert) {
        value = +value;
        offset = offset >>> 0;
        if (!noAssert) {
          checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
        }
        ieee754.write(buf, value, offset, littleEndian, 52, 8);
        return offset + 8;
      }
      Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
        return writeDouble(this, value, offset, true, noAssert);
      };
      Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
        return writeDouble(this, value, offset, false, noAssert);
      };
      Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
        if (!Buffer2.isBuffer(target))
          throw new TypeError("argument should be a Buffer");
        if (!start)
          start = 0;
        if (!end && end !== 0)
          end = this.length;
        if (targetStart >= target.length)
          targetStart = target.length;
        if (!targetStart)
          targetStart = 0;
        if (end > 0 && end < start)
          end = start;
        if (end === start)
          return 0;
        if (target.length === 0 || this.length === 0)
          return 0;
        if (targetStart < 0) {
          throw new RangeError("targetStart out of bounds");
        }
        if (start < 0 || start >= this.length)
          throw new RangeError("Index out of range");
        if (end < 0)
          throw new RangeError("sourceEnd out of bounds");
        if (end > this.length)
          end = this.length;
        if (target.length - targetStart < end - start) {
          end = target.length - targetStart + start;
        }
        const len = end - start;
        if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
          this.copyWithin(targetStart, start, end);
        } else {
          Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
        }
        return len;
      };
      Buffer2.prototype.fill = function fill(val, start, end, encoding) {
        if (typeof val === "string") {
          if (typeof start === "string") {
            encoding = start;
            start = 0;
            end = this.length;
          } else if (typeof end === "string") {
            encoding = end;
            end = this.length;
          }
          if (encoding !== void 0 && typeof encoding !== "string") {
            throw new TypeError("encoding must be a string");
          }
          if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
            throw new TypeError("Unknown encoding: " + encoding);
          }
          if (val.length === 1) {
            const code = val.charCodeAt(0);
            if (encoding === "utf8" && code < 128 || encoding === "latin1") {
              val = code;
            }
          }
        } else if (typeof val === "number") {
          val = val & 255;
        } else if (typeof val === "boolean") {
          val = Number(val);
        }
        if (start < 0 || this.length < start || this.length < end) {
          throw new RangeError("Out of range index");
        }
        if (end <= start) {
          return this;
        }
        start = start >>> 0;
        end = end === void 0 ? this.length : end >>> 0;
        if (!val)
          val = 0;
        let i;
        if (typeof val === "number") {
          for (i = start; i < end; ++i) {
            this[i] = val;
          }
        } else {
          const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
          const len = bytes.length;
          if (len === 0) {
            throw new TypeError('The value "' + val + '" is invalid for argument "value"');
          }
          for (i = 0; i < end - start; ++i) {
            this[i + start] = bytes[i % len];
          }
        }
        return this;
      };
      var errors = {};
      function E(sym, getMessage, Base) {
        errors[sym] = class NodeError extends Base {
          constructor() {
            super();
            Object.defineProperty(this, "message", {
              value: getMessage.apply(this, arguments),
              writable: true,
              configurable: true
            });
            this.name = `${this.name} [${sym}]`;
            this.stack;
            delete this.name;
          }
          get code() {
            return sym;
          }
          set code(value) {
            Object.defineProperty(this, "code", {
              configurable: true,
              enumerable: true,
              value,
              writable: true
            });
          }
          toString() {
            return `${this.name} [${sym}]: ${this.message}`;
          }
        };
      }
      E("ERR_BUFFER_OUT_OF_BOUNDS", function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      }, RangeError);
      E("ERR_INVALID_ARG_TYPE", function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      }, TypeError);
      E("ERR_OUT_OF_RANGE", function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      }, RangeError);
      function addNumericalSeparator(val) {
        let res = "";
        let i = val.length;
        const start = val[0] === "-" ? 1 : 0;
        for (; i >= start + 4; i -= 3) {
          res = `_${val.slice(i - 3, i)}${res}`;
        }
        return `${val.slice(0, i)}${res}`;
      }
      function checkBounds(buf, offset, byteLength2) {
        validateNumber(offset, "offset");
        if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
          boundsError(offset, buf.length - (byteLength2 + 1));
        }
      }
      function checkIntBI(value, min, max, buf, offset, byteLength2) {
        if (value > max || value < min) {
          const n = typeof min === "bigint" ? "n" : "";
          let range;
          if (byteLength2 > 3) {
            if (min === 0 || min === BigInt(0)) {
              range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
            } else {
              range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
            }
          } else {
            range = `>= ${min}${n} and <= ${max}${n}`;
          }
          throw new errors.ERR_OUT_OF_RANGE("value", range, value);
        }
        checkBounds(buf, offset, byteLength2);
      }
      function validateNumber(value, name) {
        if (typeof value !== "number") {
          throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
        }
      }
      function boundsError(value, length2, type) {
        if (Math.floor(value) !== value) {
          validateNumber(value, type);
          throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
        }
        if (length2 < 0) {
          throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
        }
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length2}`, value);
      }
      var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
      function base64clean(str) {
        str = str.split("=")[0];
        str = str.trim().replace(INVALID_BASE64_RE, "");
        if (str.length < 2)
          return "";
        while (str.length % 4 !== 0) {
          str = str + "=";
        }
        return str;
      }
      function utf8ToBytes(string2, units) {
        units = units || Infinity;
        let codePoint;
        const length2 = string2.length;
        let leadSurrogate = null;
        const bytes = [];
        for (let i = 0; i < length2; ++i) {
          codePoint = string2.charCodeAt(i);
          if (codePoint > 55295 && codePoint < 57344) {
            if (!leadSurrogate) {
              if (codePoint > 56319) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              } else if (i + 1 === length2) {
                if ((units -= 3) > -1)
                  bytes.push(239, 191, 189);
                continue;
              }
              leadSurrogate = codePoint;
              continue;
            }
            if (codePoint < 56320) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              leadSurrogate = codePoint;
              continue;
            }
            codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
          } else if (leadSurrogate) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
          }
          leadSurrogate = null;
          if (codePoint < 128) {
            if ((units -= 1) < 0)
              break;
            bytes.push(codePoint);
          } else if (codePoint < 2048) {
            if ((units -= 2) < 0)
              break;
            bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
          } else if (codePoint < 65536) {
            if ((units -= 3) < 0)
              break;
            bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else if (codePoint < 1114112) {
            if ((units -= 4) < 0)
              break;
            bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
          } else {
            throw new Error("Invalid code point");
          }
        }
        return bytes;
      }
      function asciiToBytes(str) {
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          byteArray.push(str.charCodeAt(i) & 255);
        }
        return byteArray;
      }
      function utf16leToBytes(str, units) {
        let c, hi, lo;
        const byteArray = [];
        for (let i = 0; i < str.length; ++i) {
          if ((units -= 2) < 0)
            break;
          c = str.charCodeAt(i);
          hi = c >> 8;
          lo = c % 256;
          byteArray.push(lo);
          byteArray.push(hi);
        }
        return byteArray;
      }
      function base64ToBytes(str) {
        return base642.toByteArray(base64clean(str));
      }
      function blitBuffer(src2, dst, offset, length2) {
        let i;
        for (i = 0; i < length2; ++i) {
          if (i + offset >= dst.length || i >= src2.length)
            break;
          dst[i + offset] = src2[i];
        }
        return i;
      }
      function isInstance(obj, type) {
        return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
      }
      function numberIsNaN(obj) {
        return obj !== obj;
      }
      var hexSliceLookupTable = function() {
        const alphabet = "0123456789abcdef";
        const table = new Array(256);
        for (let i = 0; i < 16; ++i) {
          const i16 = i * 16;
          for (let j = 0; j < 16; ++j) {
            table[i16 + j] = alphabet[i] + alphabet[j];
          }
        }
        return table;
      }();
      function defineBigIntMethod(fn) {
        return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
      }
      function BufferBigIntNotDefined() {
        throw new Error("BigInt not supported");
      }
    }
  });

  // node_modules/event-iterator/lib/event-iterator.js
  var require_event_iterator = __commonJS({
    "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var EventQueue = class {
        constructor() {
          this.pullQueue = [];
          this.pushQueue = [];
          this.eventHandlers = {};
          this.isPaused = false;
          this.isStopped = false;
        }
        push(value) {
          if (this.isStopped)
            return;
          const resolution = { value, done: false };
          if (this.pullQueue.length) {
            const placeholder = this.pullQueue.shift();
            if (placeholder)
              placeholder.resolve(resolution);
          } else {
            this.pushQueue.push(Promise.resolve(resolution));
            if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
              this.isPaused = true;
              if (this.eventHandlers.highWater) {
                this.eventHandlers.highWater();
              } else if (console) {
                console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
              }
            }
          }
        }
        stop() {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          for (const placeholder of this.pullQueue) {
            placeholder.resolve({ value: void 0, done: true });
          }
          this.pullQueue.length = 0;
        }
        fail(error) {
          if (this.isStopped)
            return;
          this.isStopped = true;
          this.remove();
          if (this.pullQueue.length) {
            for (const placeholder of this.pullQueue) {
              placeholder.reject(error);
            }
            this.pullQueue.length = 0;
          } else {
            const rejection = Promise.reject(error);
            rejection.catch(() => {
            });
            this.pushQueue.push(rejection);
          }
        }
        remove() {
          Promise.resolve().then(() => {
            if (this.removeCallback)
              this.removeCallback();
          });
        }
        [Symbol.asyncIterator]() {
          return {
            next: (value) => {
              const result = this.pushQueue.shift();
              if (result) {
                if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                  this.isPaused = false;
                  if (this.eventHandlers.lowWater) {
                    this.eventHandlers.lowWater();
                  }
                }
                return result;
              } else if (this.isStopped) {
                return Promise.resolve({ value: void 0, done: true });
              } else {
                return new Promise((resolve, reject) => {
                  this.pullQueue.push({ resolve, reject });
                });
              }
            },
            return: () => {
              this.isStopped = true;
              this.pushQueue.length = 0;
              this.remove();
              return Promise.resolve({ value: void 0, done: true });
            }
          };
        }
      };
      var EventIterator = class {
        constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
          const queue = new EventQueue();
          queue.highWaterMark = highWaterMark;
          queue.lowWaterMark = lowWaterMark;
          queue.removeCallback = listen({
            push: (value) => queue.push(value),
            stop: () => queue.stop(),
            fail: (error) => queue.fail(error),
            on: (event, fn) => {
              queue.eventHandlers[event] = fn;
            }
          }) || (() => {
          });
          this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
          Object.freeze(this);
        }
      };
      exports2.EventIterator = EventIterator;
      exports2.default = EventIterator;
    }
  });

  // node_modules/event-iterator/lib/dom.js
  var require_dom = __commonJS({
    "node_modules/event-iterator/lib/dom.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var event_iterator_1 = require_event_iterator();
      exports2.EventIterator = event_iterator_1.EventIterator;
      function subscribe(event, options, evOptions) {
        return new event_iterator_1.EventIterator(({ push }) => {
          this.addEventListener(event, push, options);
          return () => this.removeEventListener(event, push, options);
        }, evOptions);
      }
      exports2.subscribe = subscribe;
      exports2.default = event_iterator_1.EventIterator;
    }
  });

  // node_modules/it-ws/source.js
  var require_source = __commonJS({
    "node_modules/it-ws/source.js"(exports2, module2) {
      var { Buffer: Buffer2 } = require_buffer();
      var { EventIterator } = require_dom();
      function isArrayBuffer(obj) {
        return obj instanceof ArrayBuffer || obj != null && obj.constructor != null && obj.constructor.name === "ArrayBuffer" && typeof obj.byteLength === "number";
      }
      module2.exports = (socket) => {
        const removeListener = socket.removeEventListener || socket.removeListener;
        const source = async function* () {
          const messages = new EventIterator(({ push, stop, fail }) => {
            socket.addEventListener("message", push);
            socket.addEventListener("error", fail);
            socket.addEventListener("close", stop);
            return () => {
              removeListener.call(socket, "message", push);
              removeListener.call(socket, "error", fail);
              removeListener.call(socket, "close", stop);
            };
          }, { highWaterMark: Infinity });
          for await (const { data } of messages) {
            yield isArrayBuffer(data) ? Buffer2.from(data) : data;
          }
        }();
        let connected = socket.readyState === 1;
        let connError;
        socket.addEventListener("open", () => {
          connected = true;
          connError = null;
        });
        socket.addEventListener("close", () => {
          connected = false;
          connError = null;
        });
        socket.addEventListener("error", (err) => {
          if (!connected)
            connError = err;
        });
        source.connected = () => new Promise((resolve, reject) => {
          if (connected)
            return resolve();
          if (connError)
            return reject(connError);
          const cleanUp = (cont) => {
            removeListener.call(socket, "open", onOpen);
            removeListener.call(socket, "error", onError);
            cont();
          };
          const onOpen = () => cleanUp(resolve);
          const onError = (err) => cleanUp(() => reject(err));
          socket.addEventListener("open", onOpen);
          socket.addEventListener("error", onError);
        });
        return source;
      };
    }
  });

  // node_modules/it-ws/ready.js
  var require_ready = __commonJS({
    "node_modules/it-ws/ready.js"(exports2, module2) {
      module2.exports = async (socket) => {
        if (socket.readyState >= 2) {
          throw new Error("socket closed");
        }
        if (socket.readyState === 1) {
          return;
        }
        return new Promise((resolve, reject) => {
          const remove = socket && (socket.removeEventListener || socket.removeListener);
          function cleanup() {
            if (typeof remove === "function") {
              remove.call(socket, "open", handleOpen);
              remove.call(socket, "error", handleErr);
            }
          }
          function handleOpen() {
            cleanup();
            resolve();
          }
          function handleErr(evt) {
            cleanup();
            reject(evt);
          }
          socket.addEventListener("open", handleOpen);
          socket.addEventListener("error", handleErr);
        });
      };
    }
  });

  // node_modules/it-ws/sink.js
  var require_sink = __commonJS({
    "node_modules/it-ws/sink.js"(exports2, module2) {
      var ready = require_ready();
      module2.exports = (socket, options) => {
        options = options || {};
        options.closeOnEnd = options.closeOnEnd !== false;
        return async (source) => {
          for await (const data of source) {
            try {
              await ready(socket);
            } catch (err) {
              if (err.message === "socket closed")
                break;
              throw err;
            }
            socket.send(data);
          }
          if (options.closeOnEnd && socket.readyState <= 1) {
            return new Promise((resolve, reject) => {
              socket.addEventListener("close", (event) => {
                if (event.wasClean || event.code === 1006) {
                  resolve();
                } else {
                  const err = Object.assign(new Error("ws error"), { event });
                  reject(err);
                }
              });
              setTimeout(() => socket.close());
            });
          }
        };
      };
    }
  });

  // node_modules/it-ws/duplex.js
  var require_duplex = __commonJS({
    "node_modules/it-ws/duplex.js"(exports2, module2) {
      var source = require_source();
      var sink = require_sink();
      module2.exports = (socket, options) => {
        options = options || {};
        if (options.binaryType) {
          socket.binaryType = options.binaryType;
        } else if (options.binary) {
          socket.binaryType = "arraybuffer";
        }
        const duplex = {
          sink: sink(socket, options),
          source: source(socket, options),
          connected: () => duplex.source.connected()
        };
        return duplex;
      };
    }
  });

  // node_modules/iso-url/src/url-browser.js
  var require_url_browser = __commonJS({
    "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
      "use strict";
      var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
      function getDefaultBase() {
        if (isReactNative) {
          return "http://localhost";
        }
        if (!self.location) {
          return "";
        }
        return self.location.protocol + "//" + self.location.host;
      }
      var URL2 = self.URL;
      var defaultBase = getDefaultBase();
      var URLWithLegacySupport = class {
        constructor(url = "", base3 = defaultBase) {
          this.super = new URL2(url, base3);
          this.path = this.pathname + this.search;
          this.auth = this.username && this.password ? this.username + ":" + this.password : null;
          this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
        }
        get hash() {
          return this.super.hash;
        }
        get host() {
          return this.super.host;
        }
        get hostname() {
          return this.super.hostname;
        }
        get href() {
          return this.super.href;
        }
        get origin() {
          return this.super.origin;
        }
        get password() {
          return this.super.password;
        }
        get pathname() {
          return this.super.pathname;
        }
        get port() {
          return this.super.port;
        }
        get protocol() {
          return this.super.protocol;
        }
        get search() {
          return this.super.search;
        }
        get searchParams() {
          return this.super.searchParams;
        }
        get username() {
          return this.super.username;
        }
        set hash(hash) {
          this.super.hash = hash;
        }
        set host(host) {
          this.super.host = host;
        }
        set hostname(hostname) {
          this.super.hostname = hostname;
        }
        set href(href) {
          this.super.href = href;
        }
        set password(password) {
          this.super.password = password;
        }
        set pathname(pathname) {
          this.super.pathname = pathname;
        }
        set port(port) {
          this.super.port = port;
        }
        set protocol(protocol) {
          this.super.protocol = protocol;
        }
        set search(search) {
          this.super.search = search;
        }
        set username(username) {
          this.super.username = username;
        }
        static createObjectURL(o) {
          return URL2.createObjectURL(o);
        }
        static revokeObjectURL(o) {
          URL2.revokeObjectURL(o);
        }
        toJSON() {
          return this.super.toJSON();
        }
        toString() {
          return this.super.toString();
        }
        format() {
          return this.toString();
        }
      };
      function format(obj) {
        if (typeof obj === "string") {
          const url = new URL2(obj);
          return url.toString();
        }
        if (!(obj instanceof URL2)) {
          const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
          const auth = obj.auth ? obj.auth + "@" : "";
          const port = obj.port ? ":" + obj.port : "";
          const protocol = obj.protocol ? obj.protocol + "//" : "";
          const host = obj.host || "";
          const hostname = obj.hostname || "";
          const search = obj.search || (obj.query ? "?" + obj.query : "");
          const hash = obj.hash || "";
          const pathname = obj.pathname || "";
          const path = obj.path || pathname + search;
          return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
        }
      }
      module2.exports = {
        URLWithLegacySupport,
        URLSearchParams: self.URLSearchParams,
        defaultBase,
        format
      };
    }
  });

  // node_modules/iso-url/src/relative.js
  var require_relative = __commonJS({
    "node_modules/iso-url/src/relative.js"(exports2, module2) {
      "use strict";
      var { URLWithLegacySupport, format } = require_url_browser();
      module2.exports = (url, location = {}, protocolMap = {}, defaultProtocol) => {
        let protocol = location.protocol ? location.protocol.replace(":", "") : "http";
        protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
        let urlParsed;
        try {
          urlParsed = new URLWithLegacySupport(url);
        } catch (err) {
          urlParsed = {};
        }
        const base3 = Object.assign({}, location, {
          protocol: protocol || urlParsed.protocol,
          host: location.host || urlParsed.host
        });
        return new URLWithLegacySupport(url, format(base3)).toString();
      };
    }
  });

  // node_modules/iso-url/index.js
  var require_iso_url = __commonJS({
    "node_modules/iso-url/index.js"(exports2, module2) {
      "use strict";
      var {
        URLWithLegacySupport,
        format,
        URLSearchParams: URLSearchParams2,
        defaultBase
      } = require_url_browser();
      var relative = require_relative();
      module2.exports = {
        URL: URLWithLegacySupport,
        URLSearchParams: URLSearchParams2,
        format,
        relative,
        defaultBase
      };
    }
  });

  // node_modules/it-ws/ws-url.js
  var require_ws_url = __commonJS({
    "node_modules/it-ws/ws-url.js"(exports2, module2) {
      var { relative } = require_iso_url();
      var map = { http: "ws", https: "wss" };
      var def = "ws";
      module2.exports = (url, location) => relative(url, location, map, def);
    }
  });

  // node_modules/it-ws/client.js
  var require_client = __commonJS({
    "node_modules/it-ws/client.js"(exports2, module2) {
      "use strict";
      var WebSocket2 = require_web_socket();
      var duplex = require_duplex();
      var wsurl = require_ws_url();
      module2.exports = function(addr, opts = {}) {
        const location = typeof window === "undefined" ? {} : window.location;
        const url = wsurl(addr, location);
        const socket = new WebSocket2(url, opts.websocket);
        const stream = duplex(socket, opts);
        stream.remoteAddress = url;
        stream.close = () => new Promise((resolve, reject) => {
          socket.addEventListener("close", resolve);
          socket.close();
        });
        stream.destroy = () => {
          if (socket.terminate) {
            socket.terminate();
          } else {
            socket.close();
          }
        };
        stream.socket = socket;
        return stream;
      };
      module2.exports.connect = module2.exports;
    }
  });

  // node_modules/class-is/index.js
  var require_class_is = __commonJS({
    "node_modules/class-is/index.js"(exports2, module2) {
      "use strict";
      function withIs(Class, { className, symbolName }) {
        const symbol = Symbol.for(symbolName);
        const ClassIsWrapper = {
          [className]: class extends Class {
            constructor(...args) {
              super(...args);
              Object.defineProperty(this, symbol, { value: true });
            }
            get [Symbol.toStringTag]() {
              return className;
            }
          }
        }[className];
        ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
        return ClassIsWrapper;
      }
      function withIsProto(Class, { className, symbolName, withoutNew }) {
        const symbol = Symbol.for(symbolName);
        const ClassIsWrapper = {
          [className]: function(...args) {
            if (withoutNew && !(this instanceof ClassIsWrapper)) {
              return new ClassIsWrapper(...args);
            }
            const _this = Class.call(this, ...args) || this;
            if (_this && !_this[symbol]) {
              Object.defineProperty(_this, symbol, { value: true });
            }
            return _this;
          }
        }[className];
        ClassIsWrapper.prototype = Object.create(Class.prototype);
        ClassIsWrapper.prototype.constructor = ClassIsWrapper;
        Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
          get() {
            return className;
          }
        });
        ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
        return ClassIsWrapper;
      }
      module2.exports = withIs;
      module2.exports.proto = withIsProto;
    }
  });

  // node_modules/ip-regex/index.js
  var require_ip_regex = __commonJS({
    "node_modules/ip-regex/index.js"(exports2, module2) {
      "use strict";
      var word = "[a-fA-F\\d:]";
      var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
      var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
      var v6seg = "[a-fA-F\\d]{1,4}";
      var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
      var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
      var v4exact = new RegExp(`^${v4}$`);
      var v6exact = new RegExp(`^${v6}$`);
      var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
      ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
      ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
      module2.exports = ip;
    }
  });

  // node_modules/is-ip/index.js
  var require_is_ip = __commonJS({
    "node_modules/is-ip/index.js"(exports2, module2) {
      "use strict";
      var ipRegex = require_ip_regex();
      var isIp = (string2) => ipRegex({ exact: true }).test(string2);
      isIp.v4 = (string2) => ipRegex.v4({ exact: true }).test(string2);
      isIp.v6 = (string2) => ipRegex.v6({ exact: true }).test(string2);
      isIp.version = (string2) => isIp(string2) ? isIp.v4(string2) ? 4 : 6 : void 0;
      module2.exports = isIp;
    }
  });

  // node_modules/multiformats/esm/vendor/base-x.js
  function base(ALPHABET, name) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode3(source) {
      if (source instanceof Uint8Array)
        ;
      else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length2 = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length2) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        pbegin++;
      }
      var it2 = size - length2;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length2 = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length2) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length2 = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length2;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode5(string2) {
      var buffer = decodeUnsafe(string2);
      if (buffer) {
        return buffer;
      }
      throw new Error(`Non-${name} character`);
    }
    return {
      encode: encode3,
      decodeUnsafe,
      decode: decode5
    };
  }
  var src, _brrp__multiformats_scope_baseX, base_x_default;
  var init_base_x = __esm({
    "node_modules/multiformats/esm/vendor/base-x.js"() {
      src = base;
      _brrp__multiformats_scope_baseX = src;
      base_x_default = _brrp__multiformats_scope_baseX;
    }
  });

  // node_modules/multiformats/esm/src/bytes.js
  var empty, equals, coerce, fromString, toString;
  var init_bytes = __esm({
    "node_modules/multiformats/esm/src/bytes.js"() {
      empty = new Uint8Array(0);
      equals = (aa, bb) => {
        if (aa === bb)
          return true;
        if (aa.byteLength !== bb.byteLength) {
          return false;
        }
        for (let ii = 0; ii < aa.byteLength; ii++) {
          if (aa[ii] !== bb[ii]) {
            return false;
          }
        }
        return true;
      };
      coerce = (o) => {
        if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
          return o;
        if (o instanceof ArrayBuffer)
          return new Uint8Array(o);
        if (ArrayBuffer.isView(o)) {
          return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
        }
        throw new Error("Unknown type, must be binary type");
      };
      fromString = (str) => new TextEncoder().encode(str);
      toString = (b) => new TextDecoder().decode(b);
    }
  });

  // node_modules/multiformats/esm/src/bases/base.js
  var Encoder, Decoder, ComposedDecoder, or, Codec, from, baseX, decode, encode, rfc4648;
  var init_base = __esm({
    "node_modules/multiformats/esm/src/bases/base.js"() {
      init_base_x();
      init_bytes();
      Encoder = class {
        constructor(name, prefix, baseEncode) {
          this.name = name;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
        }
        encode(bytes) {
          if (bytes instanceof Uint8Array) {
            return `${this.prefix}${this.baseEncode(bytes)}`;
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
      Decoder = class {
        constructor(name, prefix, baseDecode) {
          this.name = name;
          this.prefix = prefix;
          this.baseDecode = baseDecode;
        }
        decode(text) {
          if (typeof text === "string") {
            switch (text[0]) {
              case this.prefix: {
                return this.baseDecode(text.slice(1));
              }
              default: {
                throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
              }
            }
          } else {
            throw Error("Can only multibase decode strings");
          }
        }
        or(decoder) {
          return or(this, decoder);
        }
      };
      ComposedDecoder = class {
        constructor(decoders) {
          this.decoders = decoders;
        }
        or(decoder) {
          return or(this, decoder);
        }
        decode(input) {
          const prefix = input[0];
          const decoder = this.decoders[prefix];
          if (decoder) {
            return decoder.decode(input);
          } else {
            throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
          }
        }
      };
      or = (left, right) => new ComposedDecoder({
        ...left.decoders || { [left.prefix]: left },
        ...right.decoders || { [right.prefix]: right }
      });
      Codec = class {
        constructor(name, prefix, baseEncode, baseDecode) {
          this.name = name;
          this.prefix = prefix;
          this.baseEncode = baseEncode;
          this.baseDecode = baseDecode;
          this.encoder = new Encoder(name, prefix, baseEncode);
          this.decoder = new Decoder(name, prefix, baseDecode);
        }
        encode(input) {
          return this.encoder.encode(input);
        }
        decode(input) {
          return this.decoder.decode(input);
        }
      };
      from = ({ name, prefix, encode: encode3, decode: decode5 }) => new Codec(name, prefix, encode3, decode5);
      baseX = ({ prefix, name, alphabet }) => {
        const { encode: encode3, decode: decode5 } = base_x_default(alphabet, name);
        return from({
          prefix,
          name,
          encode: encode3,
          decode: (text) => coerce(decode5(text))
        });
      };
      decode = (string2, alphabet, bitsPerChar, name) => {
        const codes = {};
        for (let i = 0; i < alphabet.length; ++i) {
          codes[alphabet[i]] = i;
        }
        let end = string2.length;
        while (string2[end - 1] === "=") {
          --end;
        }
        const out = new Uint8Array(end * bitsPerChar / 8 | 0);
        let bits = 0;
        let buffer = 0;
        let written = 0;
        for (let i = 0; i < end; ++i) {
          const value = codes[string2[i]];
          if (value === void 0) {
            throw new SyntaxError(`Non-${name} character`);
          }
          buffer = buffer << bitsPerChar | value;
          bits += bitsPerChar;
          if (bits >= 8) {
            bits -= 8;
            out[written++] = 255 & buffer >> bits;
          }
        }
        if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
          throw new SyntaxError("Unexpected end of data");
        }
        return out;
      };
      encode = (data, alphabet, bitsPerChar) => {
        const pad = alphabet[alphabet.length - 1] === "=";
        const mask = (1 << bitsPerChar) - 1;
        let out = "";
        let bits = 0;
        let buffer = 0;
        for (let i = 0; i < data.length; ++i) {
          buffer = buffer << 8 | data[i];
          bits += 8;
          while (bits > bitsPerChar) {
            bits -= bitsPerChar;
            out += alphabet[mask & buffer >> bits];
          }
        }
        if (bits) {
          out += alphabet[mask & buffer << bitsPerChar - bits];
        }
        if (pad) {
          while (out.length * bitsPerChar & 7) {
            out += "=";
          }
        }
        return out;
      };
      rfc4648 = ({ name, prefix, bitsPerChar, alphabet }) => {
        return from({
          prefix,
          name,
          encode(input) {
            return encode(input, alphabet, bitsPerChar);
          },
          decode(input) {
            return decode(input, alphabet, bitsPerChar, name);
          }
        });
      };
    }
  });

  // node_modules/multiformats/esm/src/bases/identity.js
  var identity_exports = {};
  __export(identity_exports, {
    identity: () => identity
  });
  var identity;
  var init_identity = __esm({
    "node_modules/multiformats/esm/src/bases/identity.js"() {
      init_base();
      init_bytes();
      identity = from({
        prefix: "\0",
        name: "identity",
        encode: (buf) => toString(buf),
        decode: (str) => fromString(str)
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base2.js
  var base2_exports = {};
  __export(base2_exports, {
    base2: () => base2
  });
  var base2;
  var init_base2 = __esm({
    "node_modules/multiformats/esm/src/bases/base2.js"() {
      init_base();
      base2 = rfc4648({
        prefix: "0",
        name: "base2",
        alphabet: "01",
        bitsPerChar: 1
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base8.js
  var base8_exports = {};
  __export(base8_exports, {
    base8: () => base8
  });
  var base8;
  var init_base8 = __esm({
    "node_modules/multiformats/esm/src/bases/base8.js"() {
      init_base();
      base8 = rfc4648({
        prefix: "7",
        name: "base8",
        alphabet: "01234567",
        bitsPerChar: 3
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base10.js
  var base10_exports = {};
  __export(base10_exports, {
    base10: () => base10
  });
  var base10;
  var init_base10 = __esm({
    "node_modules/multiformats/esm/src/bases/base10.js"() {
      init_base();
      base10 = baseX({
        prefix: "9",
        name: "base10",
        alphabet: "0123456789"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base16.js
  var base16_exports = {};
  __export(base16_exports, {
    base16: () => base16,
    base16upper: () => base16upper
  });
  var base16, base16upper;
  var init_base16 = __esm({
    "node_modules/multiformats/esm/src/bases/base16.js"() {
      init_base();
      base16 = rfc4648({
        prefix: "f",
        name: "base16",
        alphabet: "0123456789abcdef",
        bitsPerChar: 4
      });
      base16upper = rfc4648({
        prefix: "F",
        name: "base16upper",
        alphabet: "0123456789ABCDEF",
        bitsPerChar: 4
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base32.js
  var base32_exports = {};
  __export(base32_exports, {
    base32: () => base32,
    base32hex: () => base32hex,
    base32hexpad: () => base32hexpad,
    base32hexpadupper: () => base32hexpadupper,
    base32hexupper: () => base32hexupper,
    base32pad: () => base32pad,
    base32padupper: () => base32padupper,
    base32upper: () => base32upper,
    base32z: () => base32z
  });
  var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
  var init_base32 = __esm({
    "node_modules/multiformats/esm/src/bases/base32.js"() {
      init_base();
      base32 = rfc4648({
        prefix: "b",
        name: "base32",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567",
        bitsPerChar: 5
      });
      base32upper = rfc4648({
        prefix: "B",
        name: "base32upper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
        bitsPerChar: 5
      });
      base32pad = rfc4648({
        prefix: "c",
        name: "base32pad",
        alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
        bitsPerChar: 5
      });
      base32padupper = rfc4648({
        prefix: "C",
        name: "base32padupper",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
        bitsPerChar: 5
      });
      base32hex = rfc4648({
        prefix: "v",
        name: "base32hex",
        alphabet: "0123456789abcdefghijklmnopqrstuv",
        bitsPerChar: 5
      });
      base32hexupper = rfc4648({
        prefix: "V",
        name: "base32hexupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
        bitsPerChar: 5
      });
      base32hexpad = rfc4648({
        prefix: "t",
        name: "base32hexpad",
        alphabet: "0123456789abcdefghijklmnopqrstuv=",
        bitsPerChar: 5
      });
      base32hexpadupper = rfc4648({
        prefix: "T",
        name: "base32hexpadupper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
        bitsPerChar: 5
      });
      base32z = rfc4648({
        prefix: "h",
        name: "base32z",
        alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
        bitsPerChar: 5
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base36.js
  var base36_exports = {};
  __export(base36_exports, {
    base36: () => base36,
    base36upper: () => base36upper
  });
  var base36, base36upper;
  var init_base36 = __esm({
    "node_modules/multiformats/esm/src/bases/base36.js"() {
      init_base();
      base36 = baseX({
        prefix: "k",
        name: "base36",
        alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
      });
      base36upper = baseX({
        prefix: "K",
        name: "base36upper",
        alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base58.js
  var base58_exports = {};
  __export(base58_exports, {
    base58btc: () => base58btc,
    base58flickr: () => base58flickr
  });
  var base58btc, base58flickr;
  var init_base58 = __esm({
    "node_modules/multiformats/esm/src/bases/base58.js"() {
      init_base();
      base58btc = baseX({
        name: "base58btc",
        prefix: "z",
        alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
      });
      base58flickr = baseX({
        name: "base58flickr",
        prefix: "Z",
        alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
      });
    }
  });

  // node_modules/multiformats/esm/src/bases/base64.js
  var base64_exports = {};
  __export(base64_exports, {
    base64: () => base64,
    base64pad: () => base64pad,
    base64url: () => base64url,
    base64urlpad: () => base64urlpad
  });
  var base64, base64pad, base64url, base64urlpad;
  var init_base64 = __esm({
    "node_modules/multiformats/esm/src/bases/base64.js"() {
      init_base();
      base64 = rfc4648({
        prefix: "m",
        name: "base64",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
        bitsPerChar: 6
      });
      base64pad = rfc4648({
        prefix: "M",
        name: "base64pad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
        bitsPerChar: 6
      });
      base64url = rfc4648({
        prefix: "u",
        name: "base64url",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
        bitsPerChar: 6
      });
      base64urlpad = rfc4648({
        prefix: "U",
        name: "base64urlpad",
        alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
        bitsPerChar: 6
      });
    }
  });

  // node_modules/multiformats/esm/vendor/varint.js
  function encode2(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode2.bytes = offset - oldOffset + 1;
    return out;
  }
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB$1);
    read.bytes = counter - offset;
    return res;
  }
  var encode_1, MSB, REST, MSBALL, INT, decode2, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
  var init_varint = __esm({
    "node_modules/multiformats/esm/vendor/varint.js"() {
      encode_1 = encode2;
      MSB = 128;
      REST = 127;
      MSBALL = ~REST;
      INT = Math.pow(2, 31);
      decode2 = read;
      MSB$1 = 128;
      REST$1 = 127;
      N1 = Math.pow(2, 7);
      N2 = Math.pow(2, 14);
      N3 = Math.pow(2, 21);
      N4 = Math.pow(2, 28);
      N5 = Math.pow(2, 35);
      N6 = Math.pow(2, 42);
      N7 = Math.pow(2, 49);
      N8 = Math.pow(2, 56);
      N9 = Math.pow(2, 63);
      length = function(value) {
        return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
      };
      varint = {
        encode: encode_1,
        decode: decode2,
        encodingLength: length
      };
      _brrp_varint = varint;
      varint_default = _brrp_varint;
    }
  });

  // node_modules/multiformats/esm/src/varint.js
  var decode3, encodeTo, encodingLength;
  var init_varint2 = __esm({
    "node_modules/multiformats/esm/src/varint.js"() {
      init_varint();
      decode3 = (data) => {
        const code = varint_default.decode(data);
        return [
          code,
          varint_default.decode.bytes
        ];
      };
      encodeTo = (int, target, offset = 0) => {
        varint_default.encode(int, target, offset);
        return target;
      };
      encodingLength = (int) => {
        return varint_default.encodingLength(int);
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/digest.js
  var digest_exports = {};
  __export(digest_exports, {
    Digest: () => Digest,
    create: () => create,
    decode: () => decode4,
    equals: () => equals2
  });
  var create, decode4, equals2, Digest;
  var init_digest = __esm({
    "node_modules/multiformats/esm/src/hashes/digest.js"() {
      init_bytes();
      init_varint2();
      create = (code, digest) => {
        const size = digest.byteLength;
        const sizeOffset = encodingLength(code);
        const digestOffset = sizeOffset + encodingLength(size);
        const bytes = new Uint8Array(digestOffset + size);
        encodeTo(code, bytes, 0);
        encodeTo(size, bytes, sizeOffset);
        bytes.set(digest, digestOffset);
        return new Digest(code, size, digest, bytes);
      };
      decode4 = (multihash) => {
        const bytes = coerce(multihash);
        const [code, sizeOffset] = decode3(bytes);
        const [size, digestOffset] = decode3(bytes.subarray(sizeOffset));
        const digest = bytes.subarray(sizeOffset + digestOffset);
        if (digest.byteLength !== size) {
          throw new Error("Incorrect length");
        }
        return new Digest(code, size, digest, bytes);
      };
      equals2 = (a, b) => {
        if (a === b) {
          return true;
        } else {
          return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
        }
      };
      Digest = class {
        constructor(code, size, digest, bytes) {
          this.code = code;
          this.size = size;
          this.digest = digest;
          this.bytes = bytes;
        }
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/hasher.js
  var from2, Hasher;
  var init_hasher = __esm({
    "node_modules/multiformats/esm/src/hashes/hasher.js"() {
      init_digest();
      from2 = ({ name, code, encode: encode3 }) => new Hasher(name, code, encode3);
      Hasher = class {
        constructor(name, code, encode3) {
          this.name = name;
          this.code = code;
          this.encode = encode3;
        }
        async digest(input) {
          if (input instanceof Uint8Array) {
            const digest = await this.encode(input);
            return create(this.code, digest);
          } else {
            throw Error("Unknown type, must be binary type");
          }
        }
      };
    }
  });

  // node_modules/multiformats/esm/src/hashes/sha2-browser.js
  var sha2_browser_exports = {};
  __export(sha2_browser_exports, {
    sha256: () => sha256,
    sha512: () => sha512
  });
  var sha, sha256, sha512;
  var init_sha2_browser = __esm({
    "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
      init_hasher();
      sha = (name) => async (data) => new Uint8Array(await crypto.subtle.digest(name, data));
      sha256 = from2({
        name: "sha2-256",
        code: 18,
        encode: sha("SHA-256")
      });
      sha512 = from2({
        name: "sha2-512",
        code: 19,
        encode: sha("SHA-512")
      });
    }
  });

  // node_modules/multiformats/esm/src/hashes/identity.js
  var identity_exports2 = {};
  __export(identity_exports2, {
    identity: () => identity2
  });
  var identity2;
  var init_identity2 = __esm({
    "node_modules/multiformats/esm/src/hashes/identity.js"() {
      init_hasher();
      init_bytes();
      identity2 = from2({
        name: "identity",
        code: 0,
        encode: (input) => coerce(input)
      });
    }
  });

  // node_modules/multiformats/esm/src/codecs/raw.js
  var init_raw = __esm({
    "node_modules/multiformats/esm/src/codecs/raw.js"() {
      init_bytes();
    }
  });

  // node_modules/multiformats/esm/src/codecs/json.js
  var textEncoder, textDecoder;
  var init_json = __esm({
    "node_modules/multiformats/esm/src/codecs/json.js"() {
      textEncoder = new TextEncoder();
      textDecoder = new TextDecoder();
    }
  });

  // node_modules/multiformats/esm/src/cid.js
  var cid_exports = {};
  __export(cid_exports, {
    CID: () => CID
  });
  var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
  var init_cid = __esm({
    "node_modules/multiformats/esm/src/cid.js"() {
      init_varint2();
      init_digest();
      init_base58();
      init_base32();
      init_bytes();
      CID = class {
        constructor(version2, code, multihash, bytes) {
          this.code = code;
          this.version = version2;
          this.multihash = multihash;
          this.bytes = bytes;
          this.byteOffset = bytes.byteOffset;
          this.byteLength = bytes.byteLength;
          this.asCID = this;
          this._baseCache = /* @__PURE__ */ new Map();
          Object.defineProperties(this, {
            byteOffset: hidden,
            byteLength: hidden,
            code: readonly,
            version: readonly,
            multihash: readonly,
            bytes: readonly,
            _baseCache: hidden,
            asCID: hidden
          });
        }
        toV0() {
          switch (this.version) {
            case 0: {
              return this;
            }
            default: {
              const { code, multihash } = this;
              if (code !== DAG_PB_CODE) {
                throw new Error("Cannot convert a non dag-pb CID to CIDv0");
              }
              if (multihash.code !== SHA_256_CODE) {
                throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
              }
              return CID.createV0(multihash);
            }
          }
        }
        toV1() {
          switch (this.version) {
            case 0: {
              const { code, digest } = this.multihash;
              const multihash = create(code, digest);
              return CID.createV1(this.code, multihash);
            }
            case 1: {
              return this;
            }
            default: {
              throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
            }
          }
        }
        equals(other) {
          return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
        }
        toString(base3) {
          const { bytes, version: version2, _baseCache } = this;
          switch (version2) {
            case 0:
              return toStringV0(bytes, _baseCache, base3 || base58btc.encoder);
            default:
              return toStringV1(bytes, _baseCache, base3 || base32.encoder);
          }
        }
        toJSON() {
          return {
            code: this.code,
            version: this.version,
            hash: this.multihash.bytes
          };
        }
        get [Symbol.toStringTag]() {
          return "CID";
        }
        [Symbol.for("nodejs.util.inspect.custom")]() {
          return "CID(" + this.toString() + ")";
        }
        static isCID(value) {
          deprecate(/^0\.0/, IS_CID_DEPRECATION);
          return !!(value && (value[cidSymbol] || value.asCID === value));
        }
        get toBaseEncodedString() {
          throw new Error("Deprecated, use .toString()");
        }
        get codec() {
          throw new Error('"codec" property is deprecated, use integer "code" property instead');
        }
        get buffer() {
          throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
        }
        get multibaseName() {
          throw new Error('"multibaseName" property is deprecated');
        }
        get prefix() {
          throw new Error('"prefix" property is deprecated');
        }
        static asCID(value) {
          if (value instanceof CID) {
            return value;
          } else if (value != null && value.asCID === value) {
            const { version: version2, code, multihash, bytes } = value;
            return new CID(version2, code, multihash, bytes || encodeCID(version2, code, multihash.bytes));
          } else if (value != null && value[cidSymbol] === true) {
            const { version: version2, multihash, code } = value;
            const digest = decode4(multihash);
            return CID.create(version2, code, digest);
          } else {
            return null;
          }
        }
        static create(version2, code, digest) {
          if (typeof code !== "number") {
            throw new Error("String codecs are no longer supported");
          }
          switch (version2) {
            case 0: {
              if (code !== DAG_PB_CODE) {
                throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
              } else {
                return new CID(version2, code, digest, digest.bytes);
              }
            }
            case 1: {
              const bytes = encodeCID(version2, code, digest.bytes);
              return new CID(version2, code, digest, bytes);
            }
            default: {
              throw new Error("Invalid version");
            }
          }
        }
        static createV0(digest) {
          return CID.create(0, DAG_PB_CODE, digest);
        }
        static createV1(code, digest) {
          return CID.create(1, code, digest);
        }
        static decode(bytes) {
          const [cid, remainder] = CID.decodeFirst(bytes);
          if (remainder.length) {
            throw new Error("Incorrect length");
          }
          return cid;
        }
        static decodeFirst(bytes) {
          const specs = CID.inspectBytes(bytes);
          const prefixSize = specs.size - specs.multihashSize;
          const multihashBytes = coerce(bytes.subarray(prefixSize, prefixSize + specs.multihashSize));
          if (multihashBytes.byteLength !== specs.multihashSize) {
            throw new Error("Incorrect length");
          }
          const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
          const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
          const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
          return [
            cid,
            bytes.subarray(specs.size)
          ];
        }
        static inspectBytes(initialBytes) {
          let offset = 0;
          const next = () => {
            const [i, length2] = decode3(initialBytes.subarray(offset));
            offset += length2;
            return i;
          };
          let version2 = next();
          let codec = DAG_PB_CODE;
          if (version2 === 18) {
            version2 = 0;
            offset = 0;
          } else if (version2 === 1) {
            codec = next();
          }
          if (version2 !== 0 && version2 !== 1) {
            throw new RangeError(`Invalid CID version ${version2}`);
          }
          const prefixSize = offset;
          const multihashCode = next();
          const digestSize = next();
          const size = offset + digestSize;
          const multihashSize = size - prefixSize;
          return {
            version: version2,
            codec,
            multihashCode,
            digestSize,
            multihashSize,
            size
          };
        }
        static parse(source, base3) {
          const [prefix, bytes] = parseCIDtoBytes(source, base3);
          const cid = CID.decode(bytes);
          cid._baseCache.set(prefix, source);
          return cid;
        }
      };
      parseCIDtoBytes = (source, base3) => {
        switch (source[0]) {
          case "Q": {
            const decoder = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder.decode(`${base58btc.prefix}${source}`)
            ];
          }
          case base58btc.prefix: {
            const decoder = base3 || base58btc;
            return [
              base58btc.prefix,
              decoder.decode(source)
            ];
          }
          case base32.prefix: {
            const decoder = base3 || base32;
            return [
              base32.prefix,
              decoder.decode(source)
            ];
          }
          default: {
            if (base3 == null) {
              throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
            }
            return [
              source[0],
              base3.decode(source)
            ];
          }
        }
      };
      toStringV0 = (bytes, cache, base3) => {
        const { prefix } = base3;
        if (prefix !== base58btc.prefix) {
          throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
        }
        const cid = cache.get(prefix);
        if (cid == null) {
          const cid2 = base3.encode(bytes).slice(1);
          cache.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      toStringV1 = (bytes, cache, base3) => {
        const { prefix } = base3;
        const cid = cache.get(prefix);
        if (cid == null) {
          const cid2 = base3.encode(bytes);
          cache.set(prefix, cid2);
          return cid2;
        } else {
          return cid;
        }
      };
      DAG_PB_CODE = 112;
      SHA_256_CODE = 18;
      encodeCID = (version2, code, multihash) => {
        const codeOffset = encodingLength(version2);
        const hashOffset = codeOffset + encodingLength(code);
        const bytes = new Uint8Array(hashOffset + multihash.byteLength);
        encodeTo(version2, bytes, 0);
        encodeTo(code, bytes, codeOffset);
        bytes.set(multihash, hashOffset);
        return bytes;
      };
      cidSymbol = Symbol.for("@ipld/js-cid/CID");
      readonly = {
        writable: false,
        configurable: false,
        enumerable: true
      };
      hidden = {
        writable: false,
        enumerable: false,
        configurable: false
      };
      version = "0.0.0-dev";
      deprecate = (range, message) => {
        if (range.test(version)) {
          console.warn(message);
        } else {
          throw new Error(message);
        }
      };
      IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
    }
  });

  // node_modules/multiformats/esm/src/index.js
  var init_src = __esm({
    "node_modules/multiformats/esm/src/index.js"() {
      init_cid();
      init_varint2();
      init_bytes();
      init_hasher();
      init_digest();
    }
  });

  // node_modules/multiformats/esm/src/basics.js
  var bases, hashes;
  var init_basics = __esm({
    "node_modules/multiformats/esm/src/basics.js"() {
      init_identity();
      init_base2();
      init_base8();
      init_base10();
      init_base16();
      init_base32();
      init_base36();
      init_base58();
      init_base64();
      init_sha2_browser();
      init_identity2();
      init_raw();
      init_json();
      init_src();
      bases = {
        ...identity_exports,
        ...base2_exports,
        ...base8_exports,
        ...base10_exports,
        ...base16_exports,
        ...base32_exports,
        ...base36_exports,
        ...base58_exports,
        ...base64_exports
      };
      hashes = {
        ...sha2_browser_exports,
        ...identity_exports2
      };
    }
  });

  // node_modules/uint8arrays/esm/src/util/bases.js
  function createCodec(name, prefix, encode3, decode5) {
    return {
      name,
      prefix,
      encoder: {
        name,
        prefix,
        encode: encode3
      },
      decoder: { decode: decode5 }
    };
  }
  var string, ascii, BASES, bases_default;
  var init_bases = __esm({
    "node_modules/uint8arrays/esm/src/util/bases.js"() {
      init_basics();
      string = createCodec("utf8", "u", (buf) => {
        const decoder = new TextDecoder("utf8");
        return "u" + decoder.decode(buf);
      }, (str) => {
        const encoder = new TextEncoder();
        return encoder.encode(str.substring(1));
      });
      ascii = createCodec("ascii", "a", (buf) => {
        let string2 = "a";
        for (let i = 0; i < buf.length; i++) {
          string2 += String.fromCharCode(buf[i]);
        }
        return string2;
      }, (str) => {
        str = str.substring(1);
        const buf = new Uint8Array(str.length);
        for (let i = 0; i < str.length; i++) {
          buf[i] = str.charCodeAt(i);
        }
        return buf;
      });
      BASES = {
        utf8: string,
        "utf-8": string,
        hex: bases.base16,
        latin1: ascii,
        ascii,
        binary: ascii,
        ...bases
      };
      bases_default = BASES;
    }
  });

  // node_modules/uint8arrays/esm/src/to-string.js
  var to_string_exports = {};
  __export(to_string_exports, {
    toString: () => toString2
  });
  function toString2(array, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.encoder.encode(array).substring(1);
  }
  var init_to_string = __esm({
    "node_modules/uint8arrays/esm/src/to-string.js"() {
      init_bases();
    }
  });

  // node_modules/multiaddr/src/ip.js
  var require_ip = __commonJS({
    "node_modules/multiaddr/src/ip.js"(exports2, module2) {
      "use strict";
      var isIp = require_is_ip();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var isIP = isIp;
      var isV4 = isIp.v4;
      var isV6 = isIp.v6;
      var toBytes = function(ip, buff, offset) {
        offset = ~~offset;
        let result;
        if (isV4(ip)) {
          result = buff || new Uint8Array(offset + 4);
          ip.split(/\./g).map(function(byte) {
            result[offset++] = parseInt(byte, 10) & 255;
          });
        } else if (isV6(ip)) {
          const sections = ip.split(":", 8);
          let i;
          for (i = 0; i < sections.length; i++) {
            const isv4 = isV4(sections[i]);
            let v4Buffer;
            if (isv4) {
              v4Buffer = toBytes(sections[i]);
              sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
            }
            if (v4Buffer && ++i < 8) {
              sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
            }
          }
          if (sections[0] === "") {
            while (sections.length < 8)
              sections.unshift("0");
          } else if (sections[sections.length - 1] === "") {
            while (sections.length < 8)
              sections.push("0");
          } else if (sections.length < 8) {
            for (i = 0; i < sections.length && sections[i] !== ""; i++)
              ;
            const argv = [i, "1"];
            for (i = 9 - sections.length; i > 0; i--) {
              argv.push("0");
            }
            sections.splice.apply(sections, argv);
          }
          result = buff || new Uint8Array(offset + 16);
          for (i = 0; i < sections.length; i++) {
            const word = parseInt(sections[i], 16);
            result[offset++] = word >> 8 & 255;
            result[offset++] = word & 255;
          }
        }
        if (!result) {
          throw Error("Invalid ip address: " + ip);
        }
        return result;
      };
      var toString3 = function(buff, offset, length2) {
        offset = ~~offset;
        length2 = length2 || buff.length - offset;
        const result = [];
        let string2;
        const view = new DataView(buff.buffer);
        if (length2 === 4) {
          for (let i = 0; i < length2; i++) {
            result.push(buff[offset + i]);
          }
          string2 = result.join(".");
        } else if (length2 === 16) {
          for (let i = 0; i < length2; i += 2) {
            result.push(view.getUint16(offset + i).toString(16));
          }
          string2 = result.join(":");
          string2 = string2.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
          string2 = string2.replace(/:{3,4}/, "::");
        }
        return string2;
      };
      module2.exports = {
        isIP,
        isV4,
        isV6,
        toBytes,
        toString: toString3
      };
    }
  });

  // node_modules/multiaddr/src/protocols-table.js
  var require_protocols_table = __commonJS({
    "node_modules/multiaddr/src/protocols-table.js"(exports2, module2) {
      "use strict";
      function Protocols(proto) {
        if (typeof proto === "number") {
          if (Protocols.codes[proto]) {
            return Protocols.codes[proto];
          }
          throw new Error("no protocol with code: " + proto);
        } else if (typeof proto === "string") {
          if (Protocols.names[proto]) {
            return Protocols.names[proto];
          }
          throw new Error("no protocol with name: " + proto);
        }
        throw new Error("invalid protocol id type: " + proto);
      }
      var V = -1;
      Protocols.lengthPrefixedVarSize = V;
      Protocols.V = V;
      Protocols.table = [
        [4, 32, "ip4"],
        [6, 16, "tcp"],
        [33, 16, "dccp"],
        [41, 128, "ip6"],
        [42, V, "ip6zone"],
        [53, V, "dns", "resolvable"],
        [54, V, "dns4", "resolvable"],
        [55, V, "dns6", "resolvable"],
        [56, V, "dnsaddr", "resolvable"],
        [132, 16, "sctp"],
        [273, 16, "udp"],
        [275, 0, "p2p-webrtc-star"],
        [276, 0, "p2p-webrtc-direct"],
        [277, 0, "p2p-stardust"],
        [290, 0, "p2p-circuit"],
        [301, 0, "udt"],
        [302, 0, "utp"],
        [400, V, "unix", false, "path"],
        [421, V, "ipfs"],
        [421, V, "p2p"],
        [443, 0, "https"],
        [444, 96, "onion"],
        [445, 296, "onion3"],
        [446, V, "garlic64"],
        [460, 0, "quic"],
        [477, 0, "ws"],
        [478, 0, "wss"],
        [479, 0, "p2p-websocket-star"],
        [480, 0, "http"],
        [777, V, "memory"]
      ];
      Protocols.names = {};
      Protocols.codes = {};
      Protocols.table.map((row) => {
        const proto = p.apply(null, row);
        Protocols.codes[proto.code] = proto;
        Protocols.names[proto.name] = proto;
        return null;
      });
      Protocols.object = p;
      function p(code, size, name, resolvable, path) {
        return {
          code,
          size,
          name,
          resolvable: Boolean(resolvable),
          path: Boolean(path)
        };
      }
      module2.exports = Protocols;
    }
  });

  // node_modules/varint/encode.js
  var require_encode = __commonJS({
    "node_modules/varint/encode.js"(exports2, module2) {
      module2.exports = encode3;
      var MSB2 = 128;
      var REST2 = 127;
      var MSBALL2 = ~REST2;
      var INT2 = Math.pow(2, 31);
      function encode3(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode3.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT2) {
          out[offset++] = num & 255 | MSB2;
          num /= 128;
        }
        while (num & MSBALL2) {
          out[offset++] = num & 255 | MSB2;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode3.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/varint/decode.js
  var require_decode = __commonJS({
    "node_modules/varint/decode.js"(exports2, module2) {
      module2.exports = read2;
      var MSB2 = 128;
      var REST2 = 127;
      function read2(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l || shift > 49) {
            read2.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB2);
        read2.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/varint/length.js
  var require_length = __commonJS({
    "node_modules/varint/length.js"(exports2, module2) {
      var N12 = Math.pow(2, 7);
      var N22 = Math.pow(2, 14);
      var N32 = Math.pow(2, 21);
      var N42 = Math.pow(2, 28);
      var N52 = Math.pow(2, 35);
      var N62 = Math.pow(2, 42);
      var N72 = Math.pow(2, 49);
      var N82 = Math.pow(2, 56);
      var N92 = Math.pow(2, 63);
      module2.exports = function(value) {
        return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
      };
    }
  });

  // node_modules/varint/index.js
  var require_varint = __commonJS({
    "node_modules/varint/index.js"(exports2, module2) {
      module2.exports = {
        encode: require_encode(),
        decode: require_decode(),
        encodingLength: require_length()
      };
    }
  });

  // node_modules/uint8arrays/esm/src/from-string.js
  var from_string_exports = {};
  __export(from_string_exports, {
    fromString: () => fromString2
  });
  function fromString2(string2, encoding = "utf8") {
    const base3 = bases_default[encoding];
    if (!base3) {
      throw new Error(`Unsupported encoding "${encoding}"`);
    }
    return base3.decoder.decode(`${base3.prefix}${string2}`);
  }
  var init_from_string = __esm({
    "node_modules/uint8arrays/esm/src/from-string.js"() {
      init_bases();
    }
  });

  // node_modules/uint8arrays/esm/src/concat.js
  var concat_exports = {};
  __export(concat_exports, {
    concat: () => concat
  });
  function concat(arrays, length2) {
    if (!length2) {
      length2 = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length2);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  var init_concat = __esm({
    "node_modules/uint8arrays/esm/src/concat.js"() {
    }
  });

  // node_modules/multiaddr/src/convert.js
  var require_convert = __commonJS({
    "node_modules/multiaddr/src/convert.js"(exports2, module2) {
      "use strict";
      var ip = require_ip();
      var protocols = require_protocols_table();
      var { CID: CID2 } = (init_cid(), cid_exports);
      var { base32: base322 } = (init_base32(), base32_exports);
      var { base58btc: base58btc2 } = (init_base58(), base58_exports);
      var Digest4 = (init_digest(), digest_exports);
      var varint4 = require_varint();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      module2.exports = Convert;
      function Convert(proto, a) {
        if (a instanceof Uint8Array) {
          return Convert.toString(proto, a);
        } else {
          return Convert.toBytes(proto, a);
        }
      }
      Convert.toString = function convertToString(proto, buf) {
        const protocol = protocols(proto);
        switch (protocol.code) {
          case 4:
          case 41:
            return bytes2ip(buf);
          case 6:
          case 273:
          case 33:
          case 132:
            return bytes2port(buf).toString();
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return bytes2str(buf);
          case 421:
            return bytes2mh(buf);
          case 444:
            return bytes2onion(buf);
          case 445:
            return bytes2onion(buf);
          default:
            return uint8ArrayToString(buf, "base16");
        }
      };
      Convert.toBytes = function convertToBytes(proto, str) {
        const protocol = protocols(proto);
        switch (protocol.code) {
          case 4:
            return ip2bytes(str);
          case 41:
            return ip2bytes(str);
          case 6:
          case 273:
          case 33:
          case 132:
            return port2bytes(parseInt(str, 10));
          case 53:
          case 54:
          case 55:
          case 56:
          case 400:
          case 777:
            return str2bytes(str);
          case 421:
            return mh2bytes(str);
          case 444:
            return onion2bytes(str);
          case 445:
            return onion32bytes(str);
          default:
            return uint8ArrayFromString(str, "base16");
        }
      };
      function ip2bytes(ipString) {
        if (!ip.isIP(ipString)) {
          throw new Error("invalid ip address");
        }
        return ip.toBytes(ipString);
      }
      function bytes2ip(ipBuff) {
        const ipString = ip.toString(ipBuff);
        if (!ipString || !ip.isIP(ipString)) {
          throw new Error("invalid ip address");
        }
        return ipString;
      }
      function port2bytes(port) {
        const buf = new ArrayBuffer(2);
        const view = new DataView(buf);
        view.setUint16(0, port);
        return new Uint8Array(buf);
      }
      function bytes2port(buf) {
        const view = new DataView(buf.buffer);
        return view.getUint16(buf.byteOffset);
      }
      function str2bytes(str) {
        const buf = uint8ArrayFromString(str);
        const size = Uint8Array.from(varint4.encode(buf.length));
        return uint8ArrayConcat([size, buf], size.length + buf.length);
      }
      function bytes2str(buf) {
        const size = varint4.decode(buf);
        buf = buf.slice(varint4.decode.bytes);
        if (buf.length !== size) {
          throw new Error("inconsistent lengths");
        }
        return uint8ArrayToString(buf);
      }
      function mh2bytes(hash) {
        let mh;
        if (hash[0] === "Q" || hash[0] === "1") {
          mh = Digest4.decode(base58btc2.decode(`z${hash}`)).bytes;
        } else {
          mh = CID2.parse(hash).multihash.bytes;
        }
        const size = Uint8Array.from(varint4.encode(mh.length));
        return uint8ArrayConcat([size, mh], size.length + mh.length);
      }
      function bytes2mh(buf) {
        const size = varint4.decode(buf);
        const address = buf.slice(varint4.decode.bytes);
        if (address.length !== size) {
          throw new Error("inconsistent lengths");
        }
        return uint8ArrayToString(address, "base58btc");
      }
      function onion2bytes(str) {
        const addr = str.split(":");
        if (addr.length !== 2) {
          throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
        }
        if (addr[0].length !== 16) {
          throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
        }
        const buf = base322.decode("b" + addr[0]);
        const port = parseInt(addr[1], 10);
        if (port < 1 || port > 65536) {
          throw new Error("Port number is not in range(1, 65536)");
        }
        const portBuf = port2bytes(port);
        return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);
      }
      function onion32bytes(str) {
        const addr = str.split(":");
        if (addr.length !== 2) {
          throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
        }
        if (addr[0].length !== 56) {
          throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
        }
        const buf = base322.decode("b" + addr[0]);
        const port = parseInt(addr[1], 10);
        if (port < 1 || port > 65536) {
          throw new Error("Port number is not in range(1, 65536)");
        }
        const portBuf = port2bytes(port);
        return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);
      }
      function bytes2onion(buf) {
        const addrBytes = buf.slice(0, buf.length - 2);
        const portBytes = buf.slice(buf.length - 2);
        const addr = uint8ArrayToString(addrBytes, "base32");
        const port = bytes2port(portBytes);
        return addr + ":" + port;
      }
    }
  });

  // node_modules/multiaddr/src/codec.js
  var require_codec = __commonJS({
    "node_modules/multiaddr/src/codec.js"(exports2, module2) {
      "use strict";
      var convert = require_convert();
      var protocols = require_protocols_table();
      var varint4 = require_varint();
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      module2.exports = {
        stringToStringTuples,
        stringTuplesToString,
        tuplesToStringTuples,
        stringTuplesToTuples,
        bytesToTuples,
        tuplesToBytes,
        bytesToString,
        stringToBytes,
        fromString: fromString3,
        fromBytes,
        validateBytes,
        isValidBytes,
        cleanPath,
        ParseError,
        protoFromTuple,
        sizeForAddr
      };
      function stringToStringTuples(str) {
        const tuples = [];
        const parts = str.split("/").slice(1);
        if (parts.length === 1 && parts[0] === "") {
          return [];
        }
        for (let p = 0; p < parts.length; p++) {
          const part = parts[p];
          const proto = protocols(part);
          if (proto.size === 0) {
            tuples.push([part]);
            continue;
          }
          p++;
          if (p >= parts.length) {
            throw ParseError("invalid address: " + str);
          }
          if (proto.path) {
            tuples.push([
              part,
              cleanPath(parts.slice(p).join("/"))
            ]);
            break;
          }
          tuples.push([part, parts[p]]);
        }
        return tuples;
      }
      function stringTuplesToString(tuples) {
        const parts = [];
        tuples.map((tup) => {
          const proto = protoFromTuple(tup);
          parts.push(proto.name);
          if (tup.length > 1) {
            parts.push(tup[1]);
          }
          return null;
        });
        return cleanPath(parts.join("/"));
      }
      function stringTuplesToTuples(tuples) {
        return tuples.map((tup) => {
          if (!Array.isArray(tup)) {
            tup = [tup];
          }
          const proto = protoFromTuple(tup);
          if (tup.length > 1) {
            return [proto.code, convert.toBytes(proto.code, tup[1])];
          }
          return [proto.code];
        });
      }
      function tuplesToStringTuples(tuples) {
        return tuples.map((tup) => {
          const proto = protoFromTuple(tup);
          if (tup[1]) {
            return [proto.code, convert.toString(proto.code, tup[1])];
          }
          return [proto.code];
        });
      }
      function tuplesToBytes(tuples) {
        return fromBytes(uint8ArrayConcat(tuples.map((tup) => {
          const proto = protoFromTuple(tup);
          let buf = Uint8Array.from(varint4.encode(proto.code));
          if (tup.length > 1) {
            buf = uint8ArrayConcat([buf, tup[1]]);
          }
          return buf;
        })));
      }
      function sizeForAddr(p, addr) {
        if (p.size > 0) {
          return p.size / 8;
        } else if (p.size === 0) {
          return 0;
        } else {
          const size = varint4.decode(addr);
          return size + varint4.decode.bytes;
        }
      }
      function bytesToTuples(buf) {
        const tuples = [];
        let i = 0;
        while (i < buf.length) {
          const code = varint4.decode(buf, i);
          const n = varint4.decode.bytes;
          const p = protocols(code);
          const size = sizeForAddr(p, buf.slice(i + n));
          if (size === 0) {
            tuples.push([code]);
            i += n;
            continue;
          }
          const addr = buf.slice(i + n, i + n + size);
          i += size + n;
          if (i > buf.length) {
            throw ParseError("Invalid address Uint8Array: " + uint8ArrayToString(buf, "base16"));
          }
          tuples.push([code, addr]);
        }
        return tuples;
      }
      function bytesToString(buf) {
        const a = bytesToTuples(buf);
        const b = tuplesToStringTuples(a);
        return stringTuplesToString(b);
      }
      function stringToBytes(str) {
        str = cleanPath(str);
        const a = stringToStringTuples(str);
        const b = stringTuplesToTuples(a);
        return tuplesToBytes(b);
      }
      function fromString3(str) {
        return stringToBytes(str);
      }
      function fromBytes(buf) {
        const err = validateBytes(buf);
        if (err)
          throw err;
        return Uint8Array.from(buf);
      }
      function validateBytes(buf) {
        try {
          bytesToTuples(buf);
        } catch (err) {
          return err;
        }
      }
      function isValidBytes(buf) {
        return validateBytes(buf) === void 0;
      }
      function cleanPath(str) {
        return "/" + str.trim().split("/").filter((a) => a).join("/");
      }
      function ParseError(str) {
        return new Error("Error parsing address: " + str);
      }
      function protoFromTuple(tup) {
        const proto = protocols(tup[0]);
        return proto;
      }
    }
  });

  // node_modules/err-code/index.js
  var require_err_code = __commonJS({
    "node_modules/err-code/index.js"(exports2, module2) {
      "use strict";
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = "";
        }
        if (code) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function() {
          };
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          const output = assign(new ErrClass(), props);
          return output;
        }
      }
      module2.exports = createError;
    }
  });

  // node_modules/uint8arrays/esm/src/equals.js
  var equals_exports = {};
  __export(equals_exports, {
    equals: () => equals3
  });
  function equals3(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var init_equals = __esm({
    "node_modules/uint8arrays/esm/src/equals.js"() {
    }
  });

  // node_modules/multiaddr/src/index.js
  var require_src = __commonJS({
    "node_modules/multiaddr/src/index.js"(exports2, module2) {
      "use strict";
      var codec = require_codec();
      var protocols = require_protocols_table();
      var varint4 = require_varint();
      var { CID: CID2 } = (init_cid(), cid_exports);
      var { base58btc: base58btc2 } = (init_base58(), base58_exports);
      var errCode = require_err_code();
      var inspect = Symbol.for("nodejs.util.inspect.custom");
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var resolvers = /* @__PURE__ */ new Map();
      var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
      var Multiaddr2 = class {
        constructor(addr) {
          if (addr == null) {
            addr = "";
          }
          Object.defineProperty(this, symbol, { value: true });
          if (addr instanceof Uint8Array) {
            this.bytes = codec.fromBytes(addr);
          } else if (typeof addr === "string") {
            if (addr.length > 0 && addr.charAt(0) !== "/") {
              throw new Error(`multiaddr "${addr}" must start with a "/"`);
            }
            this.bytes = codec.fromString(addr);
          } else if (Multiaddr2.isMultiaddr(addr)) {
            this.bytes = codec.fromBytes(addr.bytes);
          } else {
            throw new Error("addr must be a string, Buffer, or another Multiaddr");
          }
        }
        toString() {
          return codec.bytesToString(this.bytes);
        }
        toJSON() {
          return this.toString();
        }
        toOptions() {
          const opts = {};
          const parsed = this.toString().split("/");
          opts.family = parsed[1] === "ip4" ? 4 : 6;
          opts.host = parsed[2];
          opts.transport = parsed[3];
          opts.port = parseInt(parsed[4]);
          return opts;
        }
        protos() {
          return this.protoCodes().map((code) => Object.assign({}, protocols(code)));
        }
        protoCodes() {
          const codes = [];
          const buf = this.bytes;
          let i = 0;
          while (i < buf.length) {
            const code = varint4.decode(buf, i);
            const n = varint4.decode.bytes;
            const p = protocols(code);
            const size = codec.sizeForAddr(p, buf.slice(i + n));
            i += size + n;
            codes.push(code);
          }
          return codes;
        }
        protoNames() {
          return this.protos().map((proto) => proto.name);
        }
        tuples() {
          return codec.bytesToTuples(this.bytes);
        }
        stringTuples() {
          const t = codec.bytesToTuples(this.bytes);
          return codec.tuplesToStringTuples(t);
        }
        encapsulate(addr) {
          addr = new Multiaddr2(addr);
          return new Multiaddr2(this.toString() + addr.toString());
        }
        decapsulate(addr) {
          const addrString = addr.toString();
          const s = this.toString();
          const i = s.lastIndexOf(addrString);
          if (i < 0) {
            throw new Error("Address " + this + " does not contain subaddress: " + addr);
          }
          return new Multiaddr2(s.slice(0, i));
        }
        decapsulateCode(code) {
          const tuples = this.tuples();
          for (let i = tuples.length - 1; i >= 0; i--) {
            if (tuples[i][0] === code) {
              return new Multiaddr2(codec.tuplesToBytes(tuples.slice(0, i)));
            }
          }
          return this;
        }
        getPeerId() {
          try {
            const tuples = this.stringTuples().filter((tuple2) => {
              if (tuple2[0] === protocols.names.ipfs.code) {
                return true;
              }
              return false;
            });
            const tuple = tuples.pop();
            if (tuple && tuple[1]) {
              const peerIdStr = tuple[1];
              if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
                return uint8ArrayToString(base58btc2.decode(`z${peerIdStr}`), "base58btc");
              }
              return uint8ArrayToString(CID2.parse(peerIdStr).multihash.bytes, "base58btc");
            }
            return null;
          } catch (e) {
            return null;
          }
        }
        getPath() {
          let path = null;
          try {
            path = this.stringTuples().filter((tuple) => {
              const proto = protocols(tuple[0]);
              if (proto.path) {
                return true;
              }
              return false;
            })[0][1];
            if (!path) {
              path = null;
            }
          } catch (e) {
            path = null;
          }
          return path;
        }
        equals(addr) {
          return uint8ArrayEquals(this.bytes, addr.bytes);
        }
        async resolve() {
          const resolvableProto = this.protos().find((p) => p.resolvable);
          if (!resolvableProto) {
            return [this];
          }
          const resolver = resolvers.get(resolvableProto.name);
          if (!resolver) {
            throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
          }
          const addresses = await resolver(this);
          return addresses.map((a) => new Multiaddr2(a));
        }
        nodeAddress() {
          const codes = this.protoCodes();
          const names = this.protoNames();
          const parts = this.toString().split("/").slice(1);
          if (parts.length < 4) {
            throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
          } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
            throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
          } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
            throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
          }
          return {
            family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
            address: parts[1],
            port: parseInt(parts[3])
          };
        }
        isThinWaistAddress(addr) {
          const protos = (addr || this).protos();
          if (protos.length !== 2) {
            return false;
          }
          if (protos[0].code !== 4 && protos[0].code !== 41) {
            return false;
          }
          if (protos[1].code !== 6 && protos[1].code !== 273) {
            return false;
          }
          return true;
        }
        static fromNodeAddress(addr, transport) {
          if (!addr) {
            throw new Error("requires node address object");
          }
          if (!transport) {
            throw new Error("requires transport protocol");
          }
          let ip;
          switch (addr.family) {
            case 4:
              ip = "ip4";
              break;
            case 6:
              ip = "ip6";
              break;
            default:
              throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`);
          }
          return new Multiaddr2("/" + [ip, addr.address, transport, addr.port].join("/"));
        }
        static isName(addr) {
          if (!Multiaddr2.isMultiaddr(addr)) {
            return false;
          }
          return addr.protos().some((proto) => proto.resolvable);
        }
        static isMultiaddr(value) {
          return value instanceof Multiaddr2 || Boolean(value && value[symbol]);
        }
        [inspect]() {
          return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
        }
        inspect() {
          return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
        }
      };
      Multiaddr2.protocols = protocols;
      Multiaddr2.resolvers = resolvers;
      function multiaddr(addr) {
        return new Multiaddr2(addr);
      }
      module2.exports = { Multiaddr: Multiaddr2, multiaddr, protocols, resolvers };
    }
  });

  // node_modules/multiaddr-to-uri/index.js
  var require_multiaddr_to_uri = __commonJS({
    "node_modules/multiaddr-to-uri/index.js"(exports2, module2) {
      var { Multiaddr: Multiaddr2 } = require_src();
      var reduceValue = (_, v) => v;
      var tcpUri = (str, port, parts, opts) => {
        if (opts && opts.assumeHttp === false)
          return `tcp://${str}:${port}`;
        let protocol = "tcp";
        let explicitPort = `:${port}`;
        const last = parts[parts.length - 1];
        if (last.protocol === "tcp") {
          protocol = port === "443" ? "https" : "http";
          explicitPort = port === "443" || port === "80" ? "" : explicitPort;
        }
        return `${protocol}://${str}${explicitPort}`;
      };
      var Reducers = {
        ip4: reduceValue,
        ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
        tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
        udp: (str, content) => `udp://${str}:${content}`,
        dnsaddr: reduceValue,
        dns4: reduceValue,
        dns6: reduceValue,
        ipfs: (str, content) => `${str}/ipfs/${content}`,
        p2p: (str, content) => `${str}/p2p/${content}`,
        http: (str) => `http://${str}`,
        https: (str) => `https://${str}`,
        ws: (str) => `ws://${str}`,
        wss: (str) => `wss://${str}`,
        "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
        "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
        "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
      };
      module2.exports = (multiaddr, opts) => {
        const ma = new Multiaddr2(multiaddr);
        const parts = multiaddr.toString().split("/").slice(1);
        return ma.tuples().map((tuple) => ({
          protocol: parts.shift(),
          content: tuple[1] ? parts.shift() : null
        })).reduce((str, part, i, parts2) => {
          const reduce = Reducers[part.protocol];
          if (!reduce)
            throw new Error(`Unsupported protocol ${part.protocol}`);
          return reduce(str, part.content, i, parts2, opts);
        }, "");
      };
    }
  });

  // node_modules/get-iterator/index.js
  var require_get_iterator = __commonJS({
    "node_modules/get-iterator/index.js"(exports2, module2) {
      module2.exports = function getIterator(obj) {
        if (obj) {
          if (typeof obj[Symbol.iterator] === "function") {
            return obj[Symbol.iterator]();
          }
          if (typeof obj[Symbol.asyncIterator] === "function") {
            return obj[Symbol.asyncIterator]();
          }
          if (typeof obj.next === "function") {
            return obj;
          }
        }
        throw new Error("argument is not an iterator or iterable");
      };
    }
  });

  // node_modules/abortable-iterator/AbortError.js
  var require_AbortError = __commonJS({
    "node_modules/abortable-iterator/AbortError.js"(exports2, module2) {
      module2.exports = class AbortError extends Error {
        constructor(message, code) {
          super(message || "The operation was aborted");
          this.type = "aborted";
          this.code = code || "ABORT_ERR";
        }
      };
    }
  });

  // node_modules/abortable-iterator/index.js
  var require_abortable_iterator = __commonJS({
    "node_modules/abortable-iterator/index.js"(exports2, module2) {
      var getIterator = require_get_iterator();
      var AbortError = require_AbortError();
      var toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }]);
      var toMultiAbortableSource = (source, signals) => {
        source = getIterator(source);
        signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }));
        async function* abortable() {
          let nextAbortHandler;
          const abortHandler = () => {
            if (nextAbortHandler)
              nextAbortHandler();
          };
          for (const { signal } of signals) {
            signal.addEventListener("abort", abortHandler);
          }
          while (true) {
            let result;
            try {
              for (const { signal, options } of signals) {
                if (signal.aborted) {
                  const { abortMessage, abortCode } = options;
                  throw new AbortError(abortMessage, abortCode);
                }
              }
              const abort = new Promise((resolve, reject) => {
                nextAbortHandler = () => {
                  const { options } = signals.find(({ signal }) => signal.aborted);
                  const { abortMessage, abortCode } = options;
                  reject(new AbortError(abortMessage, abortCode));
                };
              });
              result = await Promise.race([abort, source.next()]);
              nextAbortHandler = null;
            } catch (err) {
              for (const { signal } of signals) {
                signal.removeEventListener("abort", abortHandler);
              }
              const aborter = signals.find(({ signal }) => signal.aborted);
              const isKnownAborter = err.type === "aborted" && aborter;
              if (isKnownAborter && aborter.options.onAbort) {
                await aborter.options.onAbort(source);
              }
              if (typeof source.return === "function") {
                await source.return();
              }
              if (isKnownAborter && aborter.options.returnOnAbort) {
                return;
              }
              throw err;
            }
            if (result.done)
              break;
            yield result.value;
          }
          for (const { signal } of signals) {
            signal.removeEventListener("abort", abortHandler);
          }
        }
        return abortable();
      };
      var toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }]);
      var toMultiAbortableSink = (sink, signals) => (source) => sink(toMultiAbortableSource(source, signals));
      var toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }]);
      var toMultiAbortableDuplex = (duplex, signals) => ({
        sink: toMultiAbortableSink(duplex.sink, signals),
        source: toMultiAbortableSource(duplex.source, signals)
      });
      module2.exports = toAbortableSource;
      module2.exports.AbortError = AbortError;
      module2.exports.source = toAbortableSource;
      module2.exports.sink = toAbortableSink;
      module2.exports.transform = toAbortableSink;
      module2.exports.duplex = toAbortableDuplex;
    }
  });

  // node_modules/p-defer/index.js
  var require_p_defer = __commonJS({
    "node_modules/p-defer/index.js"(exports2, module2) {
      "use strict";
      var pDefer = () => {
        const deferred = {};
        deferred.promise = new Promise((resolve, reject) => {
          deferred.resolve = resolve;
          deferred.reject = reject;
        });
        return deferred;
      };
      module2.exports = pDefer;
    }
  });

  // node_modules/ms/index.js
  var require_ms = __commonJS({
    "node_modules/ms/index.js"(exports2, module2) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/debug/src/common.js
  var require_common = __commonJS({
    "node_modules/debug/src/common.js"(exports2, module2) {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce2;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = require_ms();
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self2 = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self2.diff = ms;
            self2.prev = prevTime;
            self2.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self2, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self2, args);
            const logFn = self2.log || createDebug.log;
            logFn.apply(self2, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            }
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
        }
        function coerce2(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module2.exports = setup;
    }
  });

  // node_modules/debug/src/browser.js
  var require_browser2 = __commonJS({
    "node_modules/debug/src/browser.js"(exports2, module2) {
      exports2.formatArgs = formatArgs;
      exports2.save = save;
      exports2.load = load;
      exports2.useColors = useColors;
      exports2.storage = localstorage();
      exports2.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }
        };
      })();
      exports2.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33"
      ];
      function useColors() {
        if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
          return true;
        }
        if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
          return false;
        }
        return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
      }
      function formatArgs(args) {
        args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports2.log = console.debug || console.log || (() => {
      });
      function save(namespaces) {
        try {
          if (namespaces) {
            exports2.storage.setItem("debug", namespaces);
          } else {
            exports2.storage.removeItem("debug");
          }
        } catch (error) {
        }
      }
      function load() {
        let r;
        try {
          r = exports2.storage.getItem("debug");
        } catch (error) {
        }
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {
        }
      }
      module2.exports = require_common()(exports2);
      var { formatters } = module2.exports;
      formatters.j = function(v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    }
  });

  // node_modules/is-electron/index.js
  var require_is_electron = __commonJS({
    "node_modules/is-electron/index.js"(exports2, module2) {
      function isElectron() {
        if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
          return true;
        }
        if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
          return true;
        }
        if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
          return true;
        }
        return false;
      }
      module2.exports = isElectron;
    }
  });

  // node_modules/ipfs-utils/src/env.js
  var require_env = __commonJS({
    "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
      "use strict";
      var isElectron = require_is_electron();
      var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
      var IS_ELECTRON = isElectron();
      var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
      var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
      var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
      var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
      var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
      var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
      var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
      module2.exports = {
        isTest: IS_TEST,
        isElectron: IS_ELECTRON,
        isElectronMain: IS_ELECTRON_MAIN,
        isElectronRenderer: IS_ELECTRON_RENDERER,
        isNode: IS_NODE,
        isBrowser: IS_BROWSER,
        isWebWorker: IS_WEBWORKER,
        isEnvWithDom: IS_ENV_WITH_DOM,
        isReactNative: IS_REACT_NATIVE
      };
    }
  });

  // node_modules/libp2p-websockets/src/listener.browser.js
  var require_listener_browser = __commonJS({
    "node_modules/libp2p-websockets/src/listener.browser.js"(exports2, module2) {
      "use strict";
      module2.exports = function() {
        throw new Error("WebSocket Servers can not be created in the browser!");
      };
    }
  });

  // node_modules/libp2p-websockets/src/constants.js
  var require_constants = __commonJS({
    "node_modules/libp2p-websockets/src/constants.js"(exports2) {
      "use strict";
      exports2.CODE_P2P = 421;
      exports2.CODE_CIRCUIT = 290;
      exports2.CODE_TCP = 6;
      exports2.CODE_WS = 477;
      exports2.CODE_WSS = 478;
      exports2.CLOSE_TIMEOUT = 2e3;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/common.js
  var require_common2 = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/common.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isCorrect = exports2.isInSubnet = void 0;
      function isInSubnet(address) {
        if (this.subnetMask < address.subnetMask) {
          return false;
        }
        if (this.mask(address.subnetMask) === address.mask()) {
          return true;
        }
        return false;
      }
      exports2.isInSubnet = isInSubnet;
      function isCorrect(defaultBits) {
        return function() {
          if (this.addressMinusSuffix !== this.correctForm()) {
            return false;
          }
          if (this.subnetMask === defaultBits && !this.parsedSubnet) {
            return true;
          }
          return this.parsedSubnet === String(this.subnetMask);
        };
      }
      exports2.isCorrect = isCorrect;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/v4/constants.js
  var require_constants2 = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/v4/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
      exports2.BITS = 32;
      exports2.GROUPS = 4;
      exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
      exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/address-error.js
  var require_address_error = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/address-error.js"(exports2) {
      "use strict";
      var __extends = exports2 && exports2.__extends || function() {
        var extendStatics = function(d, b) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
            d2.__proto__ = b2;
          } || function(d2, b2) {
            for (var p in b2)
              if (Object.prototype.hasOwnProperty.call(b2, p))
                d2[p] = b2[p];
          };
          return extendStatics(d, b);
        };
        return function(d, b) {
          if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
          extendStatics(d, b);
          function __() {
            this.constructor = d;
          }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
      }();
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AddressError = void 0;
      var AddressError = function(_super) {
        __extends(AddressError2, _super);
        function AddressError2(message, parseMessage) {
          var _this = _super.call(this, message) || this;
          _this.name = "AddressError";
          if (parseMessage !== null) {
            _this.parseMessage = parseMessage;
          }
          return _this;
        }
        return AddressError2;
      }(Error);
      exports2.AddressError = AddressError;
    }
  });

  // node_modules/node-forge/lib/forge.js
  var require_forge = __commonJS({
    "node_modules/node-forge/lib/forge.js"(exports2, module2) {
      module2.exports = {
        options: {
          usePureJavaScript: false
        }
      };
    }
  });

  // node_modules/node-forge/lib/jsbn.js
  var require_jsbn = __commonJS({
    "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
      var forge = require_forge();
      module2.exports = forge.jsbn = forge.jsbn || {};
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        this.data = [];
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      forge.jsbn.BigInteger = BigInteger;
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this.data[i++] + w.data[j] + c;
          c = Math.floor(v / 67108864);
          w.data[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this.data[i] & 32767;
          var h = this.data[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w.data[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this.data[i] & 16383;
          var h = this.data[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w.data[j++] = l & 268435455;
        }
        return c;
      }
      if (typeof navigator === "undefined") {
        BigInteger.prototype.am = am3;
        dbits = 28;
      } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr;
      var vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r.data[i] = this.data[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this.data[0] = x;
        else if (x < -1)
          this.data[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this.data[this.t++] = x;
          else if (sh + k > this.DB) {
            this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this.data[this.t++] = x >> this.DB - sh;
          } else
            this.data[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this.data[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this.data[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this.data[i] & (1 << p) - 1) << k - p;
              d |= this.data[--i] >> (p += this.DB - k);
            } else {
              d = this.data[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this.data[i] - a.data[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t;
        if ((t = x >>> 16) != 0) {
          x = t;
          r += 16;
        }
        if ((t = x >> 8) != 0) {
          x = t;
          r += 8;
        }
        if ((t = x >> 4) != 0) {
          x = t;
          r += 4;
        }
        if ((t = x >> 2) != 0) {
          x = t;
          r += 2;
        }
        if ((t = x >> 1) != 0) {
          x = t;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r.data[i + n] = this.data[i];
        for (i = n - 1; i >= 0; --i)
          r.data[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r.data[i - n] = this.data[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r.data[i + ds + 1] = this.data[i] >> cbs | c;
          c = (this.data[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r.data[i] = 0;
        r.data[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r.data[0] = this.data[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
          r.data[i - ds] = this.data[i] >> bs;
        }
        if (bs > 0)
          r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this.data[i] - a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r.data[i++] = this.DV + c;
        else if (c > 0)
          r.data[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = 0; i < y.t; ++i)
          r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
          if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r.data[i + x.t] -= x.DV;
            r.data[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm.data[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y.data[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t = q == null ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
          r.data[r.t++] = 1;
          r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y);
        while (y.t < ys)
          y.data[y.t++] = 0;
        while (--j >= 0) {
          var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
          if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t);
            r.subTo(t, r);
            while (r.data[i] < --qd)
              r.subTo(t, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this.data[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x.data[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x.data[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x.data[j] >= x.DV) {
            x.data[j] -= x.DV;
            x.data[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z.mulTo(r2, g, r);
          else {
            var t = r;
            r = r2;
            r2 = t;
          }
        }
        return z.revert(r);
      }
      function bnModPowInt(e, m) {
        var z;
        if (e < 256 || m.isEven())
          z = new Classic(m);
        else
          z = new Montgomery(m);
        return this.exp(e, z);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this.data[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this.data[0];
        else if (this.t == 0)
          return 0;
        return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z = nbi(), r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
          r = (a + z.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t > 0)
            x[0] &= (1 << t) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this.data[i] & (1 << p) - 1) << 8 - p;
              d |= this.data[--i] >> (p += this.DB - 8);
            } else {
              d = this.data[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r.data[i] = op(this.data[i], a.data[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r.data[i] = op(this.data[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r.data[i] = op(f, a.data[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r.data[i] = this.DM & ~this.data[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this.data[i] != 0)
            return i * this.DB + lbit(this.data[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this.data[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this.data[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this.data[i] + a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r.data[i++] = c;
        else if (c < -1)
          r.data[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this.data[this.t++] = 0;
        this.data[w] += n;
        while (this.data[w] >= this.DV) {
          this.data[w] -= this.DV;
          if (++w >= this.t)
            this.data[this.t++] = 0;
          ++this.data[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r.data[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a.data[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z = new Classic(m);
        else if (m.isEven())
          z = new Barrett(m);
        else
          z = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
        i = nbits(e.data[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e.data[j] >> i - k1 & km;
          else {
            w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e.data[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z.sqrTo(r, r2);
              z.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z.sqrTo(r, r2);
            else {
              t = r;
              r = r2;
              r2 = t;
            }
            z.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e.data[j] & 1 << i) == 0) {
            z.sqrTo(r, r2);
            t = r;
            r = r2;
            r2 = t;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t = x;
          x = y;
          y = t;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this.data[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this.data[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t) {
        var i, x = this.abs();
        if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x.data[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t);
      }
      function bnpMillerRabin(t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        var prng = bnGetPrng();
        var a;
        for (var i = 0; i < t; ++i) {
          do {
            a = new BigInteger(this.bitLength(), prng);
          } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      function bnGetPrng() {
        return {
          nextBytes: function(x) {
            for (var i = 0; i < x.length; ++i) {
              x[i] = Math.floor(Math.random() * 256);
            }
          }
        };
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    }
  });

  // node_modules/sprintf-js/src/sprintf.js
  var require_sprintf = __commonJS({
    "node_modules/sprintf-js/src/sprintf.js"(exports2) {
      !function() {
        "use strict";
        var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/
        };
        function sprintf(key) {
          return sprintf_format(sprintf_parse(key), arguments);
        }
        function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []));
        }
        function sprintf_format(parse_tree, argv) {
          var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
          for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === "string") {
              output += parse_tree[i];
            } else if (typeof parse_tree[i] === "object") {
              ph = parse_tree[i];
              if (ph.keys) {
                arg = argv[cursor];
                for (k = 0; k < ph.keys.length; k++) {
                  if (arg == void 0) {
                    throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                  }
                  arg = arg[ph.keys[k]];
                }
              } else if (ph.param_no) {
                arg = argv[ph.param_no];
              } else {
                arg = argv[cursor++];
              }
              if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
                arg = arg();
              }
              if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
                throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
              }
              if (re.number.test(ph.type)) {
                is_positive = arg >= 0;
              }
              switch (ph.type) {
                case "b":
                  arg = parseInt(arg, 10).toString(2);
                  break;
                case "c":
                  arg = String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                case "i":
                  arg = parseInt(arg, 10);
                  break;
                case "j":
                  arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                  break;
                case "e":
                  arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                  break;
                case "f":
                  arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                  break;
                case "g":
                  arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                  break;
                case "o":
                  arg = (parseInt(arg, 10) >>> 0).toString(8);
                  break;
                case "s":
                  arg = String(arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "t":
                  arg = String(!!arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "T":
                  arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "u":
                  arg = parseInt(arg, 10) >>> 0;
                  break;
                case "v":
                  arg = arg.valueOf();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "x":
                  arg = (parseInt(arg, 10) >>> 0).toString(16);
                  break;
                case "X":
                  arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                  break;
              }
              if (re.json.test(ph.type)) {
                output += arg;
              } else {
                if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                  sign = is_positive ? "+" : "-";
                  arg = arg.toString().replace(re.sign, "");
                } else {
                  sign = "";
                }
                pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
                pad_length = ph.width - (sign + arg).length;
                pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
                output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
              }
            }
          }
          return output;
        }
        var sprintf_cache = Object.create(null);
        function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
          }
          var _fmt = fmt, match, parse_tree = [], arg_names = 0;
          while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
              parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
              parse_tree.push("%");
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
              if (match[2]) {
                arg_names |= 1;
                var field_list = [], replacement_field = match[2], field_match = [];
                if ((field_match = re.key.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                  while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                    if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                      field_list.push(field_match[1]);
                    } else {
                      throw new SyntaxError("[sprintf] failed to parse named argument key");
                    }
                  }
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
                match[2] = field_list;
              } else {
                arg_names |= 2;
              }
              if (arg_names === 3) {
                throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
              }
              parse_tree.push({
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8]
              });
            } else {
              throw new SyntaxError("[sprintf] unexpected placeholder");
            }
            _fmt = _fmt.substring(match[0].length);
          }
          return sprintf_cache[fmt] = parse_tree;
        }
        if (typeof exports2 !== "undefined") {
          exports2["sprintf"] = sprintf;
          exports2["vsprintf"] = vsprintf;
        }
        if (typeof window !== "undefined") {
          window["sprintf"] = sprintf;
          window["vsprintf"] = vsprintf;
          if (typeof define === "function" && define["amd"]) {
            define(function() {
              return {
                "sprintf": sprintf,
                "vsprintf": vsprintf
              };
            });
          }
        }
      }();
    }
  });

  // node_modules/ip-address/dist/cjs/lib/ipv4.js
  var require_ipv4 = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/ipv4.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Address4 = void 0;
      var common = __importStar(require_common2());
      var constants = __importStar(require_constants2());
      var address_error_1 = require_address_error();
      var jsbn_1 = require_jsbn();
      var sprintf_js_1 = require_sprintf();
      var Address4 = function() {
        function Address42(address) {
          this.groups = constants.GROUPS;
          this.parsedAddress = [];
          this.parsedSubnet = "";
          this.subnet = "/32";
          this.subnetMask = 32;
          this.v4 = true;
          this.isCorrect = common.isCorrect(constants.BITS);
          this.isInSubnet = common.isInSubnet;
          this.address = address;
          var subnet = constants.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = "/" + this.subnetMask;
            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants.RE_SUBNET_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(address);
        }
        Address42.isValid = function(address) {
          try {
            new Address42(address);
            return true;
          } catch (e) {
            return false;
          }
        };
        Address42.prototype.parse = function(address) {
          var groups = address.split(".");
          if (!address.match(constants.RE_ADDRESS)) {
            throw new address_error_1.AddressError("Invalid IPv4 address.");
          }
          return groups;
        };
        Address42.prototype.correctForm = function() {
          return this.parsedAddress.map(function(part) {
            return parseInt(part, 10);
          }).join(".");
        };
        Address42.fromHex = function(hex) {
          var padded = hex.replace(/:/g, "").padStart(8, "0");
          var groups = [];
          var i;
          for (i = 0; i < 8; i += 2) {
            var h = padded.slice(i, i + 2);
            groups.push(parseInt(h, 16));
          }
          return new Address42(groups.join("."));
        };
        Address42.fromInteger = function(integer) {
          return Address42.fromHex(integer.toString(16));
        };
        Address42.fromArpa = function(arpaFormAddress) {
          var leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
          var address = leader.split(".").reverse().join(".");
          return new Address42(address);
        };
        Address42.prototype.toHex = function() {
          return this.parsedAddress.map(function(part) {
            return sprintf_js_1.sprintf("%02x", parseInt(part, 10));
          }).join(":");
        };
        Address42.prototype.toArray = function() {
          return this.parsedAddress.map(function(part) {
            return parseInt(part, 10);
          });
        };
        Address42.prototype.toGroup6 = function() {
          var output = [];
          var i;
          for (i = 0; i < constants.GROUPS; i += 2) {
            var hex = sprintf_js_1.sprintf("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
            output.push(sprintf_js_1.sprintf("%x", parseInt(hex, 16)));
          }
          return output.join(":");
        };
        Address42.prototype.bigInteger = function() {
          return new jsbn_1.BigInteger(this.parsedAddress.map(function(n) {
            return sprintf_js_1.sprintf("%02x", parseInt(n, 10));
          }).join(""), 16);
        };
        Address42.prototype._startAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
        };
        Address42.prototype.startAddress = function() {
          return Address42.fromBigInteger(this._startAddress());
        };
        Address42.prototype.startAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address42.fromBigInteger(this._startAddress().add(adjust));
        };
        Address42.prototype._endAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
        };
        Address42.prototype.endAddress = function() {
          return Address42.fromBigInteger(this._endAddress());
        };
        Address42.prototype.endAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address42.fromBigInteger(this._endAddress().subtract(adjust));
        };
        Address42.fromBigInteger = function(bigInteger) {
          return Address42.fromInteger(parseInt(bigInteger.toString(), 10));
        };
        Address42.prototype.mask = function(mask) {
          if (mask === void 0) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        };
        Address42.prototype.getBitsBase2 = function(start, end) {
          return this.binaryZeroPad().slice(start, end);
        };
        Address42.prototype.reverseForm = function(options) {
          if (!options) {
            options = {};
          }
          var reversed = this.correctForm().split(".").reverse().join(".");
          if (options.omitSuffix) {
            return reversed;
          }
          return sprintf_js_1.sprintf("%s.in-addr.arpa.", reversed);
        };
        Address42.prototype.isMulticast = function() {
          return this.isInSubnet(new Address42("224.0.0.0/4"));
        };
        Address42.prototype.binaryZeroPad = function() {
          return this.bigInteger().toString(2).padStart(constants.BITS, "0");
        };
        Address42.prototype.groupForV6 = function() {
          var segments = this.parsedAddress;
          return this.address.replace(constants.RE_ADDRESS, sprintf_js_1.sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
        };
        return Address42;
      }();
      exports2.Address4 = Address4;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/v6/constants.js
  var require_constants3 = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/v6/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
      exports2.BITS = 128;
      exports2.GROUPS = 8;
      exports2.SCOPES = {
        0: "Reserved",
        1: "Interface local",
        2: "Link local",
        4: "Admin local",
        5: "Site local",
        8: "Organization local",
        14: "Global",
        15: "Reserved"
      };
      exports2.TYPES = {
        "ff01::1/128": "Multicast (All nodes on this interface)",
        "ff01::2/128": "Multicast (All routers on this interface)",
        "ff02::1/128": "Multicast (All nodes on this link)",
        "ff02::2/128": "Multicast (All routers on this link)",
        "ff05::2/128": "Multicast (All routers in this site)",
        "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
        "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
        "ff02::9/128": "Multicast (RIP routers)",
        "ff02::a/128": "Multicast (EIGRP routers)",
        "ff02::d/128": "Multicast (PIM routers)",
        "ff02::16/128": "Multicast (MLDv2 reports)",
        "ff01::fb/128": "Multicast (mDNSv6)",
        "ff02::fb/128": "Multicast (mDNSv6)",
        "ff05::fb/128": "Multicast (mDNSv6)",
        "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
        "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
        "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
        "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
        "::/128": "Unspecified",
        "::1/128": "Loopback",
        "ff00::/8": "Multicast",
        "fe80::/10": "Link-local unicast"
      };
      exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
      exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
      exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
      exports2.RE_ZONE_STRING = /%.*$/;
      exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
      exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
    }
  });

  // node_modules/ip-address/dist/cjs/lib/v6/helpers.js
  var require_helpers = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/v6/helpers.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
      var sprintf_js_1 = require_sprintf();
      function spanAllZeroes(s) {
        return s.replace(/(0+)/g, '<span class="zero">$1</span>');
      }
      exports2.spanAllZeroes = spanAllZeroes;
      function spanAll(s, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var letters = s.split("");
        return letters.map(function(n, i) {
          return sprintf_js_1.sprintf('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n));
        }).join("");
      }
      exports2.spanAll = spanAll;
      function spanLeadingZeroesSimple(group) {
        return group.replace(/^(0+)/, '<span class="zero">$1</span>');
      }
      function spanLeadingZeroes(address) {
        var groups = address.split(":");
        return groups.map(function(g) {
          return spanLeadingZeroesSimple(g);
        }).join(":");
      }
      exports2.spanLeadingZeroes = spanLeadingZeroes;
      function simpleGroup(addressString, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var groups = addressString.split(":");
        return groups.map(function(g, i) {
          if (/group-v4/.test(g)) {
            return g;
          }
          return sprintf_js_1.sprintf('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
        });
      }
      exports2.simpleGroup = simpleGroup;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js
  var require_regular_expressions = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
      var v6 = __importStar(require_constants3());
      var sprintf_js_1 = require_sprintf();
      function groupPossibilities(possibilities) {
        return sprintf_js_1.sprintf("(%s)", possibilities.join("|"));
      }
      exports2.groupPossibilities = groupPossibilities;
      function padGroup(group) {
        if (group.length < 4) {
          return sprintf_js_1.sprintf("0{0,%d}%s", 4 - group.length, group);
        }
        return group;
      }
      exports2.padGroup = padGroup;
      exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
      function simpleRegularExpression(groups) {
        var zeroIndexes = [];
        groups.forEach(function(group, i) {
          var groupInteger = parseInt(group, 16);
          if (groupInteger === 0) {
            zeroIndexes.push(i);
          }
        });
        var possibilities = zeroIndexes.map(function(zeroIndex) {
          return groups.map(function(group, i) {
            if (i === zeroIndex) {
              var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
              return groupPossibilities([padGroup(group), elision]);
            }
            return padGroup(group);
          }).join(":");
        });
        possibilities.push(groups.map(padGroup).join(":"));
        return groupPossibilities(possibilities);
      }
      exports2.simpleRegularExpression = simpleRegularExpression;
      function possibleElisions(elidedGroups, moreLeft, moreRight) {
        var left = moreLeft ? "" : ":";
        var right = moreRight ? "" : ":";
        var possibilities = [];
        if (!moreLeft && !moreRight) {
          possibilities.push("::");
        }
        if (moreLeft && moreRight) {
          possibilities.push("");
        }
        if (moreRight && !moreLeft || !moreRight && moreLeft) {
          possibilities.push(":");
        }
        possibilities.push(sprintf_js_1.sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
        possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
        possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
        for (var groups = 1; groups < elidedGroups - 1; groups++) {
          for (var position = 1; position < elidedGroups - groups; position++) {
            possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
          }
        }
        return groupPossibilities(possibilities);
      }
      exports2.possibleElisions = possibleElisions;
    }
  });

  // node_modules/ip-address/dist/cjs/lib/ipv6.js
  var require_ipv6 = __commonJS({
    "node_modules/ip-address/dist/cjs/lib/ipv6.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __spreadArray = exports2 && exports2.__spreadArray || function(to, from3) {
        for (var i = 0, il = from3.length, j = to.length; i < il; i++, j++)
          to[j] = from3[i];
        return to;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Address6 = void 0;
      var common = __importStar(require_common2());
      var constants4 = __importStar(require_constants2());
      var constants6 = __importStar(require_constants3());
      var helpers = __importStar(require_helpers());
      var ipv4_1 = require_ipv4();
      var regular_expressions_1 = require_regular_expressions();
      var address_error_1 = require_address_error();
      var jsbn_1 = require_jsbn();
      var sprintf_js_1 = require_sprintf();
      function assert(condition) {
        if (!condition) {
          throw new Error("Assertion failed.");
        }
      }
      function addCommas(number) {
        var r = /(\d+)(\d{3})/;
        while (r.test(number)) {
          number = number.replace(r, "$1,$2");
        }
        return number;
      }
      function spanLeadingZeroes4(n) {
        n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
        n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
        return n;
      }
      function compact(address, slice) {
        var s1 = [];
        var s2 = [];
        var i;
        for (i = 0; i < address.length; i++) {
          if (i < slice[0]) {
            s1.push(address[i]);
          } else if (i > slice[1]) {
            s2.push(address[i]);
          }
        }
        return s1.concat(["compact"]).concat(s2);
      }
      function paddedHex(octet) {
        return sprintf_js_1.sprintf("%04x", parseInt(octet, 16));
      }
      function unsignByte(b) {
        return b & 255;
      }
      var Address6 = function() {
        function Address62(address, optionalGroups) {
          this.addressMinusSuffix = "";
          this.parsedSubnet = "";
          this.subnet = "/128";
          this.subnetMask = 128;
          this.v4 = false;
          this.zone = "";
          this.isInSubnet = common.isInSubnet;
          this.isCorrect = common.isCorrect(constants6.BITS);
          if (optionalGroups === void 0) {
            this.groups = constants6.GROUPS;
          } else {
            this.groups = optionalGroups;
          }
          this.address = address;
          var subnet = constants6.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = "/" + this.subnetMask;
            if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants6.RE_SUBNET_STRING, "");
          } else if (/\//.test(address)) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          var zone = constants6.RE_ZONE_STRING.exec(address);
          if (zone) {
            this.zone = zone[0];
            address = address.replace(constants6.RE_ZONE_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(this.addressMinusSuffix);
        }
        Address62.isValid = function(address) {
          try {
            new Address62(address);
            return true;
          } catch (e) {
            return false;
          }
        };
        Address62.fromBigInteger = function(bigInteger) {
          var hex = bigInteger.toString(16).padStart(32, "0");
          var groups = [];
          var i;
          for (i = 0; i < constants6.GROUPS; i++) {
            groups.push(hex.slice(i * 4, (i + 1) * 4));
          }
          return new Address62(groups.join(":"));
        };
        Address62.fromURL = function(url) {
          var host;
          var port = null;
          var result;
          if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
            result = constants6.RE_URL_WITH_PORT.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address with port",
                address: null,
                port: null
              };
            }
            host = result[1];
            port = result[2];
          } else if (url.indexOf("/") !== -1) {
            url = url.replace(/^[a-z0-9]+:\/\//, "");
            result = constants6.RE_URL.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address from URL",
                address: null,
                port: null
              };
            }
            host = result[1];
          } else {
            host = url;
          }
          if (port) {
            port = parseInt(port, 10);
            if (port < 0 || port > 65536) {
              port = null;
            }
          } else {
            port = null;
          }
          return {
            address: new Address62(host),
            port
          };
        };
        Address62.fromAddress4 = function(address) {
          var address4 = new ipv4_1.Address4(address);
          var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
          return new Address62("::ffff:" + address4.correctForm() + "/" + mask6);
        };
        Address62.fromArpa = function(arpaFormAddress) {
          var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
          var semicolonAmount = 7;
          if (address.length !== 63) {
            throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
          }
          var parts = address.split(".").reverse();
          for (var i = semicolonAmount; i > 0; i--) {
            var insertIndex = i * 4;
            parts.splice(insertIndex, 0, ":");
          }
          address = parts.join("");
          return new Address62(address);
        };
        Address62.prototype.microsoftTranscription = function() {
          return sprintf_js_1.sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
        };
        Address62.prototype.mask = function(mask) {
          if (mask === void 0) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        };
        Address62.prototype.possibleSubnets = function(subnetSize) {
          if (subnetSize === void 0) {
            subnetSize = 128;
          }
          var availableBits = constants6.BITS - this.subnetMask;
          var subnetBits = Math.abs(subnetSize - constants6.BITS);
          var subnetPowers = availableBits - subnetBits;
          if (subnetPowers < 0) {
            return "0";
          }
          return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
        };
        Address62.prototype._startAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
        };
        Address62.prototype.startAddress = function() {
          return Address62.fromBigInteger(this._startAddress());
        };
        Address62.prototype.startAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address62.fromBigInteger(this._startAddress().add(adjust));
        };
        Address62.prototype._endAddress = function() {
          return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
        };
        Address62.prototype.endAddress = function() {
          return Address62.fromBigInteger(this._endAddress());
        };
        Address62.prototype.endAddressExclusive = function() {
          var adjust = new jsbn_1.BigInteger("1");
          return Address62.fromBigInteger(this._endAddress().subtract(adjust));
        };
        Address62.prototype.getScope = function() {
          var scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
          if (this.getType() === "Global unicast" && scope !== "Link local") {
            scope = "Global";
          }
          return scope || "Unknown";
        };
        Address62.prototype.getType = function() {
          for (var _i = 0, _a = Object.keys(constants6.TYPES); _i < _a.length; _i++) {
            var subnet = _a[_i];
            if (this.isInSubnet(new Address62(subnet))) {
              return constants6.TYPES[subnet];
            }
          }
          return "Global unicast";
        };
        Address62.prototype.getBits = function(start, end) {
          return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
        };
        Address62.prototype.getBitsBase2 = function(start, end) {
          return this.binaryZeroPad().slice(start, end);
        };
        Address62.prototype.getBitsBase16 = function(start, end) {
          var length2 = end - start;
          if (length2 % 4 !== 0) {
            throw new Error("Length of bits to retrieve must be divisible by four");
          }
          return this.getBits(start, end).toString(16).padStart(length2 / 4, "0");
        };
        Address62.prototype.getBitsPastSubnet = function() {
          return this.getBitsBase2(this.subnetMask, constants6.BITS);
        };
        Address62.prototype.reverseForm = function(options) {
          if (!options) {
            options = {};
          }
          var characters = Math.floor(this.subnetMask / 4);
          var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
          if (characters > 0) {
            if (options.omitSuffix) {
              return reversed;
            }
            return sprintf_js_1.sprintf("%s.ip6.arpa.", reversed);
          }
          if (options.omitSuffix) {
            return "";
          }
          return "ip6.arpa.";
        };
        Address62.prototype.correctForm = function() {
          var i;
          var groups = [];
          var zeroCounter = 0;
          var zeroes = [];
          for (i = 0; i < this.parsedAddress.length; i++) {
            var value = parseInt(this.parsedAddress[i], 16);
            if (value === 0) {
              zeroCounter++;
            }
            if (value !== 0 && zeroCounter > 0) {
              if (zeroCounter > 1) {
                zeroes.push([i - zeroCounter, i - 1]);
              }
              zeroCounter = 0;
            }
          }
          if (zeroCounter > 1) {
            zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
          }
          var zeroLengths = zeroes.map(function(n) {
            return n[1] - n[0] + 1;
          });
          if (zeroes.length > 0) {
            var index = zeroLengths.indexOf(Math.max.apply(Math, zeroLengths));
            groups = compact(this.parsedAddress, zeroes[index]);
          } else {
            groups = this.parsedAddress;
          }
          for (i = 0; i < groups.length; i++) {
            if (groups[i] !== "compact") {
              groups[i] = parseInt(groups[i], 16).toString(16);
            }
          }
          var correct = groups.join(":");
          correct = correct.replace(/^compact$/, "::");
          correct = correct.replace(/^compact|compact$/, ":");
          correct = correct.replace(/compact/, "");
          return correct;
        };
        Address62.prototype.binaryZeroPad = function() {
          return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
        };
        Address62.prototype.parse4in6 = function(address) {
          var groups = address.split(":");
          var lastGroup = groups.slice(-1)[0];
          var address4 = lastGroup.match(constants4.RE_ADDRESS);
          if (address4) {
            this.parsedAddress4 = address4[0];
            this.address4 = new ipv4_1.Address4(this.parsedAddress4);
            for (var i = 0; i < this.address4.groups; i++) {
              if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
                throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
              }
            }
            this.v4 = true;
            groups[groups.length - 1] = this.address4.toGroup6();
            address = groups.join(":");
          }
          return address;
        };
        Address62.prototype.parse = function(address) {
          address = this.parse4in6(address);
          var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
          if (badCharacters) {
            throw new address_error_1.AddressError(sprintf_js_1.sprintf("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
          }
          var badAddress = address.match(constants6.RE_BAD_ADDRESS);
          if (badAddress) {
            throw new address_error_1.AddressError(sprintf_js_1.sprintf("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
          }
          var groups = [];
          var halves = address.split("::");
          if (halves.length === 2) {
            var first = halves[0].split(":");
            var last = halves[1].split(":");
            if (first.length === 1 && first[0] === "") {
              first = [];
            }
            if (last.length === 1 && last[0] === "") {
              last = [];
            }
            var remaining = this.groups - (first.length + last.length);
            if (!remaining) {
              throw new address_error_1.AddressError("Error parsing groups");
            }
            this.elidedGroups = remaining;
            this.elisionBegin = first.length;
            this.elisionEnd = first.length + this.elidedGroups;
            groups = groups.concat(first);
            for (var i = 0; i < remaining; i++) {
              groups.push("0");
            }
            groups = groups.concat(last);
          } else if (halves.length === 1) {
            groups = address.split(":");
            this.elidedGroups = 0;
          } else {
            throw new address_error_1.AddressError("Too many :: groups found");
          }
          groups = groups.map(function(group) {
            return sprintf_js_1.sprintf("%x", parseInt(group, 16));
          });
          if (groups.length !== this.groups) {
            throw new address_error_1.AddressError("Incorrect number of groups found");
          }
          return groups;
        };
        Address62.prototype.canonicalForm = function() {
          return this.parsedAddress.map(paddedHex).join(":");
        };
        Address62.prototype.decimal = function() {
          return this.parsedAddress.map(function(n) {
            return sprintf_js_1.sprintf("%05d", parseInt(n, 16));
          }).join(":");
        };
        Address62.prototype.bigInteger = function() {
          return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
        };
        Address62.prototype.to4 = function() {
          var binary = this.binaryZeroPad().split("");
          return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
        };
        Address62.prototype.to4in6 = function() {
          var address4 = this.to4();
          var address6 = new Address62(this.parsedAddress.slice(0, 6).join(":"), 6);
          var correct = address6.correctForm();
          var infix = "";
          if (!/:$/.test(correct)) {
            infix = ":";
          }
          return correct + infix + address4.address;
        };
        Address62.prototype.inspectTeredo = function() {
          var prefix = this.getBitsBase16(0, 32);
          var udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
          var server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
          var client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
          var flags = this.getBits(64, 80);
          var flagsBase2 = this.getBitsBase2(64, 80);
          var coneNat = flags.testBit(15);
          var reserved = flags.testBit(14);
          var groupIndividual = flags.testBit(8);
          var universalLocal = flags.testBit(9);
          var nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
          return {
            prefix: sprintf_js_1.sprintf("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
            server4: server4.address,
            client4: client4.address,
            flags: flagsBase2,
            coneNat,
            microsoft: {
              reserved,
              universalLocal,
              groupIndividual,
              nonce
            },
            udpPort
          };
        };
        Address62.prototype.inspect6to4 = function() {
          var prefix = this.getBitsBase16(0, 16);
          var gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
          return {
            prefix: sprintf_js_1.sprintf("%s", prefix.slice(0, 4)),
            gateway: gateway.address
          };
        };
        Address62.prototype.to6to4 = function() {
          if (!this.is4()) {
            return null;
          }
          var addr6to4 = [
            "2002",
            this.getBitsBase16(96, 112),
            this.getBitsBase16(112, 128),
            "",
            "/16"
          ].join(":");
          return new Address62(addr6to4);
        };
        Address62.prototype.toByteArray = function() {
          var byteArray = this.bigInteger().toByteArray();
          if (byteArray.length === 17 && byteArray[0] === 0) {
            return byteArray.slice(1);
          }
          return byteArray;
        };
        Address62.prototype.toUnsignedByteArray = function() {
          return this.toByteArray().map(unsignByte);
        };
        Address62.fromByteArray = function(bytes) {
          return this.fromUnsignedByteArray(bytes.map(unsignByte));
        };
        Address62.fromUnsignedByteArray = function(bytes) {
          var BYTE_MAX = new jsbn_1.BigInteger("256", 10);
          var result = new jsbn_1.BigInteger("0", 10);
          var multiplier = new jsbn_1.BigInteger("1", 10);
          for (var i = bytes.length - 1; i >= 0; i--) {
            result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes[i].toString(10), 10)));
            multiplier = multiplier.multiply(BYTE_MAX);
          }
          return Address62.fromBigInteger(result);
        };
        Address62.prototype.isCanonical = function() {
          return this.addressMinusSuffix === this.canonicalForm();
        };
        Address62.prototype.isLinkLocal = function() {
          if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
            return true;
          }
          return false;
        };
        Address62.prototype.isMulticast = function() {
          return this.getType() === "Multicast";
        };
        Address62.prototype.is4 = function() {
          return this.v4;
        };
        Address62.prototype.isTeredo = function() {
          return this.isInSubnet(new Address62("2001::/32"));
        };
        Address62.prototype.is6to4 = function() {
          return this.isInSubnet(new Address62("2002::/16"));
        };
        Address62.prototype.isLoopback = function() {
          return this.getType() === "Loopback";
        };
        Address62.prototype.href = function(optionalPort) {
          if (optionalPort === void 0) {
            optionalPort = "";
          } else {
            optionalPort = sprintf_js_1.sprintf(":%s", optionalPort);
          }
          return sprintf_js_1.sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
        };
        Address62.prototype.link = function(options) {
          if (!options) {
            options = {};
          }
          if (options.className === void 0) {
            options.className = "";
          }
          if (options.prefix === void 0) {
            options.prefix = "/#address=";
          }
          if (options.v4 === void 0) {
            options.v4 = false;
          }
          var formFunction = this.correctForm;
          if (options.v4) {
            formFunction = this.to4in6;
          }
          if (options.className) {
            return sprintf_js_1.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
          }
          return sprintf_js_1.sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
        };
        Address62.prototype.group = function() {
          if (this.elidedGroups === 0) {
            return helpers.simpleGroup(this.address).join(":");
          }
          assert(typeof this.elidedGroups === "number");
          assert(typeof this.elisionBegin === "number");
          var output = [];
          var _a = this.address.split("::"), left = _a[0], right = _a[1];
          if (left.length) {
            output.push.apply(output, helpers.simpleGroup(left));
          } else {
            output.push("");
          }
          var classes = ["hover-group"];
          for (var i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
            classes.push(sprintf_js_1.sprintf("group-%d", i));
          }
          output.push(sprintf_js_1.sprintf('<span class="%s"></span>', classes.join(" ")));
          if (right.length) {
            output.push.apply(output, helpers.simpleGroup(right, this.elisionEnd));
          } else {
            output.push("");
          }
          if (this.is4()) {
            assert(this.address4 instanceof ipv4_1.Address4);
            output.pop();
            output.push(this.address4.groupForV6());
          }
          return output.join(":");
        };
        Address62.prototype.regularExpressionString = function(substringSearch) {
          if (substringSearch === void 0) {
            substringSearch = false;
          }
          var output = [];
          var address6 = new Address62(this.correctForm());
          if (address6.elidedGroups === 0) {
            output.push(regular_expressions_1.simpleRegularExpression(address6.parsedAddress));
          } else if (address6.elidedGroups === constants6.GROUPS) {
            output.push(regular_expressions_1.possibleElisions(constants6.GROUPS));
          } else {
            var halves = address6.address.split("::");
            if (halves[0].length) {
              output.push(regular_expressions_1.simpleRegularExpression(halves[0].split(":")));
            }
            assert(typeof address6.elidedGroups === "number");
            output.push(regular_expressions_1.possibleElisions(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
            if (halves[1].length) {
              output.push(regular_expressions_1.simpleRegularExpression(halves[1].split(":")));
            }
            output = [output.join(":")];
          }
          if (!substringSearch) {
            output = __spreadArray(__spreadArray([
              "(?=^|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|[^\\w\\:])("
            ], output), [
              ")(?=[^\\w\\:]|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|$)"
            ]);
          }
          return output.join("");
        };
        Address62.prototype.regularExpression = function(substringSearch) {
          if (substringSearch === void 0) {
            substringSearch = false;
          }
          return new RegExp(this.regularExpressionString(substringSearch), "i");
        };
        return Address62;
      }();
      exports2.Address6 = Address6;
    }
  });

  // node_modules/ip-address/dist/cjs/ip-address.js
  var require_ip_address = __commonJS({
    "node_modules/ip-address/dist/cjs/ip-address.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
      var ipv4_1 = require_ipv4();
      Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
        return ipv4_1.Address4;
      } });
      var ipv6_1 = require_ipv6();
      Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
        return ipv6_1.Address6;
      } });
      var address_error_1 = require_address_error();
      Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
        return address_error_1.AddressError;
      } });
      var helpers = __importStar(require_helpers());
      exports2.v6 = { helpers };
    }
  });

  // node_modules/libp2p-utils/src/ip-port-to-multiaddr.js
  var require_ip_port_to_multiaddr = __commonJS({
    "node_modules/libp2p-utils/src/ip-port-to-multiaddr.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:ip-port-to-multiaddr"), {
        error: debug("libp2p:ip-port-to-multiaddr:err")
      });
      var { Multiaddr: Multiaddr2 } = require_src();
      var errCode = require_err_code();
      var { Address4, Address6 } = require_ip_address();
      var errors = {
        ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
        ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
        ERR_INVALID_IP: "ERR_INVALID_IP"
      };
      function ipPortToMultiaddr(ip, port) {
        if (typeof ip !== "string") {
          throw errCode(new Error(`invalid ip provided: ${ip}`), errors.ERR_INVALID_IP_PARAMETER);
        }
        if (typeof port === "string") {
          port = parseInt(port);
        }
        if (isNaN(port)) {
          throw errCode(new Error(`invalid port provided: ${port}`), errors.ERR_INVALID_PORT_PARAMETER);
        }
        try {
          new Address4(ip);
          return new Multiaddr2(`/ip4/${ip}/tcp/${port}`);
        } catch {
        }
        try {
          const ip6 = new Address6(ip);
          return ip6.is4() ? new Multiaddr2(`/ip4/${ip6.to4().correctForm()}/tcp/${port}`) : new Multiaddr2(`/ip6/${ip}/tcp/${port}`);
        } catch (err) {
          const errMsg = `invalid ip:port for creating a multiaddr: ${ip}:${port}`;
          log.error(errMsg);
          throw errCode(new Error(errMsg), errors.ERR_INVALID_IP);
        }
      }
      module2.exports = ipPortToMultiaddr;
      module2.exports.Errors = errors;
    }
  });

  // node_modules/p-timeout/index.js
  var require_p_timeout = __commonJS({
    "node_modules/p-timeout/index.js"(exports2, module2) {
      "use strict";
      var TimeoutError = class extends Error {
        constructor(message) {
          super(message);
          this.name = "TimeoutError";
        }
      };
      var pTimeout = (promise, milliseconds, fallback, options) => {
        let timer;
        const cancelablePromise = new Promise((resolve, reject) => {
          if (typeof milliseconds !== "number" || milliseconds < 0) {
            throw new TypeError("Expected `milliseconds` to be a positive number");
          }
          if (milliseconds === Infinity) {
            resolve(promise);
            return;
          }
          options = {
            customTimers: { setTimeout, clearTimeout },
            ...options
          };
          timer = options.customTimers.setTimeout.call(void 0, () => {
            if (typeof fallback === "function") {
              try {
                resolve(fallback());
              } catch (error) {
                reject(error);
              }
              return;
            }
            const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
            const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
            if (typeof promise.cancel === "function") {
              promise.cancel();
            }
            reject(timeoutError);
          }, milliseconds);
          (async () => {
            try {
              resolve(await promise);
            } catch (error) {
              reject(error);
            } finally {
              options.customTimers.clearTimeout.call(void 0, timer);
            }
          })();
        });
        cancelablePromise.clear = () => {
          clearTimeout(timer);
          timer = void 0;
        };
        return cancelablePromise;
      };
      module2.exports = pTimeout;
      module2.exports.default = pTimeout;
      module2.exports.TimeoutError = TimeoutError;
    }
  });

  // node_modules/libp2p-websockets/src/socket-to-conn.js
  var require_socket_to_conn = __commonJS({
    "node_modules/libp2p-websockets/src/socket-to-conn.js"(exports2, module2) {
      "use strict";
      var abortable = require_abortable_iterator();
      var { CLOSE_TIMEOUT } = require_constants();
      var toMultiaddr = require_ip_port_to_multiaddr();
      var pTimeout = require_p_timeout();
      var debug = require_browser2();
      var log = debug("libp2p:websockets:socket");
      log.error = debug("libp2p:websockets:socket:error");
      module2.exports = (stream, options = {}) => {
        const maConn = {
          async sink(source) {
            if (options.signal) {
              source = abortable(source, options.signal);
            }
            try {
              await stream.sink(async function* () {
                for await (const chunk of source) {
                  yield chunk instanceof Uint8Array ? chunk : chunk.slice();
                }
              }());
            } catch (err) {
              if (err.type !== "aborted") {
                log.error(err);
              }
            }
          },
          source: options.signal ? abortable(stream.source, options.signal) : stream.source,
          conn: stream,
          localAddr: options.localAddr || (stream.localAddress && stream.localPort ? toMultiaddr(stream.localAddress, stream.localPort) : void 0),
          remoteAddr: options.remoteAddr || toMultiaddr(stream.remoteAddress, stream.remotePort),
          timeline: { open: Date.now() },
          async close() {
            const start = Date.now();
            try {
              await pTimeout(stream.close(), CLOSE_TIMEOUT);
            } catch (err) {
              const { host, port } = maConn.remoteAddr.toOptions();
              log("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
              stream.destroy();
            } finally {
              maConn.timeline.close = Date.now();
            }
          }
        };
        stream.socket.once && stream.socket.once("close", () => {
          if (!maConn.timeline.close) {
            maConn.timeline.close = Date.now();
          }
        });
        return maConn;
      };
    }
  });

  // node_modules/mafmt/src/index.js
  var require_src2 = __commonJS({
    "node_modules/mafmt/src/index.js"(exports2, module2) {
      "use strict";
      var { Multiaddr: Multiaddr2 } = require_src();
      var DNS4 = base3("dns4");
      var DNS6 = base3("dns6");
      var DNSADDR = base3("dnsaddr");
      var DNS = or2(base3("dns"), DNSADDR, DNS4, DNS6);
      var IP = or2(base3("ip4"), base3("ip6"));
      var TCP = or2(and(IP, base3("tcp")), and(DNS, base3("tcp")));
      var UDP = and(IP, base3("udp"));
      var UTP = and(UDP, base3("utp"));
      var QUIC = and(UDP, base3("quic"));
      var WebSockets = or2(and(TCP, base3("ws")), and(DNS, base3("ws")));
      var WebSocketsSecure = or2(and(TCP, base3("wss")), and(DNS, base3("wss")));
      var HTTP = or2(and(TCP, base3("http")), and(IP, base3("http")), and(DNS, base3("http")));
      var HTTPS = or2(and(TCP, base3("https")), and(IP, base3("https")), and(DNS, base3("https")));
      var WebRTCStar = or2(and(WebSockets, base3("p2p-webrtc-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-webrtc-star"), base3("p2p")), and(WebSockets, base3("p2p-webrtc-star")), and(WebSocketsSecure, base3("p2p-webrtc-star")));
      var WebSocketStar = or2(and(WebSockets, base3("p2p-websocket-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-websocket-star"), base3("p2p")), and(WebSockets, base3("p2p-websocket-star")), and(WebSocketsSecure, base3("p2p-websocket-star")));
      var WebRTCDirect = or2(and(HTTP, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTPS, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTP, base3("p2p-webrtc-direct")), and(HTTPS, base3("p2p-webrtc-direct")));
      var Reliable = or2(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS);
      var Stardust = or2(and(Reliable, base3("p2p-stardust"), base3("p2p")), and(Reliable, base3("p2p-stardust")));
      var _P2P = or2(and(Reliable, base3("p2p")), WebRTCStar, WebRTCDirect, base3("p2p"));
      var _Circuit = or2(and(_P2P, base3("p2p-circuit"), _P2P), and(_P2P, base3("p2p-circuit")), and(base3("p2p-circuit"), _P2P), and(Reliable, base3("p2p-circuit")), and(base3("p2p-circuit"), Reliable), base3("p2p-circuit"));
      var CircuitRecursive = () => or2(and(_Circuit, CircuitRecursive), _Circuit);
      var Circuit = CircuitRecursive();
      var P2P = or2(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
      module2.exports = {
        DNS,
        DNS4,
        DNS6,
        DNSADDR,
        IP,
        TCP,
        UDP,
        QUIC,
        UTP,
        HTTP,
        HTTPS,
        WebSockets,
        WebSocketsSecure,
        WebSocketStar,
        WebRTCStar,
        WebRTCDirect,
        Reliable,
        Stardust,
        Circuit,
        P2P,
        IPFS: P2P
      };
      function makeMatchesFunction(partialMatch) {
        function matches(a) {
          if (!Multiaddr2.isMultiaddr(a)) {
            try {
              a = new Multiaddr2(a);
            } catch (err) {
              return false;
            }
          }
          const out = partialMatch(a.protoNames());
          if (out === null) {
            return false;
          }
          if (out === true || out === false) {
            return out;
          }
          return out.length === 0;
        }
        return matches;
      }
      function and(...args) {
        function partialMatch(a) {
          if (a.length < args.length) {
            return null;
          }
          let out = a;
          args.some((arg) => {
            out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
            if (Array.isArray(out)) {
              a = out;
            }
            if (out === null) {
              return true;
            }
            return false;
          });
          return out;
        }
        return {
          toString: function() {
            return "{ " + args.join(" ") + " }";
          },
          input: args,
          matches: makeMatchesFunction(partialMatch),
          partialMatch
        };
      }
      function or2(...args) {
        function partialMatch(a) {
          let out = null;
          args.some((arg) => {
            const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
            if (res) {
              out = res;
              return true;
            }
            return false;
          });
          return out;
        }
        const result = {
          toString: function() {
            return "{ " + args.join(" ") + " }";
          },
          input: args,
          matches: makeMatchesFunction(partialMatch),
          partialMatch
        };
        return result;
      }
      function base3(n) {
        const name = n;
        function matches(a) {
          let ma;
          if (typeof a === "string" || a instanceof Uint8Array) {
            try {
              ma = new Multiaddr2(a);
            } catch (err) {
              return false;
            }
          } else {
            ma = a;
          }
          const pnames = ma.protoNames();
          if (pnames.length === 1 && pnames[0] === name) {
            return true;
          }
          return false;
        }
        function partialMatch(protos) {
          if (protos.length === 0) {
            return null;
          }
          if (protos[0] === name) {
            return protos.slice(1);
          }
          return null;
        }
        return {
          toString: function() {
            return name;
          },
          matches,
          partialMatch
        };
      }
    }
  });

  // node_modules/libp2p-websockets/src/filters.js
  var require_filters = __commonJS({
    "node_modules/libp2p-websockets/src/filters.js"(exports2, module2) {
      "use strict";
      var mafmt = require_src2();
      var {
        CODE_CIRCUIT,
        CODE_P2P,
        CODE_TCP,
        CODE_WS,
        CODE_WSS
      } = require_constants();
      module2.exports = {
        all: (multiaddrs) => multiaddrs.filter((ma) => {
          if (ma.protoCodes().includes(CODE_CIRCUIT)) {
            return false;
          }
          const testMa = ma.decapsulateCode(CODE_P2P);
          return mafmt.WebSockets.matches(testMa) || mafmt.WebSocketsSecure.matches(testMa);
        }),
        dnsWss: (multiaddrs) => multiaddrs.filter((ma) => {
          if (ma.protoCodes().includes(CODE_CIRCUIT)) {
            return false;
          }
          const testMa = ma.decapsulateCode(CODE_P2P);
          return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
        }),
        dnsWsOrWss: (multiaddrs) => multiaddrs.filter((ma) => {
          if (ma.protoCodes().includes(CODE_CIRCUIT)) {
            return false;
          }
          const testMa = ma.decapsulateCode(CODE_P2P);
          if (mafmt.WebSockets.matches(testMa)) {
            return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));
          }
          return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
        })
      };
    }
  });

  // node_modules/libp2p-websockets/src/index.js
  var require_src3 = __commonJS({
    "node_modules/libp2p-websockets/src/index.js"(exports2, module2) {
      "use strict";
      var connect = require_client();
      var withIs = require_class_is();
      var toUri = require_multiaddr_to_uri();
      var { AbortError } = require_abortable_iterator();
      var pDefer = require_p_defer();
      var debug = require_browser2();
      var log = debug("libp2p:websockets");
      log.error = debug("libp2p:websockets:error");
      var env = require_env();
      var createListener = require_listener_browser();
      var toConnection = require_socket_to_conn();
      var filters2 = require_filters();
      var WebSockets = class {
        constructor({ upgrader, filter }) {
          if (!upgrader) {
            throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
          }
          this._upgrader = upgrader;
          this._filter = filter;
        }
        async dial(ma, options = {}) {
          log("dialing %s", ma);
          const socket = await this._connect(ma, options);
          const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal });
          log("new outbound connection %s", maConn.remoteAddr);
          const conn = await this._upgrader.upgradeOutbound(maConn);
          log("outbound connection %s upgraded", maConn.remoteAddr);
          return conn;
        }
        async _connect(ma, options = {}) {
          if (options.signal && options.signal.aborted) {
            throw new AbortError();
          }
          const cOpts = ma.toOptions();
          log("dialing %s:%s", cOpts.host, cOpts.port);
          const errorPromise = pDefer();
          const errfn = (err) => {
            const msg = `connection error: ${err.message}`;
            log.error(msg);
            errorPromise.reject(err);
          };
          const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options));
          if (rawSocket.socket.on) {
            rawSocket.socket.on("error", errfn);
          } else {
            rawSocket.socket.onerror = errfn;
          }
          if (!options.signal) {
            await Promise.race([rawSocket.connected(), errorPromise.promise]);
            log("connected %s", ma);
            return rawSocket;
          }
          let onAbort;
          const abort = new Promise((resolve, reject) => {
            onAbort = () => {
              reject(new AbortError());
              setTimeout(() => {
                rawSocket.close();
              });
            };
            if (options.signal.aborted)
              return onAbort();
            options.signal.addEventListener("abort", onAbort);
          });
          try {
            await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
          } finally {
            options.signal.removeEventListener("abort", onAbort);
          }
          log("connected %s", ma);
          return rawSocket;
        }
        createListener(options = {}, handler) {
          if (typeof options === "function") {
            handler = options;
            options = {};
          }
          return createListener({ handler, upgrader: this._upgrader }, options);
        }
        filter(multiaddrs) {
          multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
          if (this._filter) {
            return this._filter(multiaddrs);
          }
          if (env.isBrowser || env.isWebWorker) {
            return filters2.dnsWss(multiaddrs);
          }
          return filters2.all(multiaddrs);
        }
      };
      module2.exports = withIs(WebSockets, {
        className: "WebSockets",
        symbolName: "@libp2p/js-libp2p-websockets/websockets"
      });
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/browser.js
  var require_browser3 = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var QUOTA = 65536;
      var BrowserRandomSource = function() {
        function BrowserRandomSource2() {
          this.isAvailable = false;
          this.isInstantiated = false;
          var browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
          if (browserCrypto && browserCrypto.getRandomValues) {
            this._crypto = browserCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
        BrowserRandomSource2.prototype.randomBytes = function(length2) {
          if (!this.isAvailable || !this._crypto) {
            throw new Error("Browser random byte generator is not available.");
          }
          var out = new Uint8Array(length2);
          for (var i = 0; i < out.length; i += QUOTA) {
            this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
          }
          return out;
        };
        return BrowserRandomSource2;
      }();
      exports2.BrowserRandomSource = BrowserRandomSource;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/wipe/lib/wipe.js
  var require_wipe = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function wipe(array) {
        for (var i = 0; i < array.length; i++) {
          array[i] = 0;
        }
        return array;
      }
      exports2.wipe = wipe;
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/node.js
  var require_node = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/node.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var wipe_1 = require_wipe();
      var NodeRandomSource = function() {
        function NodeRandomSource2() {
          this.isAvailable = false;
          this.isInstantiated = false;
          if (typeof __require !== "undefined") {
            var nodeCrypto = require_crypto();
            if (nodeCrypto && nodeCrypto.randomBytes) {
              this._crypto = nodeCrypto;
              this.isAvailable = true;
              this.isInstantiated = true;
            }
          }
        }
        NodeRandomSource2.prototype.randomBytes = function(length2) {
          if (!this.isAvailable || !this._crypto) {
            throw new Error("Node.js random byte generator is not available.");
          }
          var buffer = this._crypto.randomBytes(length2);
          if (buffer.length !== length2) {
            throw new Error("NodeRandomSource: got fewer bytes than requested");
          }
          var out = new Uint8Array(length2);
          for (var i = 0; i < out.length; i++) {
            out[i] = buffer[i];
          }
          wipe_1.wipe(buffer);
          return out;
        };
        return NodeRandomSource2;
      }();
      exports2.NodeRandomSource = NodeRandomSource;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/system.js
  var require_system = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/random/lib/source/system.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var browser_1 = require_browser3();
      var node_1 = require_node();
      var SystemRandomSource = function() {
        function SystemRandomSource2() {
          this.isAvailable = false;
          this.name = "";
          this._source = new browser_1.BrowserRandomSource();
          if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Browser";
            return;
          }
          this._source = new node_1.NodeRandomSource();
          if (this._source.isAvailable) {
            this.isAvailable = true;
            this.name = "Node";
            return;
          }
        }
        SystemRandomSource2.prototype.randomBytes = function(length2) {
          if (!this.isAvailable) {
            throw new Error("System random byte generator is not available.");
          }
          return this._source.randomBytes(length2);
        };
        return SystemRandomSource2;
      }();
      exports2.SystemRandomSource = SystemRandomSource;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/int/lib/int.js
  var require_int = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/int/lib/int.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function imulShim(a, b) {
        var ah = a >>> 16 & 65535, al = a & 65535;
        var bh = b >>> 16 & 65535, bl = b & 65535;
        return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
      }
      exports2.mul = Math.imul || imulShim;
      function add(a, b) {
        return a + b | 0;
      }
      exports2.add = add;
      function sub(a, b) {
        return a - b | 0;
      }
      exports2.sub = sub;
      function rotl(x, n) {
        return x << n | x >>> 32 - n;
      }
      exports2.rotl = rotl;
      function rotr(x, n) {
        return x << 32 - n | x >>> n;
      }
      exports2.rotr = rotr;
      function isIntegerShim(n) {
        return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
      }
      exports2.isInteger = Number.isInteger || isIntegerShim;
      exports2.MAX_SAFE_INTEGER = 9007199254740991;
      exports2.isSafeInteger = function(n) {
        return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/binary/lib/binary.js
  var require_binary = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/binary/lib/binary.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var int_1 = require_int();
      function readInt16BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
      }
      exports2.readInt16BE = readInt16BE;
      function readUint16BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
      }
      exports2.readUint16BE = readUint16BE;
      function readInt16LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
      }
      exports2.readInt16LE = readInt16LE;
      function readUint16LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 1] << 8 | array[offset]) >>> 0;
      }
      exports2.readUint16LE = readUint16LE;
      function writeUint16BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(2);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 8;
        out[offset + 1] = value >>> 0;
        return out;
      }
      exports2.writeUint16BE = writeUint16BE;
      exports2.writeInt16BE = writeUint16BE;
      function writeUint16LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(2);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        return out;
      }
      exports2.writeUint16LE = writeUint16LE;
      exports2.writeInt16LE = writeUint16LE;
      function readInt32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
      }
      exports2.readInt32BE = readInt32BE;
      function readUint32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
      }
      exports2.readUint32BE = readUint32BE;
      function readInt32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
      }
      exports2.readInt32LE = readInt32LE;
      function readUint32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
      }
      exports2.readUint32LE = readUint32LE;
      function writeUint32BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 24;
        out[offset + 1] = value >>> 16;
        out[offset + 2] = value >>> 8;
        out[offset + 3] = value >>> 0;
        return out;
      }
      exports2.writeUint32BE = writeUint32BE;
      exports2.writeInt32BE = writeUint32BE;
      function writeUint32LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        out[offset + 0] = value >>> 0;
        out[offset + 1] = value >>> 8;
        out[offset + 2] = value >>> 16;
        out[offset + 3] = value >>> 24;
        return out;
      }
      exports2.writeUint32LE = writeUint32LE;
      exports2.writeInt32LE = writeUint32LE;
      function readInt64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var hi = readInt32BE(array, offset);
        var lo = readInt32BE(array, offset + 4);
        return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
      }
      exports2.readInt64BE = readInt64BE;
      function readUint64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var hi = readUint32BE(array, offset);
        var lo = readUint32BE(array, offset + 4);
        return hi * 4294967296 + lo;
      }
      exports2.readUint64BE = readUint64BE;
      function readInt64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var lo = readInt32LE(array, offset);
        var hi = readInt32LE(array, offset + 4);
        return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
      }
      exports2.readInt64LE = readInt64LE;
      function readUint64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var lo = readUint32LE(array, offset);
        var hi = readUint32LE(array, offset + 4);
        return hi * 4294967296 + lo;
      }
      exports2.readUint64LE = readUint64LE;
      function writeUint64BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        writeUint32BE(value / 4294967296 >>> 0, out, offset);
        writeUint32BE(value >>> 0, out, offset + 4);
        return out;
      }
      exports2.writeUint64BE = writeUint64BE;
      exports2.writeInt64BE = writeUint64BE;
      function writeUint64LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        writeUint32LE(value >>> 0, out, offset);
        writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
        return out;
      }
      exports2.writeUint64LE = writeUint64LE;
      exports2.writeInt64LE = writeUint64LE;
      function readUintBE(bitLength, array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("readUintBE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
          throw new Error("readUintBE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul = 1;
        for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
          result += array[i] * mul;
          mul *= 256;
        }
        return result;
      }
      exports2.readUintBE = readUintBE;
      function readUintLE(bitLength, array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("readUintLE supports only bitLengths divisible by 8");
        }
        if (bitLength / 8 > array.length - offset) {
          throw new Error("readUintLE: array is too short for the given bitLength");
        }
        var result = 0;
        var mul = 1;
        for (var i = offset; i < offset + bitLength / 8; i++) {
          result += array[i] * mul;
          mul *= 256;
        }
        return result;
      }
      exports2.readUintLE = readUintLE;
      function writeUintBE(bitLength, value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(bitLength / 8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("writeUintBE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
          throw new Error("writeUintBE value must be an integer");
        }
        var div = 1;
        for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
          out[i] = value / div & 255;
          div *= 256;
        }
        return out;
      }
      exports2.writeUintBE = writeUintBE;
      function writeUintLE(bitLength, value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(bitLength / 8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        if (bitLength % 8 !== 0) {
          throw new Error("writeUintLE supports only bitLengths divisible by 8");
        }
        if (!int_1.isSafeInteger(value)) {
          throw new Error("writeUintLE value must be an integer");
        }
        var div = 1;
        for (var i = offset; i < offset + bitLength / 8; i++) {
          out[i] = value / div & 255;
          div *= 256;
        }
        return out;
      }
      exports2.writeUintLE = writeUintLE;
      function readFloat32BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset);
      }
      exports2.readFloat32BE = readFloat32BE;
      function readFloat32LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat32(offset, true);
      }
      exports2.readFloat32LE = readFloat32LE;
      function readFloat64BE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset);
      }
      exports2.readFloat64BE = readFloat64BE;
      function readFloat64LE(array, offset) {
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
        return view.getFloat64(offset, true);
      }
      exports2.readFloat64LE = readFloat64LE;
      function writeFloat32BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value);
        return out;
      }
      exports2.writeFloat32BE = writeFloat32BE;
      function writeFloat32LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(4);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat32(offset, value, true);
        return out;
      }
      exports2.writeFloat32LE = writeFloat32LE;
      function writeFloat64BE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value);
        return out;
      }
      exports2.writeFloat64BE = writeFloat64BE;
      function writeFloat64LE(value, out, offset) {
        if (out === void 0) {
          out = new Uint8Array(8);
        }
        if (offset === void 0) {
          offset = 0;
        }
        var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        view.setFloat64(offset, value, true);
        return out;
      }
      exports2.writeFloat64LE = writeFloat64LE;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/random/lib/random.js
  var require_random = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/random/lib/random.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var system_1 = require_system();
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      exports2.defaultRandomSource = new system_1.SystemRandomSource();
      function randomBytes(length2, prng) {
        if (prng === void 0) {
          prng = exports2.defaultRandomSource;
        }
        return prng.randomBytes(length2);
      }
      exports2.randomBytes = randomBytes;
      function randomUint32(prng) {
        if (prng === void 0) {
          prng = exports2.defaultRandomSource;
        }
        var buf = randomBytes(4, prng);
        var result = binary_1.readUint32LE(buf);
        wipe_1.wipe(buf);
        return result;
      }
      exports2.randomUint32 = randomUint32;
      var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
      function randomString(length2, charset, prng) {
        if (charset === void 0) {
          charset = ALPHANUMERIC;
        }
        if (prng === void 0) {
          prng = exports2.defaultRandomSource;
        }
        if (charset.length < 2) {
          throw new Error("randomString charset is too short");
        }
        if (charset.length > 256) {
          throw new Error("randomString charset is too long");
        }
        var out = "";
        var charsLen = charset.length;
        var maxByte = 256 - 256 % charsLen;
        while (length2 > 0) {
          var buf = randomBytes(Math.ceil(length2 * 256 / maxByte), prng);
          for (var i = 0; i < buf.length && length2 > 0; i++) {
            var randomByte = buf[i];
            if (randomByte < maxByte) {
              out += charset.charAt(randomByte % charsLen);
              length2--;
            }
          }
          wipe_1.wipe(buf);
        }
        return out;
      }
      exports2.randomString = randomString;
      function randomStringForEntropy(bits, charset, prng) {
        if (charset === void 0) {
          charset = ALPHANUMERIC;
        }
        if (prng === void 0) {
          prng = exports2.defaultRandomSource;
        }
        var length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
        return randomString(length2, charset, prng);
      }
      exports2.randomStringForEntropy = randomStringForEntropy;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/x25519/lib/x25519.js
  var require_x25519 = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var random_1 = require_random();
      var wipe_1 = require_wipe();
      exports2.PUBLIC_KEY_LENGTH = 32;
      exports2.SECRET_KEY_LENGTH = 32;
      exports2.SHARED_KEY_LENGTH = 32;
      function gf(init) {
        var r = new Float64Array(16);
        if (init) {
          for (var i = 0; i < init.length; i++) {
            r[i] = init[i];
          }
        }
        return r;
      }
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var _121665 = gf([56129, 1]);
      function car25519(o) {
        var c = 1;
        for (var i = 0; i < 16; i++) {
          var v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          var t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function pack25519(o, n) {
        var m = gf();
        var t = gf();
        for (var i = 0; i < 16; i++) {
          t[i] = n[i];
        }
        car25519(t);
        car25519(t);
        car25519(t);
        for (var j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (var i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          var b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (var i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function unpack25519(o, n) {
        for (var i = 0; i < 16; i++) {
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 32767;
      }
      function add(o, a, b) {
        for (var i = 0; i < 16; i++) {
          o[i] = a[i] + b[i];
        }
      }
      function sub(o, a, b) {
        for (var i = 0; i < 16; i++) {
          o[i] = a[i] - b[i];
        }
      }
      function mul(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      function square(o, a) {
        mul(o, a, a);
      }
      function inv25519(o, inp) {
        var c = gf();
        for (var i = 0; i < 16; i++) {
          c[i] = inp[i];
        }
        for (var i = 253; i >= 0; i--) {
          square(c, c);
          if (i !== 2 && i !== 4) {
            mul(c, c, inp);
          }
        }
        for (var i = 0; i < 16; i++) {
          o[i] = c[i];
        }
      }
      function scalarMult(n, p) {
        var z = new Uint8Array(32);
        var x = new Float64Array(80);
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (var i = 0; i < 31; i++) {
          z[i] = n[i];
        }
        z[31] = n[31] & 127 | 64;
        z[0] &= 248;
        unpack25519(x, p);
        for (var i = 0; i < 16; i++) {
          b[i] = x[i];
        }
        a[0] = d[0] = 1;
        for (var i = 254; i >= 0; --i) {
          var r = z[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          add(e, a, c);
          sub(a, a, c);
          add(c, b, d);
          sub(b, b, d);
          square(d, e);
          square(f, a);
          mul(a, c, a);
          mul(c, b, e);
          add(e, a, c);
          sub(a, a, c);
          square(b, a);
          sub(c, d, f);
          mul(a, c, _121665);
          add(a, a, d);
          mul(c, c, a);
          mul(a, d, f);
          mul(d, b, x);
          square(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (var i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        mul(x16, x16, x32);
        var q = new Uint8Array(32);
        pack25519(q, x16);
        return q;
      }
      exports2.scalarMult = scalarMult;
      function scalarMultBase(n) {
        return scalarMult(n, _9);
      }
      exports2.scalarMultBase = scalarMultBase;
      function generateKeyPairFromSeed(seed) {
        if (seed.length !== exports2.SECRET_KEY_LENGTH) {
          throw new Error("x25519: seed must be " + exports2.SECRET_KEY_LENGTH + " bytes");
        }
        var secretKey = new Uint8Array(seed);
        var publicKey = scalarMultBase(secretKey);
        return {
          publicKey,
          secretKey
        };
      }
      exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
      function generateKeyPair(prng) {
        var seed = random_1.randomBytes(32, prng);
        var result = generateKeyPairFromSeed(seed);
        wipe_1.wipe(seed);
        return result;
      }
      exports2.generateKeyPair = generateKeyPair;
      function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
        if (rejectZero === void 0) {
          rejectZero = false;
        }
        if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
          throw new Error("X25519: incorrect secret key length");
        }
        if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
          throw new Error("X25519: incorrect public key length");
        }
        var result = scalarMult(mySecretKey, theirPublicKey);
        if (rejectZero) {
          var zeros = 0;
          for (var i = 0; i < result.length; i++) {
            zeros |= result[i];
          }
          if (zeros === 0) {
            throw new Error("X25519: invalid shared key");
          }
        }
        return result;
      }
      exports2.sharedKey = sharedKey;
    }
  });

  // node_modules/libp2p-noise/node_modules/is-buffer/index.js
  var require_is_buffer = __commonJS({
    "node_modules/libp2p-noise/node_modules/is-buffer/index.js"(exports2, module2) {
      module2.exports = function isBuffer(obj) {
        return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
      };
    }
  });

  // node_modules/bl/BufferList.js
  var require_BufferList = __commonJS({
    "node_modules/bl/BufferList.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var symbol = Symbol.for("BufferList");
      function BufferList(buf) {
        if (!(this instanceof BufferList)) {
          return new BufferList(buf);
        }
        BufferList._init.call(this, buf);
      }
      BufferList._init = function _init(buf) {
        Object.defineProperty(this, symbol, { value: true });
        this._bufs = [];
        this.length = 0;
        if (buf) {
          this.append(buf);
        }
      };
      BufferList.prototype._new = function _new(buf) {
        return new BufferList(buf);
      };
      BufferList.prototype._offset = function _offset(offset) {
        if (offset === 0) {
          return [0, 0];
        }
        let tot = 0;
        for (let i = 0; i < this._bufs.length; i++) {
          const _t = tot + this._bufs[i].length;
          if (offset < _t || i === this._bufs.length - 1) {
            return [i, offset - tot];
          }
          tot = _t;
        }
      };
      BufferList.prototype._reverseOffset = function(blOffset) {
        const bufferId = blOffset[0];
        let offset = blOffset[1];
        for (let i = 0; i < bufferId; i++) {
          offset += this._bufs[i].length;
        }
        return offset;
      };
      BufferList.prototype.get = function get(index) {
        if (index > this.length || index < 0) {
          return void 0;
        }
        const offset = this._offset(index);
        return this._bufs[offset[0]][offset[1]];
      };
      BufferList.prototype.slice = function slice(start, end) {
        if (typeof start === "number" && start < 0) {
          start += this.length;
        }
        if (typeof end === "number" && end < 0) {
          end += this.length;
        }
        return this.copy(null, 0, start, end);
      };
      BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
        if (typeof srcStart !== "number" || srcStart < 0) {
          srcStart = 0;
        }
        if (typeof srcEnd !== "number" || srcEnd > this.length) {
          srcEnd = this.length;
        }
        if (srcStart >= this.length) {
          return dst || Buffer2.alloc(0);
        }
        if (srcEnd <= 0) {
          return dst || Buffer2.alloc(0);
        }
        const copy2 = !!dst;
        const off = this._offset(srcStart);
        const len = srcEnd - srcStart;
        let bytes = len;
        let bufoff = copy2 && dstStart || 0;
        let start = off[1];
        if (srcStart === 0 && srcEnd === this.length) {
          if (!copy2) {
            return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
          }
          for (let i = 0; i < this._bufs.length; i++) {
            this._bufs[i].copy(dst, bufoff);
            bufoff += this._bufs[i].length;
          }
          return dst;
        }
        if (bytes <= this._bufs[off[0]].length - start) {
          return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
        }
        if (!copy2) {
          dst = Buffer2.allocUnsafe(len);
        }
        for (let i = off[0]; i < this._bufs.length; i++) {
          const l = this._bufs[i].length - start;
          if (bytes > l) {
            this._bufs[i].copy(dst, bufoff, start);
            bufoff += l;
          } else {
            this._bufs[i].copy(dst, bufoff, start, start + bytes);
            bufoff += l;
            break;
          }
          bytes -= l;
          if (start) {
            start = 0;
          }
        }
        if (dst.length > bufoff)
          return dst.slice(0, bufoff);
        return dst;
      };
      BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
        start = start || 0;
        end = typeof end !== "number" ? this.length : end;
        if (start < 0) {
          start += this.length;
        }
        if (end < 0) {
          end += this.length;
        }
        if (start === end) {
          return this._new();
        }
        const startOffset = this._offset(start);
        const endOffset = this._offset(end);
        const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
        if (endOffset[1] === 0) {
          buffers.pop();
        } else {
          buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
        }
        if (startOffset[1] !== 0) {
          buffers[0] = buffers[0].slice(startOffset[1]);
        }
        return this._new(buffers);
      };
      BufferList.prototype.toString = function toString3(encoding, start, end) {
        return this.slice(start, end).toString(encoding);
      };
      BufferList.prototype.consume = function consume(bytes) {
        bytes = Math.trunc(bytes);
        if (Number.isNaN(bytes) || bytes <= 0)
          return this;
        while (this._bufs.length) {
          if (bytes >= this._bufs[0].length) {
            bytes -= this._bufs[0].length;
            this.length -= this._bufs[0].length;
            this._bufs.shift();
          } else {
            this._bufs[0] = this._bufs[0].slice(bytes);
            this.length -= bytes;
            break;
          }
        }
        return this;
      };
      BufferList.prototype.duplicate = function duplicate() {
        const copy = this._new();
        for (let i = 0; i < this._bufs.length; i++) {
          copy.append(this._bufs[i]);
        }
        return copy;
      };
      BufferList.prototype.append = function append(buf) {
        if (buf == null) {
          return this;
        }
        if (buf.buffer) {
          this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
        } else if (Array.isArray(buf)) {
          for (let i = 0; i < buf.length; i++) {
            this.append(buf[i]);
          }
        } else if (this._isBufferList(buf)) {
          for (let i = 0; i < buf._bufs.length; i++) {
            this.append(buf._bufs[i]);
          }
        } else {
          if (typeof buf === "number") {
            buf = buf.toString();
          }
          this._appendBuffer(Buffer2.from(buf));
        }
        return this;
      };
      BufferList.prototype._appendBuffer = function appendBuffer(buf) {
        this._bufs.push(buf);
        this.length += buf.length;
      };
      BufferList.prototype.indexOf = function(search, offset, encoding) {
        if (encoding === void 0 && typeof offset === "string") {
          encoding = offset;
          offset = void 0;
        }
        if (typeof search === "function" || Array.isArray(search)) {
          throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
        } else if (typeof search === "number") {
          search = Buffer2.from([search]);
        } else if (typeof search === "string") {
          search = Buffer2.from(search, encoding);
        } else if (this._isBufferList(search)) {
          search = search.slice();
        } else if (Array.isArray(search.buffer)) {
          search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
        } else if (!Buffer2.isBuffer(search)) {
          search = Buffer2.from(search);
        }
        offset = Number(offset || 0);
        if (isNaN(offset)) {
          offset = 0;
        }
        if (offset < 0) {
          offset = this.length + offset;
        }
        if (offset < 0) {
          offset = 0;
        }
        if (search.length === 0) {
          return offset > this.length ? this.length : offset;
        }
        const blOffset = this._offset(offset);
        let blIndex = blOffset[0];
        let buffOffset = blOffset[1];
        for (; blIndex < this._bufs.length; blIndex++) {
          const buff = this._bufs[blIndex];
          while (buffOffset < buff.length) {
            const availableWindow = buff.length - buffOffset;
            if (availableWindow >= search.length) {
              const nativeSearchResult = buff.indexOf(search, buffOffset);
              if (nativeSearchResult !== -1) {
                return this._reverseOffset([blIndex, nativeSearchResult]);
              }
              buffOffset = buff.length - search.length + 1;
            } else {
              const revOffset = this._reverseOffset([blIndex, buffOffset]);
              if (this._match(revOffset, search)) {
                return revOffset;
              }
              buffOffset++;
            }
          }
          buffOffset = 0;
        }
        return -1;
      };
      BufferList.prototype._match = function(offset, search) {
        if (this.length - offset < search.length) {
          return false;
        }
        for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
          if (this.get(offset + searchOffset) !== search[searchOffset]) {
            return false;
          }
        }
        return true;
      };
      (function() {
        const methods = {
          readDoubleBE: 8,
          readDoubleLE: 8,
          readFloatBE: 4,
          readFloatLE: 4,
          readInt32BE: 4,
          readInt32LE: 4,
          readUInt32BE: 4,
          readUInt32LE: 4,
          readInt16BE: 2,
          readInt16LE: 2,
          readUInt16BE: 2,
          readUInt16LE: 2,
          readInt8: 1,
          readUInt8: 1,
          readIntBE: null,
          readIntLE: null,
          readUIntBE: null,
          readUIntLE: null
        };
        for (const m in methods) {
          (function(m2) {
            if (methods[m2] === null) {
              BufferList.prototype[m2] = function(offset, byteLength) {
                return this.slice(offset, offset + byteLength)[m2](0, byteLength);
              };
            } else {
              BufferList.prototype[m2] = function(offset = 0) {
                return this.slice(offset, offset + methods[m2])[m2](0);
              };
            }
          })(m);
        }
      })();
      BufferList.prototype._isBufferList = function _isBufferList(b) {
        return b instanceof BufferList || BufferList.isBufferList(b);
      };
      BufferList.isBufferList = function isBufferList(b) {
        return b != null && b[symbol];
      };
      module2.exports = BufferList;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-reader/index.js
  var require_it_reader = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-reader/index.js"(exports2, module2) {
      var BufferList = require_BufferList();
      module2.exports = (source) => {
        const reader = async function* () {
          let bytes = yield;
          let bl = new BufferList();
          for await (const chunk of source) {
            if (!bytes) {
              bytes = yield bl.append(chunk);
              bl = new BufferList();
              continue;
            }
            bl.append(chunk);
            while (bl.length >= bytes) {
              const data = bl.shallowSlice(0, bytes);
              bl.consume(bytes);
              bytes = yield data;
              if (!bytes) {
                if (bl.length) {
                  bytes = yield bl;
                  bl = new BufferList();
                }
                break;
              }
            }
          }
          if (bytes) {
            throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
          }
        }();
        reader.next();
        return reader;
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/fast-fifo/fixed-size.js
  var require_fixed_size = __commonJS({
    "node_modules/libp2p-noise/node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
      module2.exports = class FixedFIFO {
        constructor(hwm) {
          if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
            throw new Error("Max size for a FixedFIFO should be a power of two");
          this.buffer = new Array(hwm);
          this.mask = hwm - 1;
          this.top = 0;
          this.btm = 0;
          this.next = null;
        }
        push(data) {
          if (this.buffer[this.top] !== void 0)
            return false;
          this.buffer[this.top] = data;
          this.top = this.top + 1 & this.mask;
          return true;
        }
        shift() {
          const last = this.buffer[this.btm];
          if (last === void 0)
            return void 0;
          this.buffer[this.btm] = void 0;
          this.btm = this.btm + 1 & this.mask;
          return last;
        }
        isEmpty() {
          return this.buffer[this.btm] === void 0;
        }
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/fast-fifo/index.js
  var require_fast_fifo = __commonJS({
    "node_modules/libp2p-noise/node_modules/fast-fifo/index.js"(exports2, module2) {
      var FixedFIFO = require_fixed_size();
      module2.exports = class FastFIFO {
        constructor(hwm) {
          this.hwm = hwm || 16;
          this.head = new FixedFIFO(this.hwm);
          this.tail = this.head;
        }
        push(val) {
          if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
          }
        }
        shift() {
          const val = this.tail.shift();
          if (val === void 0 && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
          }
          return val;
        }
        isEmpty() {
          return this.head.isEmpty();
        }
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pushable/index.js
  var require_it_pushable = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pushable/index.js"(exports2, module2) {
      var FIFO = require_fast_fifo();
      module2.exports = (options) => {
        options = options || {};
        let onEnd;
        if (typeof options === "function") {
          onEnd = options;
          options = {};
        } else {
          onEnd = options.onEnd;
        }
        let buffer = new FIFO();
        let pushable, onNext, ended;
        const waitNext = () => {
          if (!buffer.isEmpty()) {
            if (options.writev) {
              let next2;
              const values = [];
              while (!buffer.isEmpty()) {
                next2 = buffer.shift();
                if (next2.error)
                  throw next2.error;
                values.push(next2.value);
              }
              return { done: next2.done, value: values };
            }
            const next = buffer.shift();
            if (next.error)
              throw next.error;
            return next;
          }
          if (ended)
            return { done: true };
          return new Promise((resolve, reject) => {
            onNext = (next) => {
              onNext = null;
              if (next.error) {
                reject(next.error);
              } else {
                if (options.writev && !next.done) {
                  resolve({ done: next.done, value: [next.value] });
                } else {
                  resolve(next);
                }
              }
              return pushable;
            };
          });
        };
        const bufferNext = (next) => {
          if (onNext)
            return onNext(next);
          buffer.push(next);
          return pushable;
        };
        const bufferError = (err) => {
          buffer = new FIFO();
          if (onNext)
            return onNext({ error: err });
          buffer.push({ error: err });
          return pushable;
        };
        const push = (value) => {
          if (ended)
            return pushable;
          return bufferNext({ done: false, value });
        };
        const end = (err) => {
          if (ended)
            return pushable;
          ended = true;
          return err ? bufferError(err) : bufferNext({ done: true });
        };
        const _return = () => {
          buffer = new FIFO();
          end();
          return { done: true };
        };
        const _throw = (err) => {
          end(err);
          return { done: true };
        };
        pushable = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: waitNext,
          return: _return,
          throw: _throw,
          push,
          end
        };
        if (!onEnd)
          return pushable;
        const _pushable = pushable;
        pushable = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return _pushable.next();
          },
          throw(err) {
            _pushable.throw(err);
            if (onEnd) {
              onEnd(err);
              onEnd = null;
            }
            return { done: true };
          },
          return() {
            _pushable.return();
            if (onEnd) {
              onEnd();
              onEnd = null;
            }
            return { done: true };
          },
          push,
          end(err) {
            _pushable.end(err);
            if (onEnd) {
              onEnd(err);
              onEnd = null;
            }
            return pushable;
          }
        };
        return pushable;
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/p-defer/index.js
  var require_p_defer2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/p-defer/index.js"(exports2, module2) {
      "use strict";
      var pDefer = () => {
        const deferred = {};
        deferred.promise = new Promise((resolve, reject) => {
          deferred.resolve = resolve;
          deferred.reject = reject;
        });
        return deferred;
      };
      module2.exports = pDefer;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-handshake/src/index.js
  var require_src4 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-handshake/src/index.js"(exports2, module2) {
      "use strict";
      var Reader = require_it_reader();
      var Writer = require_it_pushable();
      var defer = require_p_defer2();
      module2.exports = (stream) => {
        const writer = Writer();
        const reader = Reader(stream.source);
        const sourcePromise = defer();
        let sinkErr;
        const sinkPromise = stream.sink(async function* () {
          yield* writer;
          const source = await sourcePromise.promise;
          yield* source;
        }());
        sinkPromise.catch((err) => {
          sinkErr = err;
        });
        const rest = {
          sink: (source) => {
            if (sinkErr) {
              return Promise.reject(sinkErr);
            }
            sourcePromise.resolve(source);
            return sinkPromise;
          },
          source: reader
        };
        return {
          reader,
          writer,
          stream: rest,
          rest: () => writer.end(),
          write: writer.push,
          read: async () => {
            return (await reader.next()).value;
          }
        };
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/varint/encode.js
  var require_encode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/varint/encode.js"(exports2, module2) {
      module2.exports = encode3;
      var MSB2 = 128;
      var REST2 = 127;
      var MSBALL2 = ~REST2;
      var INT2 = Math.pow(2, 31);
      function encode3(num, out, offset) {
        if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
          encode3.bytes = 0;
          throw new RangeError("Could not encode varint");
        }
        out = out || [];
        offset = offset || 0;
        var oldOffset = offset;
        while (num >= INT2) {
          out[offset++] = num & 255 | MSB2;
          num /= 128;
        }
        while (num & MSBALL2) {
          out[offset++] = num & 255 | MSB2;
          num >>>= 7;
        }
        out[offset] = num | 0;
        encode3.bytes = offset - oldOffset + 1;
        return out;
      }
    }
  });

  // node_modules/libp2p-noise/node_modules/varint/decode.js
  var require_decode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/varint/decode.js"(exports2, module2) {
      module2.exports = read2;
      var MSB2 = 128;
      var REST2 = 127;
      function read2(buf, offset) {
        var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
        do {
          if (counter >= l || shift > 49) {
            read2.bytes = 0;
            throw new RangeError("Could not decode varint");
          }
          b = buf[counter++];
          res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
          shift += 7;
        } while (b >= MSB2);
        read2.bytes = counter - offset;
        return res;
      }
    }
  });

  // node_modules/libp2p-noise/node_modules/varint/length.js
  var require_length2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/varint/length.js"(exports2, module2) {
      var N12 = Math.pow(2, 7);
      var N22 = Math.pow(2, 14);
      var N32 = Math.pow(2, 21);
      var N42 = Math.pow(2, 28);
      var N52 = Math.pow(2, 35);
      var N62 = Math.pow(2, 42);
      var N72 = Math.pow(2, 49);
      var N82 = Math.pow(2, 56);
      var N92 = Math.pow(2, 63);
      module2.exports = function(value) {
        return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/varint/index.js
  var require_varint2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/varint/index.js"(exports2, module2) {
      module2.exports = {
        encode: require_encode2(),
        decode: require_decode2(),
        encodingLength: require_length2()
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/varint-encode.js
  var require_varint_encode = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/varint-encode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint2();
      var { Buffer: Buffer2 } = require_buffer();
      var varintEncode = (value, target, offset) => {
        const ret = Varint.encode(value, target, offset);
        varintEncode.bytes = Varint.encode.bytes;
        return target || Buffer2.from(ret);
      };
      module2.exports = varintEncode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/encode.js
  var require_encode3 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintEncode = require_varint_encode();
      var MIN_POOL_SIZE = 8;
      var DEFAULT_POOL_SIZE = 10 * 1024;
      function encode3(options) {
        options = options || {};
        const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
        const encodeLength = options.lengthEncoder || varintEncode;
        const encoder = async function* (source) {
          let pool = Buffer2.alloc(poolSize);
          let poolOffset = 0;
          for await (const chunk of source) {
            encodeLength(chunk.length, pool, poolOffset);
            const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
            poolOffset += encodeLength.bytes;
            if (pool.length - poolOffset < MIN_POOL_SIZE) {
              pool = Buffer2.alloc(poolSize);
              poolOffset = 0;
            }
            yield new BufferList().append(encodedLength).append(chunk);
          }
        };
        return encoder;
      }
      encode3.single = (chunk, options) => {
        options = options || {};
        const encodeLength = options.lengthEncoder || varintEncode;
        return new BufferList([encodeLength(chunk.length), chunk.slice()]);
      };
      module2.exports = encode3;
      module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
      module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/varint-decode.js
  var require_varint_decode = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/varint-decode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint2();
      var { Buffer: Buffer2 } = require_buffer();
      var toBufferProxy = (bl) => new Proxy({}, {
        get: (_, prop) => {
          return prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop));
        }
      });
      var varintDecode = (data) => {
        const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
        varintDecode.bytes = Varint.decode.bytes;
        return len;
      };
      module2.exports = varintDecode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/decode.js
  var require_decode3 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/decode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintDecode = require_varint_decode();
      var MAX_LENGTH_LENGTH = 8;
      var MAX_DATA_LENGTH = 1024 * 1024 * 4;
      var Empty = Buffer2.alloc(0);
      var ReadModes = { LENGTH: "readLength", DATA: "readData" };
      var ReadHandlers = {
        [ReadModes.LENGTH]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          let dataLength;
          try {
            dataLength = options.lengthDecoder(buffer);
          } catch (err) {
            if (buffer.length > options.maxLengthLength) {
              throw Object.assign(err, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
            }
            if (err instanceof RangeError) {
              return { mode: ReadModes.LENGTH, buffer, chunk: void 0, state: void 0, data: void 0 };
            }
            throw err;
          }
          if (dataLength > options.maxDataLength) {
            throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" });
          }
          chunk = buffer.shallowSlice(options.lengthDecoder.bytes);
          buffer = new BufferList();
          if (options.onLength)
            options.onLength(dataLength);
          if (dataLength <= 0) {
            if (options.onData)
              options.onData(Empty);
            return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty };
          }
          return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: void 0 };
        },
        [ReadModes.DATA]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          if (!state) {
            throw new Error("state is required");
          }
          if (buffer.length < state.dataLength) {
            return { mode: ReadModes.DATA, buffer, state, chunk: void 0, data: void 0 };
          }
          const { dataLength } = state;
          const data = buffer.shallowSlice(0, dataLength);
          const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : void 0;
          buffer = new BufferList();
          if (options.onData)
            options.onData(data);
          return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: void 0, data };
        }
      };
      function decode5(options) {
        options = options || {};
        const opts = {
          lengthDecoder: options.lengthDecoder || varintDecode,
          maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
          maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
          onLength: options.onLength,
          onData: options.onData
        };
        const decoder = async function* (source) {
          let buffer = new BufferList();
          let mode = ReadModes.LENGTH;
          let state;
          for await (const chunk of source) {
            let nextChunk = chunk;
            while (nextChunk) {
              const result = ReadHandlers[mode](nextChunk, buffer, state, opts);
              mode = result.mode;
              nextChunk = result.chunk;
              buffer = result.buffer;
              state = result.state;
              if (result.data) {
                yield result.data;
              }
            }
          }
          if (buffer.length) {
            throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" });
          }
        };
        return decoder;
      }
      decode5.fromReader = (reader, options) => {
        let byteLength = 1;
        const varByteSource = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: async () => {
            try {
              return await reader.next(byteLength);
            } catch (err) {
              if (err.code === "ERR_UNDER_READ") {
                return { done: true, value: null };
              }
              throw err;
            } finally {
              byteLength = 1;
            }
          }
        };
        const onLength = (l) => {
          byteLength = l;
        };
        return decode5({
          ...options || {},
          onLength
        })(varByteSource);
      };
      module2.exports = decode5;
      module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
      module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/int32BE-encode.js
  var require_int32BE_encode = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/int32BE-encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var int32BEEncode = (value, target, offset) => {
        target = target || Buffer2.allocUnsafe(4);
        target.writeInt32BE(value, offset);
        return target;
      };
      int32BEEncode.bytes = 4;
      module2.exports = int32BEEncode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/int32BE-decode.js
  var require_int32BE_decode = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/int32BE-decode.js"(exports2, module2) {
      "use strict";
      var int32BEDecode = (data) => {
        if (data.length < 4)
          throw RangeError("Could not decode int32BE");
        return data.readInt32BE(0);
      };
      int32BEDecode.bytes = 4;
      module2.exports = int32BEDecode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/index.js
  var require_src5 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/node_modules/it-length-prefixed/src/index.js"(exports2) {
      "use strict";
      exports2.encode = require_encode3();
      exports2.decode = require_decode3();
      exports2.varintEncode = require_varint_encode();
      exports2.varintDecode = require_varint_decode();
      exports2.int32BEEncode = require_int32BE_encode();
      exports2.int32BEDecode = require_int32BE_decode();
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pb-rpc/src/index.js
  var require_src6 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pb-rpc/src/index.js"(exports2, module2) {
      "use strict";
      var isBuffer = require_is_buffer();
      var Shake = require_src4();
      var lp = require_src5();
      module2.exports = (duplex, opts = {}) => {
        const shake = Shake(duplex);
        const lpReader = lp.decode.fromReader(shake.reader, opts);
        let isDone = false;
        const W = {
          read: async (bytes) => {
            const { value, done } = await shake.reader.next(bytes);
            if (done && value.length < bytes) {
              throw new Error("Couldn't read enough bytes");
            }
            isDone = done;
            if (!value) {
              throw new Error("Value is null");
            }
            return value;
          },
          readLP: async () => {
            const { value, done } = await lpReader.next();
            isDone = done;
            if (!value) {
              throw new Error("Value is null");
            }
            return value;
          },
          readPB: async (proto) => {
            const value = await W.readLP();
            if (!value) {
              throw new Error("Value is null");
            }
            const buf = isBuffer(value) ? value : value.slice();
            return proto.decode(buf);
          },
          write: (data) => {
            shake.writer.push(data);
          },
          writeLP: (data) => {
            W.write(lp.encode.single(data, opts));
          },
          writePB: (data, proto) => {
            W.writeLP(proto.encode(data));
          },
          pb: (proto) => {
            return {
              read: () => W.readPB(proto),
              write: (d) => W.writePB(d, proto)
            };
          },
          unwrap: () => {
            shake.rest();
            return shake.stream;
          }
        };
        return W;
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/get-iterator/index.js
  var require_get_iterator2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/get-iterator/index.js"(exports2, module2) {
      module2.exports = function getIterator(obj) {
        if (obj) {
          if (typeof obj[Symbol.iterator] === "function") {
            return obj[Symbol.iterator]();
          }
          if (typeof obj[Symbol.asyncIterator] === "function") {
            return obj[Symbol.asyncIterator]();
          }
          if (typeof obj.next === "function") {
            return obj;
          }
        }
        throw new Error("argument is not an iterator or iterable");
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pair/index.js
  var require_it_pair = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pair/index.js"(exports2, module2) {
      "use strict";
      var getIterator = require_get_iterator2();
      module2.exports = function pair() {
        let _source, onSource;
        const sink = async (source2) => {
          if (_source)
            throw new Error("already piped");
          _source = getIterator(source2);
          if (onSource)
            onSource(_source);
        };
        const source = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            if (_source)
              return _source.next();
            return new Promise((resolve) => {
              onSource = (source2) => {
                onSource = null;
                resolve(source2.next());
              };
            });
          }
        };
        return { sink, source };
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pair/duplex.js
  var require_duplex2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pair/duplex.js"(exports2, module2) {
      var Pair = require_it_pair();
      module2.exports = function() {
        var a = Pair();
        var b = Pair();
        return [
          {
            source: a.source,
            sink: b.sink
          },
          {
            source: b.source,
            sink: a.sink
          }
        ];
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-buffer/index.js
  var require_it_buffer = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-buffer/index.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      module2.exports = async function* (source) {
        for await (const b of source) {
          if (Buffer2.isBuffer(b)) {
            yield b;
          } else if (BufferList.isBufferList(b)) {
            yield b.slice();
          } else {
            yield Buffer2.from(b);
          }
        }
      };
      module2.exports.toBuffer = module2.exports;
      module2.exports.toList = async function* (source) {
        for await (const b of source) {
          if (Buffer2.isBuffer(b)) {
            yield new BufferList().append(b);
          } else if (BufferList.isBufferList(b)) {
            yield b;
          } else {
            yield new BufferList().append(Buffer2.from(b));
          }
        }
      };
    }
  });

  // node_modules/libp2p-noise/node_modules/it-pipe/index.js
  var require_it_pipe = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-pipe/index.js"(exports2, module2) {
      var rawPipe = (...fns) => {
        let res;
        while (fns.length) {
          res = fns.shift()(res);
        }
        return res;
      };
      var isIterable = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
      var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable(obj.source);
      var duplexPipelineFn = (duplex) => (source) => {
        duplex.sink(source);
        return duplex.source;
      };
      var pipe = (...fns) => {
        if (isDuplex(fns[0])) {
          const duplex = fns[0];
          fns[0] = () => duplex.source;
        } else if (isIterable(fns[0])) {
          const source = fns[0];
          fns[0] = () => source;
        }
        if (fns.length > 1) {
          if (isDuplex(fns[fns.length - 1])) {
            fns[fns.length - 1] = fns[fns.length - 1].sink;
          }
        }
        if (fns.length > 2) {
          for (let i = 1; i < fns.length - 1; i++) {
            if (isDuplex(fns[i])) {
              fns[i] = duplexPipelineFn(fns[i]);
            }
          }
        }
        return rawPipe(...fns);
      };
      module2.exports = pipe;
      module2.exports.pipe = pipe;
      module2.exports.rawPipe = rawPipe;
      module2.exports.isIterable = isIterable;
      module2.exports.isDuplex = isDuplex;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-encode.js
  var require_varint_encode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-encode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint2();
      var { Buffer: Buffer2 } = require_buffer();
      var varintEncode = (value, target, offset) => {
        const ret = Varint.encode(value, target, offset);
        varintEncode.bytes = Varint.encode.bytes;
        return target || Buffer2.from(ret);
      };
      module2.exports = varintEncode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/encode.js
  var require_encode4 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintEncode = require_varint_encode2();
      var MIN_POOL_SIZE = 8;
      var DEFAULT_POOL_SIZE = 10 * 1024;
      function encode3(options) {
        options = options || {};
        const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
        const encodeLength = options.lengthEncoder || varintEncode;
        const encoder = async function* (source) {
          let pool = Buffer2.alloc(poolSize);
          let poolOffset = 0;
          for await (const chunk of source) {
            encodeLength(chunk.length, pool, poolOffset);
            const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
            poolOffset += encodeLength.bytes;
            if (pool.length - poolOffset < MIN_POOL_SIZE) {
              pool = Buffer2.alloc(poolSize);
              poolOffset = 0;
            }
            yield new BufferList().append(encodedLength).append(chunk);
          }
        };
        return encoder;
      }
      encode3.single = (chunk, options) => {
        options = options || {};
        const encodeLength = options.lengthEncoder || varintEncode;
        return new BufferList([encodeLength(chunk.length), chunk.slice()]);
      };
      module2.exports = encode3;
      module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
      module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-decode.js
  var require_varint_decode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/varint-decode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint2();
      var { Buffer: Buffer2 } = require_buffer();
      var toBufferProxy = (bl) => new Proxy({}, {
        get: (_, prop) => {
          return prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop));
        }
      });
      var varintDecode = (data) => {
        const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
        varintDecode.bytes = Varint.decode.bytes;
        return len;
      };
      module2.exports = varintDecode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/decode.js
  var require_decode4 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/decode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintDecode = require_varint_decode2();
      var MAX_LENGTH_LENGTH = 8;
      var MAX_DATA_LENGTH = 1024 * 1024 * 4;
      var Empty = Buffer2.alloc(0);
      var ReadModes = { LENGTH: "readLength", DATA: "readData" };
      var ReadHandlers = {
        [ReadModes.LENGTH]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          let dataLength;
          try {
            dataLength = options.lengthDecoder(buffer);
          } catch (err) {
            if (buffer.length > options.maxLengthLength) {
              throw Object.assign(err, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
            }
            if (err instanceof RangeError) {
              return { mode: ReadModes.LENGTH, buffer, chunk: void 0, state: void 0, data: void 0 };
            }
            throw err;
          }
          if (dataLength > options.maxDataLength) {
            throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" });
          }
          chunk = buffer.shallowSlice(options.lengthDecoder.bytes);
          buffer = new BufferList();
          if (options.onLength)
            options.onLength(dataLength);
          if (dataLength <= 0) {
            if (options.onData)
              options.onData(Empty);
            return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty };
          }
          return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: void 0 };
        },
        [ReadModes.DATA]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          if (!state) {
            throw new Error("state is required");
          }
          if (buffer.length < state.dataLength) {
            return { mode: ReadModes.DATA, buffer, state, chunk: void 0, data: void 0 };
          }
          const { dataLength } = state;
          const data = buffer.shallowSlice(0, dataLength);
          const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : void 0;
          buffer = new BufferList();
          if (options.onData)
            options.onData(data);
          return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: void 0, data };
        }
      };
      function decode5(options) {
        options = options || {};
        const opts = {
          lengthDecoder: options.lengthDecoder || varintDecode,
          maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
          maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
          onLength: options.onLength,
          onData: options.onData
        };
        const decoder = async function* (source) {
          let buffer = new BufferList();
          let mode = ReadModes.LENGTH;
          let state;
          for await (const chunk of source) {
            let nextChunk = chunk;
            while (nextChunk) {
              const result = ReadHandlers[mode](nextChunk, buffer, state, opts);
              mode = result.mode;
              nextChunk = result.chunk;
              buffer = result.buffer;
              state = result.state;
              if (result.data) {
                yield result.data;
              }
            }
          }
          if (buffer.length) {
            throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" });
          }
        };
        return decoder;
      }
      decode5.fromReader = (reader, options) => {
        let byteLength = 1;
        const varByteSource = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: async () => {
            try {
              return await reader.next(byteLength);
            } catch (err) {
              if (err.code === "ERR_UNDER_READ") {
                return { done: true, value: null };
              }
              throw err;
            } finally {
              byteLength = 1;
            }
          }
        };
        const onLength = (l) => {
          byteLength = l;
        };
        return decode5({
          ...options || {},
          onLength
        })(varByteSource);
      };
      module2.exports = decode5;
      module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
      module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-encode.js
  var require_int32BE_encode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var int32BEEncode = (value, target, offset) => {
        target = target || Buffer2.allocUnsafe(4);
        target.writeInt32BE(value, offset);
        return target;
      };
      int32BEEncode.bytes = 4;
      module2.exports = int32BEEncode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-decode.js
  var require_int32BE_decode2 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/int32BE-decode.js"(exports2, module2) {
      "use strict";
      var int32BEDecode = (data) => {
        if (data.length < 4)
          throw RangeError("Could not decode int32BE");
        return data.readInt32BE(0);
      };
      int32BEDecode.bytes = 4;
      module2.exports = int32BEDecode;
    }
  });

  // node_modules/libp2p-noise/node_modules/it-length-prefixed/src/index.js
  var require_src7 = __commonJS({
    "node_modules/libp2p-noise/node_modules/it-length-prefixed/src/index.js"(exports2) {
      "use strict";
      exports2.encode = require_encode4();
      exports2.decode = require_decode4();
      exports2.varintEncode = require_varint_encode2();
      exports2.varintDecode = require_varint_decode2();
      exports2.int32BEEncode = require_int32BE_encode2();
      exports2.int32BEDecode = require_int32BE_decode2();
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/hash/lib/hash.js
  var require_hash = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/hash/lib/hash.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function isSerializableHash(h) {
        return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
      }
      exports2.isSerializableHash = isSerializableHash;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/constant-time/lib/constant-time.js
  var require_constant_time = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      function select(subject, resultIfOne, resultIfZero) {
        return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
      }
      exports2.select = select;
      function lessOrEqual(a, b) {
        return (a | 0) - (b | 0) - 1 >>> 31 & 1;
      }
      exports2.lessOrEqual = lessOrEqual;
      function compare(a, b) {
        if (a.length !== b.length) {
          return 0;
        }
        var result = 0;
        for (var i = 0; i < a.length; i++) {
          result |= a[i] ^ b[i];
        }
        return 1 & result - 1 >>> 8;
      }
      exports2.compare = compare;
      function equal(a, b) {
        if (a.length === 0 || b.length === 0) {
          return false;
        }
        return compare(a, b) !== 0;
      }
      exports2.equal = equal;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/hmac/lib/hmac.js
  var require_hmac = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var hash_1 = require_hash();
      var constant_time_1 = require_constant_time();
      var wipe_1 = require_wipe();
      var HMAC = function() {
        function HMAC2(hash, key) {
          this._finished = false;
          this._inner = new hash();
          this._outer = new hash();
          this.blockSize = this._outer.blockSize;
          this.digestLength = this._outer.digestLength;
          var pad = new Uint8Array(this.blockSize);
          if (key.length > this.blockSize) {
            this._inner.update(key).finish(pad).clean();
          } else {
            pad.set(key);
          }
          for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 54;
          }
          this._inner.update(pad);
          for (var i = 0; i < pad.length; i++) {
            pad[i] ^= 54 ^ 92;
          }
          this._outer.update(pad);
          if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
          }
          wipe_1.wipe(pad);
        }
        HMAC2.prototype.reset = function() {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
          }
          this._inner.restoreState(this._innerKeyedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.clean = function() {
          if (hash_1.isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
          }
          if (hash_1.isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
          }
          this._inner.clean();
          this._outer.clean();
        };
        HMAC2.prototype.update = function(data) {
          this._inner.update(data);
          return this;
        };
        HMAC2.prototype.finish = function(out) {
          if (this._finished) {
            this._outer.finish(out);
            return this;
          }
          this._inner.finish(out);
          this._outer.update(out.subarray(0, this.digestLength)).finish(out);
          this._finished = true;
          return this;
        };
        HMAC2.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        HMAC2.prototype.saveState = function() {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
          }
          return this._inner.saveState();
        };
        HMAC2.prototype.restoreState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
          }
          this._inner.restoreState(savedState);
          this._outer.restoreState(this._outerKeyedState);
          this._finished = false;
          return this;
        };
        HMAC2.prototype.cleanSavedState = function(savedState) {
          if (!hash_1.isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
          }
          this._inner.cleanSavedState(savedState);
        };
        return HMAC2;
      }();
      exports2.HMAC = HMAC;
      function hmac(hash, key, data) {
        var h = new HMAC(hash, key);
        h.update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hmac = hmac;
      exports2.equal = constant_time_1.equal;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/hkdf/lib/hkdf.js
  var require_hkdf = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var hmac_1 = require_hmac();
      var wipe_1 = require_wipe();
      var HKDF = function() {
        function HKDF2(hash, key, salt, info) {
          if (salt === void 0) {
            salt = new Uint8Array(0);
          }
          this._counter = new Uint8Array(1);
          this._hash = hash;
          this._info = info;
          var okm = hmac_1.hmac(this._hash, salt, key);
          this._hmac = new hmac_1.HMAC(hash, okm);
          this._buffer = new Uint8Array(this._hmac.digestLength);
          this._bufpos = this._buffer.length;
        }
        HKDF2.prototype._fillBuffer = function() {
          this._counter[0]++;
          var ctr = this._counter[0];
          if (ctr === 0) {
            throw new Error("hkdf: cannot expand more");
          }
          this._hmac.reset();
          if (ctr > 1) {
            this._hmac.update(this._buffer);
          }
          if (this._info) {
            this._hmac.update(this._info);
          }
          this._hmac.update(this._counter);
          this._hmac.finish(this._buffer);
          this._bufpos = 0;
        };
        HKDF2.prototype.expand = function(length2) {
          var out = new Uint8Array(length2);
          for (var i = 0; i < out.length; i++) {
            if (this._bufpos === this._buffer.length) {
              this._fillBuffer();
            }
            out[i] = this._buffer[this._bufpos++];
          }
          return out;
        };
        HKDF2.prototype.clean = function() {
          this._hmac.clean();
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._counter);
          this._bufpos = 0;
        };
        return HKDF2;
      }();
      exports2.HKDF = HKDF;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/sha256/lib/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      exports2.DIGEST_LENGTH = 32;
      exports2.BLOCK_SIZE = 64;
      var SHA256 = function() {
        function SHA2562() {
          this.digestLength = exports2.DIGEST_LENGTH;
          this.blockSize = exports2.BLOCK_SIZE;
          this._state = new Int32Array(8);
          this._temp = new Int32Array(64);
          this._buffer = new Uint8Array(128);
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          this.reset();
        }
        SHA2562.prototype._initState = function() {
          this._state[0] = 1779033703;
          this._state[1] = 3144134277;
          this._state[2] = 1013904242;
          this._state[3] = 2773480762;
          this._state[4] = 1359893119;
          this._state[5] = 2600822924;
          this._state[6] = 528734635;
          this._state[7] = 1541459225;
        };
        SHA2562.prototype.reset = function() {
          this._initState();
          this._bufferLength = 0;
          this._bytesHashed = 0;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._temp);
          this.reset();
        };
        SHA2562.prototype.update = function(data, dataLength) {
          if (dataLength === void 0) {
            dataLength = data.length;
          }
          if (this._finished) {
            throw new Error("SHA256: can't update because hash was finished.");
          }
          var dataPos = 0;
          this._bytesHashed += dataLength;
          if (this._bufferLength > 0) {
            while (this._bufferLength < this.blockSize && dataLength > 0) {
              this._buffer[this._bufferLength++] = data[dataPos++];
              dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
              hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
              this._bufferLength = 0;
            }
          }
          if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
            dataLength %= this.blockSize;
          }
          while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          return this;
        };
        SHA2562.prototype.finish = function(out) {
          if (!this._finished) {
            var bytesHashed = this._bytesHashed;
            var left = this._bufferLength;
            var bitLenHi = bytesHashed / 536870912 | 0;
            var bitLenLo = bytesHashed << 3;
            var padLength = bytesHashed % 64 < 56 ? 64 : 128;
            this._buffer[left] = 128;
            for (var i = left + 1; i < padLength - 8; i++) {
              this._buffer[i] = 0;
            }
            binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
            this._finished = true;
          }
          for (var i = 0; i < this.digestLength / 4; i++) {
            binary_1.writeUint32BE(this._state[i], out, i * 4);
          }
          return this;
        };
        SHA2562.prototype.digest = function() {
          var out = new Uint8Array(this.digestLength);
          this.finish(out);
          return out;
        };
        SHA2562.prototype.saveState = function() {
          if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
          }
          return {
            state: new Int32Array(this._state),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
          };
        };
        SHA2562.prototype.restoreState = function(savedState) {
          this._state.set(savedState.state);
          this._bufferLength = savedState.bufferLength;
          if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
          }
          this._bytesHashed = savedState.bytesHashed;
          this._finished = false;
          return this;
        };
        SHA2562.prototype.cleanSavedState = function(savedState) {
          wipe_1.wipe(savedState.state);
          if (savedState.buffer) {
            wipe_1.wipe(savedState.buffer);
          }
          savedState.bufferLength = 0;
          savedState.bytesHashed = 0;
        };
        return SHA2562;
      }();
      exports2.SHA256 = SHA256;
      var K = new Int32Array([
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ]);
      function hashBlocks(w, v, p, pos, len) {
        while (len >= 64) {
          var a = v[0];
          var b = v[1];
          var c = v[2];
          var d = v[3];
          var e = v[4];
          var f = v[5];
          var g = v[6];
          var h = v[7];
          for (var i = 0; i < 16; i++) {
            var j = pos + i * 4;
            w[i] = binary_1.readUint32BE(p, j);
          }
          for (var i = 16; i < 64; i++) {
            var u = w[i - 2];
            var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
            u = w[i - 15];
            var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
            w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
          }
          for (var i = 0; i < 64; i++) {
            var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
            var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
            h = g;
            g = f;
            f = e;
            e = d + t1 | 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 | 0;
          }
          v[0] += a;
          v[1] += b;
          v[2] += c;
          v[3] += d;
          v[4] += e;
          v[5] += f;
          v[6] += g;
          v[7] += h;
          pos += 64;
          len -= 64;
        }
        return pos;
      }
      function hash(data) {
        var h = new SHA256();
        h.update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.hash = hash;
    }
  });

  // node_modules/@protobufjs/aspromise/index.js
  var require_aspromise = __commonJS({
    "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
      "use strict";
      module2.exports = asPromise;
      function asPromise(fn, ctx) {
        var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
        while (index < arguments.length)
          params[offset++] = arguments[index++];
        return new Promise(function executor(resolve, reject) {
          params[offset] = function callback(err) {
            if (pending) {
              pending = false;
              if (err)
                reject(err);
              else {
                var params2 = new Array(arguments.length - 1), offset2 = 0;
                while (offset2 < params2.length)
                  params2[offset2++] = arguments[offset2];
                resolve.apply(null, params2);
              }
            }
          };
          try {
            fn.apply(ctx || null, params);
          } catch (err) {
            if (pending) {
              pending = false;
              reject(err);
            }
          }
        });
      }
    }
  });

  // node_modules/@protobufjs/base64/index.js
  var require_base64 = __commonJS({
    "node_modules/@protobufjs/base64/index.js"(exports2) {
      "use strict";
      var base642 = exports2;
      base642.length = function length2(string2) {
        var p = string2.length;
        if (!p)
          return 0;
        var n = 0;
        while (--p % 4 > 1 && string2.charAt(p) === "=")
          ++n;
        return Math.ceil(string2.length * 3) / 4 - n;
      };
      var b64 = new Array(64);
      var s64 = new Array(123);
      for (i = 0; i < 64; )
        s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
      var i;
      base642.encode = function encode3(buffer, start, end) {
        var parts = null, chunk = [];
        var i2 = 0, j = 0, t;
        while (start < end) {
          var b = buffer[start++];
          switch (j) {
            case 0:
              chunk[i2++] = b64[b >> 2];
              t = (b & 3) << 4;
              j = 1;
              break;
            case 1:
              chunk[i2++] = b64[t | b >> 4];
              t = (b & 15) << 2;
              j = 2;
              break;
            case 2:
              chunk[i2++] = b64[t | b >> 6];
              chunk[i2++] = b64[b & 63];
              j = 0;
              break;
          }
          if (i2 > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i2 = 0;
          }
        }
        if (j) {
          chunk[i2++] = b64[t];
          chunk[i2++] = 61;
          if (j === 1)
            chunk[i2++] = 61;
        }
        if (parts) {
          if (i2)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i2));
      };
      var invalidEncoding = "invalid encoding";
      base642.decode = function decode5(string2, buffer, offset) {
        var start = offset;
        var j = 0, t;
        for (var i2 = 0; i2 < string2.length; ) {
          var c = string2.charCodeAt(i2++);
          if (c === 61 && j > 1)
            break;
          if ((c = s64[c]) === void 0)
            throw Error(invalidEncoding);
          switch (j) {
            case 0:
              t = c;
              j = 1;
              break;
            case 1:
              buffer[offset++] = t << 2 | (c & 48) >> 4;
              t = c;
              j = 2;
              break;
            case 2:
              buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
              t = c;
              j = 3;
              break;
            case 3:
              buffer[offset++] = (t & 3) << 6 | c;
              j = 0;
              break;
          }
        }
        if (j === 1)
          throw Error(invalidEncoding);
        return offset - start;
      };
      base642.test = function test(string2) {
        return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string2);
      };
    }
  });

  // node_modules/@protobufjs/eventemitter/index.js
  var require_eventemitter = __commonJS({
    "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
      "use strict";
      module2.exports = EventEmitter;
      function EventEmitter() {
        this._listeners = {};
      }
      EventEmitter.prototype.on = function on(evt, fn, ctx) {
        (this._listeners[evt] || (this._listeners[evt] = [])).push({
          fn,
          ctx: ctx || this
        });
        return this;
      };
      EventEmitter.prototype.off = function off(evt, fn) {
        if (evt === void 0)
          this._listeners = {};
        else {
          if (fn === void 0)
            this._listeners[evt] = [];
          else {
            var listeners = this._listeners[evt];
            for (var i = 0; i < listeners.length; )
              if (listeners[i].fn === fn)
                listeners.splice(i, 1);
              else
                ++i;
          }
        }
        return this;
      };
      EventEmitter.prototype.emit = function emit(evt) {
        var listeners = this._listeners[evt];
        if (listeners) {
          var args = [], i = 1;
          for (; i < arguments.length; )
            args.push(arguments[i++]);
          for (i = 0; i < listeners.length; )
            listeners[i].fn.apply(listeners[i++].ctx, args);
        }
        return this;
      };
    }
  });

  // node_modules/@protobufjs/float/index.js
  var require_float = __commonJS({
    "node_modules/@protobufjs/float/index.js"(exports2, module2) {
      "use strict";
      module2.exports = factory(factory);
      function factory(exports3) {
        if (typeof Float32Array !== "undefined")
          (function() {
            var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
            function writeFloat_f32_cpy(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
            }
            function writeFloat_f32_rev(val, buf, pos) {
              f32[0] = val;
              buf[pos] = f8b[3];
              buf[pos + 1] = f8b[2];
              buf[pos + 2] = f8b[1];
              buf[pos + 3] = f8b[0];
            }
            exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
            exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
            function readFloat_f32_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              return f32[0];
            }
            function readFloat_f32_rev(buf, pos) {
              f8b[3] = buf[pos];
              f8b[2] = buf[pos + 1];
              f8b[1] = buf[pos + 2];
              f8b[0] = buf[pos + 3];
              return f32[0];
            }
            exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
            exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
          })();
        else
          (function() {
            function writeFloat_ieee754(writeUint, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0)
                writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
              else if (isNaN(val))
                writeUint(2143289344, buf, pos);
              else if (val > 34028234663852886e22)
                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
              else if (val < 11754943508222875e-54)
                writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
              else {
                var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
              }
            }
            exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
            exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
            function readFloat_ieee754(readUint, buf, pos) {
              var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
              return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
            }
            exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
            exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
          })();
        if (typeof Float64Array !== "undefined")
          (function() {
            var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
            function writeDouble_f64_cpy(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[0];
              buf[pos + 1] = f8b[1];
              buf[pos + 2] = f8b[2];
              buf[pos + 3] = f8b[3];
              buf[pos + 4] = f8b[4];
              buf[pos + 5] = f8b[5];
              buf[pos + 6] = f8b[6];
              buf[pos + 7] = f8b[7];
            }
            function writeDouble_f64_rev(val, buf, pos) {
              f64[0] = val;
              buf[pos] = f8b[7];
              buf[pos + 1] = f8b[6];
              buf[pos + 2] = f8b[5];
              buf[pos + 3] = f8b[4];
              buf[pos + 4] = f8b[3];
              buf[pos + 5] = f8b[2];
              buf[pos + 6] = f8b[1];
              buf[pos + 7] = f8b[0];
            }
            exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
            exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
            function readDouble_f64_cpy(buf, pos) {
              f8b[0] = buf[pos];
              f8b[1] = buf[pos + 1];
              f8b[2] = buf[pos + 2];
              f8b[3] = buf[pos + 3];
              f8b[4] = buf[pos + 4];
              f8b[5] = buf[pos + 5];
              f8b[6] = buf[pos + 6];
              f8b[7] = buf[pos + 7];
              return f64[0];
            }
            function readDouble_f64_rev(buf, pos) {
              f8b[7] = buf[pos];
              f8b[6] = buf[pos + 1];
              f8b[5] = buf[pos + 2];
              f8b[4] = buf[pos + 3];
              f8b[3] = buf[pos + 4];
              f8b[2] = buf[pos + 5];
              f8b[1] = buf[pos + 6];
              f8b[0] = buf[pos + 7];
              return f64[0];
            }
            exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
            exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
          })();
        else
          (function() {
            function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
              var sign = val < 0 ? 1 : 0;
              if (sign)
                val = -val;
              if (val === 0) {
                writeUint(0, buf, pos + off0);
                writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
              } else if (isNaN(val)) {
                writeUint(0, buf, pos + off0);
                writeUint(2146959360, buf, pos + off1);
              } else if (val > 17976931348623157e292) {
                writeUint(0, buf, pos + off0);
                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
              } else {
                var mantissa;
                if (val < 22250738585072014e-324) {
                  mantissa = val / 5e-324;
                  writeUint(mantissa >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
                } else {
                  var exponent = Math.floor(Math.log(val) / Math.LN2);
                  if (exponent === 1024)
                    exponent = 1023;
                  mantissa = val * Math.pow(2, -exponent);
                  writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
                  writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
                }
              }
            }
            exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
            exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
            function readDouble_ieee754(readUint, off0, off1, buf, pos) {
              var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
              var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
              return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
            }
            exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
            exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
          })();
        return exports3;
      }
      function writeUintLE(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      function writeUintBE(val, buf, pos) {
        buf[pos] = val >>> 24;
        buf[pos + 1] = val >>> 16 & 255;
        buf[pos + 2] = val >>> 8 & 255;
        buf[pos + 3] = val & 255;
      }
      function readUintLE(buf, pos) {
        return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
      }
      function readUintBE(buf, pos) {
        return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
      }
    }
  });

  // node_modules/@protobufjs/inquire/index.js
  var require_inquire = __commonJS({
    "node_modules/@protobufjs/inquire/index.js"(exports, module) {
      "use strict";
      module.exports = inquire;
      function inquire(moduleName) {
        try {
          var mod = eval("quire".replace(/^/, "re"))(moduleName);
          if (mod && (mod.length || Object.keys(mod).length))
            return mod;
        } catch (e) {
        }
        return null;
      }
    }
  });

  // node_modules/@protobufjs/utf8/index.js
  var require_utf8 = __commonJS({
    "node_modules/@protobufjs/utf8/index.js"(exports2) {
      "use strict";
      var utf8 = exports2;
      utf8.length = function utf8_length(string2) {
        var len = 0, c = 0;
        for (var i = 0; i < string2.length; ++i) {
          c = string2.charCodeAt(i);
          if (c < 128)
            len += 1;
          else if (c < 2048)
            len += 2;
          else if ((c & 64512) === 55296 && (string2.charCodeAt(i + 1) & 64512) === 56320) {
            ++i;
            len += 4;
          } else
            len += 3;
        }
        return len;
      };
      utf8.read = function utf8_read(buffer, start, end) {
        var len = end - start;
        if (len < 1)
          return "";
        var parts = null, chunk = [], i = 0, t;
        while (start < end) {
          t = buffer[start++];
          if (t < 128)
            chunk[i++] = t;
          else if (t > 191 && t < 224)
            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
          else if (t > 239 && t < 365) {
            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
            chunk[i++] = 55296 + (t >> 10);
            chunk[i++] = 56320 + (t & 1023);
          } else
            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
          if (i > 8191) {
            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
            i = 0;
          }
        }
        if (parts) {
          if (i)
            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
          return parts.join("");
        }
        return String.fromCharCode.apply(String, chunk.slice(0, i));
      };
      utf8.write = function utf8_write(string2, buffer, offset) {
        var start = offset, c1, c2;
        for (var i = 0; i < string2.length; ++i) {
          c1 = string2.charCodeAt(i);
          if (c1 < 128) {
            buffer[offset++] = c1;
          } else if (c1 < 2048) {
            buffer[offset++] = c1 >> 6 | 192;
            buffer[offset++] = c1 & 63 | 128;
          } else if ((c1 & 64512) === 55296 && ((c2 = string2.charCodeAt(i + 1)) & 64512) === 56320) {
            c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
            ++i;
            buffer[offset++] = c1 >> 18 | 240;
            buffer[offset++] = c1 >> 12 & 63 | 128;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          } else {
            buffer[offset++] = c1 >> 12 | 224;
            buffer[offset++] = c1 >> 6 & 63 | 128;
            buffer[offset++] = c1 & 63 | 128;
          }
        }
        return offset - start;
      };
    }
  });

  // node_modules/@protobufjs/pool/index.js
  var require_pool = __commonJS({
    "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
      "use strict";
      module2.exports = pool;
      function pool(alloc, slice, size) {
        var SIZE = size || 8192;
        var MAX = SIZE >>> 1;
        var slab = null;
        var offset = SIZE;
        return function pool_alloc(size2) {
          if (size2 < 1 || size2 > MAX)
            return alloc(size2);
          if (offset + size2 > SIZE) {
            slab = alloc(SIZE);
            offset = 0;
          }
          var buf = slice.call(slab, offset, offset += size2);
          if (offset & 7)
            offset = (offset | 7) + 1;
          return buf;
        };
      }
    }
  });

  // node_modules/protobufjs/src/util/longbits.js
  var require_longbits = __commonJS({
    "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
      "use strict";
      module2.exports = LongBits;
      var util = require_minimal();
      function LongBits(lo, hi) {
        this.lo = lo >>> 0;
        this.hi = hi >>> 0;
      }
      var zero = LongBits.zero = new LongBits(0, 0);
      zero.toNumber = function() {
        return 0;
      };
      zero.zzEncode = zero.zzDecode = function() {
        return this;
      };
      zero.length = function() {
        return 1;
      };
      var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
      LongBits.fromNumber = function fromNumber(value) {
        if (value === 0)
          return zero;
        var sign = value < 0;
        if (sign)
          value = -value;
        var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
        if (sign) {
          hi = ~hi >>> 0;
          lo = ~lo >>> 0;
          if (++lo > 4294967295) {
            lo = 0;
            if (++hi > 4294967295)
              hi = 0;
          }
        }
        return new LongBits(lo, hi);
      };
      LongBits.from = function from3(value) {
        if (typeof value === "number")
          return LongBits.fromNumber(value);
        if (util.isString(value)) {
          if (util.Long)
            value = util.Long.fromString(value);
          else
            return LongBits.fromNumber(parseInt(value, 10));
        }
        return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
      };
      LongBits.prototype.toNumber = function toNumber(unsigned) {
        if (!unsigned && this.hi >>> 31) {
          var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
          if (!lo)
            hi = hi + 1 >>> 0;
          return -(lo + hi * 4294967296);
        }
        return this.lo + this.hi * 4294967296;
      };
      LongBits.prototype.toLong = function toLong(unsigned) {
        return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
      };
      var charCodeAt = String.prototype.charCodeAt;
      LongBits.fromHash = function fromHash(hash) {
        if (hash === zeroHash)
          return zero;
        return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
      };
      LongBits.prototype.toHash = function toHash() {
        return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
      };
      LongBits.prototype.zzEncode = function zzEncode() {
        var mask = this.hi >> 31;
        this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
        this.lo = (this.lo << 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.zzDecode = function zzDecode() {
        var mask = -(this.lo & 1);
        this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
        this.hi = (this.hi >>> 1 ^ mask) >>> 0;
        return this;
      };
      LongBits.prototype.length = function length2() {
        var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
        return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
      };
    }
  });

  // node_modules/protobufjs/src/util/minimal.js
  var require_minimal = __commonJS({
    "node_modules/protobufjs/src/util/minimal.js"(exports2) {
      "use strict";
      var util = exports2;
      util.asPromise = require_aspromise();
      util.base64 = require_base64();
      util.EventEmitter = require_eventemitter();
      util.float = require_float();
      util.inquire = require_inquire();
      util.utf8 = require_utf8();
      util.pool = require_pool();
      util.LongBits = require_longbits();
      util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
      util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
      util.emptyArray = Object.freeze ? Object.freeze([]) : [];
      util.emptyObject = Object.freeze ? Object.freeze({}) : {};
      util.isInteger = Number.isInteger || function isInteger(value) {
        return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
      };
      util.isString = function isString(value) {
        return typeof value === "string" || value instanceof String;
      };
      util.isObject = function isObject(value) {
        return value && typeof value === "object";
      };
      util.isset = util.isSet = function isSet(obj, prop) {
        var value = obj[prop];
        if (value != null && obj.hasOwnProperty(prop))
          return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
        return false;
      };
      util.Buffer = function() {
        try {
          var Buffer2 = util.inquire("buffer").Buffer;
          return Buffer2.prototype.utf8Write ? Buffer2 : null;
        } catch (e) {
          return null;
        }
      }();
      util._Buffer_from = null;
      util._Buffer_allocUnsafe = null;
      util.newBuffer = function newBuffer(sizeOrArray) {
        return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
      };
      util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
      util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
      util.key2Re = /^true|false|0|1$/;
      util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
      util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
      util.longToHash = function longToHash(value) {
        return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
      };
      util.longFromHash = function longFromHash(hash, unsigned) {
        var bits = util.LongBits.fromHash(hash);
        if (util.Long)
          return util.Long.fromBits(bits.lo, bits.hi, unsigned);
        return bits.toNumber(Boolean(unsigned));
      };
      function merge(dst, src2, ifNotSet) {
        for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
          if (dst[keys[i]] === void 0 || !ifNotSet)
            dst[keys[i]] = src2[keys[i]];
        return dst;
      }
      util.merge = merge;
      util.lcFirst = function lcFirst(str) {
        return str.charAt(0).toLowerCase() + str.substring(1);
      };
      function newError(name) {
        function CustomError(message, properties) {
          if (!(this instanceof CustomError))
            return new CustomError(message, properties);
          Object.defineProperty(this, "message", { get: function() {
            return message;
          } });
          if (Error.captureStackTrace)
            Error.captureStackTrace(this, CustomError);
          else
            Object.defineProperty(this, "stack", { value: new Error().stack || "" });
          if (properties)
            merge(this, properties);
        }
        (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
        Object.defineProperty(CustomError.prototype, "name", { get: function() {
          return name;
        } });
        CustomError.prototype.toString = function toString3() {
          return this.name + ": " + this.message;
        };
        return CustomError;
      }
      util.newError = newError;
      util.ProtocolError = newError("ProtocolError");
      util.oneOfGetter = function getOneOf(fieldNames) {
        var fieldMap = {};
        for (var i = 0; i < fieldNames.length; ++i)
          fieldMap[fieldNames[i]] = 1;
        return function() {
          for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
            if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
              return keys[i2];
        };
      };
      util.oneOfSetter = function setOneOf(fieldNames) {
        return function(name) {
          for (var i = 0; i < fieldNames.length; ++i)
            if (fieldNames[i] !== name)
              delete this[fieldNames[i]];
        };
      };
      util.toJSONOptions = {
        longs: String,
        enums: String,
        bytes: String,
        json: true
      };
      util._configure = function() {
        var Buffer2 = util.Buffer;
        if (!Buffer2) {
          util._Buffer_from = util._Buffer_allocUnsafe = null;
          return;
        }
        util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
          return new Buffer2(value, encoding);
        };
        util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
          return new Buffer2(size);
        };
      };
    }
  });

  // node_modules/protobufjs/src/writer.js
  var require_writer = __commonJS({
    "node_modules/protobufjs/src/writer.js"(exports2, module2) {
      "use strict";
      module2.exports = Writer;
      var util = require_minimal();
      var BufferWriter;
      var LongBits = util.LongBits;
      var base642 = util.base64;
      var utf8 = util.utf8;
      function Op(fn, len, val) {
        this.fn = fn;
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      function noop() {
      }
      function State(writer) {
        this.head = writer.head;
        this.tail = writer.tail;
        this.len = writer.len;
        this.next = writer.states;
      }
      function Writer() {
        this.len = 0;
        this.head = new Op(noop, 0, 0);
        this.tail = this.head;
        this.states = null;
      }
      var create3 = function create4() {
        return util.Buffer ? function create_buffer_setup() {
          return (Writer.create = function create_buffer() {
            return new BufferWriter();
          })();
        } : function create_array() {
          return new Writer();
        };
      };
      Writer.create = create3();
      Writer.alloc = function alloc(size) {
        return new util.Array(size);
      };
      if (util.Array !== Array)
        Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
      Writer.prototype._push = function push(fn, len, val) {
        this.tail = this.tail.next = new Op(fn, len, val);
        this.len += len;
        return this;
      };
      function writeByte(val, buf, pos) {
        buf[pos] = val & 255;
      }
      function writeVarint32(val, buf, pos) {
        while (val > 127) {
          buf[pos++] = val & 127 | 128;
          val >>>= 7;
        }
        buf[pos] = val;
      }
      function VarintOp(len, val) {
        this.len = len;
        this.next = void 0;
        this.val = val;
      }
      VarintOp.prototype = Object.create(Op.prototype);
      VarintOp.prototype.fn = writeVarint32;
      Writer.prototype.uint32 = function write_uint32(value) {
        this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
        return this;
      };
      Writer.prototype.int32 = function write_int32(value) {
        return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
      };
      Writer.prototype.sint32 = function write_sint32(value) {
        return this.uint32((value << 1 ^ value >> 31) >>> 0);
      };
      function writeVarint64(val, buf, pos) {
        while (val.hi) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
          val.hi >>>= 7;
        }
        while (val.lo > 127) {
          buf[pos++] = val.lo & 127 | 128;
          val.lo = val.lo >>> 7;
        }
        buf[pos++] = val.lo;
      }
      Writer.prototype.uint64 = function write_uint64(value) {
        var bits = LongBits.from(value);
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.int64 = Writer.prototype.uint64;
      Writer.prototype.sint64 = function write_sint64(value) {
        var bits = LongBits.from(value).zzEncode();
        return this._push(writeVarint64, bits.length(), bits);
      };
      Writer.prototype.bool = function write_bool(value) {
        return this._push(writeByte, 1, value ? 1 : 0);
      };
      function writeFixed32(val, buf, pos) {
        buf[pos] = val & 255;
        buf[pos + 1] = val >>> 8 & 255;
        buf[pos + 2] = val >>> 16 & 255;
        buf[pos + 3] = val >>> 24;
      }
      Writer.prototype.fixed32 = function write_fixed32(value) {
        return this._push(writeFixed32, 4, value >>> 0);
      };
      Writer.prototype.sfixed32 = Writer.prototype.fixed32;
      Writer.prototype.fixed64 = function write_fixed64(value) {
        var bits = LongBits.from(value);
        return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
      };
      Writer.prototype.sfixed64 = Writer.prototype.fixed64;
      Writer.prototype.float = function write_float(value) {
        return this._push(util.float.writeFloatLE, 4, value);
      };
      Writer.prototype.double = function write_double(value) {
        return this._push(util.float.writeDoubleLE, 8, value);
      };
      var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytes_for(val, buf, pos) {
        for (var i = 0; i < val.length; ++i)
          buf[pos + i] = val[i];
      };
      Writer.prototype.bytes = function write_bytes(value) {
        var len = value.length >>> 0;
        if (!len)
          return this._push(writeByte, 1, 0);
        if (util.isString(value)) {
          var buf = Writer.alloc(len = base642.length(value));
          base642.decode(value, buf, 0);
          value = buf;
        }
        return this.uint32(len)._push(writeBytes, len, value);
      };
      Writer.prototype.string = function write_string(value) {
        var len = utf8.length(value);
        return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
      };
      Writer.prototype.fork = function fork() {
        this.states = new State(this);
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
        return this;
      };
      Writer.prototype.reset = function reset() {
        if (this.states) {
          this.head = this.states.head;
          this.tail = this.states.tail;
          this.len = this.states.len;
          this.states = this.states.next;
        } else {
          this.head = this.tail = new Op(noop, 0, 0);
          this.len = 0;
        }
        return this;
      };
      Writer.prototype.ldelim = function ldelim() {
        var head = this.head, tail = this.tail, len = this.len;
        this.reset().uint32(len);
        if (len) {
          this.tail.next = head.next;
          this.tail = tail;
          this.len += len;
        }
        return this;
      };
      Writer.prototype.finish = function finish() {
        var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
        while (head) {
          head.fn(head.val, buf, pos);
          pos += head.len;
          head = head.next;
        }
        return buf;
      };
      Writer._configure = function(BufferWriter_) {
        BufferWriter = BufferWriter_;
        Writer.create = create3();
        BufferWriter._configure();
      };
    }
  });

  // node_modules/protobufjs/src/writer_buffer.js
  var require_writer_buffer = __commonJS({
    "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferWriter;
      var Writer = require_writer();
      (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
      var util = require_minimal();
      function BufferWriter() {
        Writer.call(this);
      }
      BufferWriter._configure = function() {
        BufferWriter.alloc = util._Buffer_allocUnsafe;
        BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
          buf.set(val, pos);
        } : function writeBytesBuffer_copy(val, buf, pos) {
          if (val.copy)
            val.copy(buf, pos, 0, val.length);
          else
            for (var i = 0; i < val.length; )
              buf[pos++] = val[i++];
        };
      };
      BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
        if (util.isString(value))
          value = util._Buffer_from(value, "base64");
        var len = value.length >>> 0;
        this.uint32(len);
        if (len)
          this._push(BufferWriter.writeBytesBuffer, len, value);
        return this;
      };
      function writeStringBuffer(val, buf, pos) {
        if (val.length < 40)
          util.utf8.write(val, buf, pos);
        else if (buf.utf8Write)
          buf.utf8Write(val, pos);
        else
          buf.write(val, pos);
      }
      BufferWriter.prototype.string = function write_string_buffer(value) {
        var len = util.Buffer.byteLength(value);
        this.uint32(len);
        if (len)
          this._push(writeStringBuffer, len, value);
        return this;
      };
      BufferWriter._configure();
    }
  });

  // node_modules/protobufjs/src/reader.js
  var require_reader = __commonJS({
    "node_modules/protobufjs/src/reader.js"(exports2, module2) {
      "use strict";
      module2.exports = Reader;
      var util = require_minimal();
      var BufferReader;
      var LongBits = util.LongBits;
      var utf8 = util.utf8;
      function indexOutOfRange(reader, writeLength) {
        return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
      }
      function Reader(buffer) {
        this.buf = buffer;
        this.pos = 0;
        this.len = buffer.length;
      }
      var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
        if (buffer instanceof Uint8Array || Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      } : function create_array2(buffer) {
        if (Array.isArray(buffer))
          return new Reader(buffer);
        throw Error("illegal buffer");
      };
      var create3 = function create4() {
        return util.Buffer ? function create_buffer_setup(buffer) {
          return (Reader.create = function create_buffer(buffer2) {
            return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
          })(buffer);
        } : create_array;
      };
      Reader.create = create3();
      Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
      Reader.prototype.uint32 = function read_uint32_setup() {
        var value = 4294967295;
        return function read_uint32() {
          value = (this.buf[this.pos] & 127) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
          if (this.buf[this.pos++] < 128)
            return value;
          if ((this.pos += 5) > this.len) {
            this.pos = this.len;
            throw indexOutOfRange(this, 10);
          }
          return value;
        };
      }();
      Reader.prototype.int32 = function read_int32() {
        return this.uint32() | 0;
      };
      Reader.prototype.sint32 = function read_sint32() {
        var value = this.uint32();
        return value >>> 1 ^ -(value & 1) | 0;
      };
      function readLongVarint() {
        var bits = new LongBits(0, 0);
        var i = 0;
        if (this.len - this.pos > 4) {
          for (; i < 4; ++i) {
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
          i = 0;
        } else {
          for (; i < 3; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
          bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
          return bits;
        }
        if (this.len - this.pos > 4) {
          for (; i < 5; ++i) {
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        } else {
          for (; i < 5; ++i) {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
            if (this.buf[this.pos++] < 128)
              return bits;
          }
        }
        throw Error("invalid varint encoding");
      }
      Reader.prototype.bool = function read_bool() {
        return this.uint32() !== 0;
      };
      function readFixed32_end(buf, end) {
        return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
      }
      Reader.prototype.fixed32 = function read_fixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4);
      };
      Reader.prototype.sfixed32 = function read_sfixed32() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        return readFixed32_end(this.buf, this.pos += 4) | 0;
      };
      function readFixed64() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 8);
        return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
      }
      Reader.prototype.float = function read_float() {
        if (this.pos + 4 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readFloatLE(this.buf, this.pos);
        this.pos += 4;
        return value;
      };
      Reader.prototype.double = function read_double() {
        if (this.pos + 8 > this.len)
          throw indexOutOfRange(this, 4);
        var value = util.float.readDoubleLE(this.buf, this.pos);
        this.pos += 8;
        return value;
      };
      Reader.prototype.bytes = function read_bytes() {
        var length2 = this.uint32(), start = this.pos, end = this.pos + length2;
        if (end > this.len)
          throw indexOutOfRange(this, length2);
        this.pos += length2;
        if (Array.isArray(this.buf))
          return this.buf.slice(start, end);
        return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
      };
      Reader.prototype.string = function read_string() {
        var bytes = this.bytes();
        return utf8.read(bytes, 0, bytes.length);
      };
      Reader.prototype.skip = function skip(length2) {
        if (typeof length2 === "number") {
          if (this.pos + length2 > this.len)
            throw indexOutOfRange(this, length2);
          this.pos += length2;
        } else {
          do {
            if (this.pos >= this.len)
              throw indexOutOfRange(this);
          } while (this.buf[this.pos++] & 128);
        }
        return this;
      };
      Reader.prototype.skipType = function(wireType) {
        switch (wireType) {
          case 0:
            this.skip();
            break;
          case 1:
            this.skip(8);
            break;
          case 2:
            this.skip(this.uint32());
            break;
          case 3:
            while ((wireType = this.uint32() & 7) !== 4) {
              this.skipType(wireType);
            }
            break;
          case 5:
            this.skip(4);
            break;
          default:
            throw Error("invalid wire type " + wireType + " at offset " + this.pos);
        }
        return this;
      };
      Reader._configure = function(BufferReader_) {
        BufferReader = BufferReader_;
        Reader.create = create3();
        BufferReader._configure();
        var fn = util.Long ? "toLong" : "toNumber";
        util.merge(Reader.prototype, {
          int64: function read_int64() {
            return readLongVarint.call(this)[fn](false);
          },
          uint64: function read_uint64() {
            return readLongVarint.call(this)[fn](true);
          },
          sint64: function read_sint64() {
            return readLongVarint.call(this).zzDecode()[fn](false);
          },
          fixed64: function read_fixed64() {
            return readFixed64.call(this)[fn](true);
          },
          sfixed64: function read_sfixed64() {
            return readFixed64.call(this)[fn](false);
          }
        });
      };
    }
  });

  // node_modules/protobufjs/src/reader_buffer.js
  var require_reader_buffer = __commonJS({
    "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
      "use strict";
      module2.exports = BufferReader;
      var Reader = require_reader();
      (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
      var util = require_minimal();
      function BufferReader(buffer) {
        Reader.call(this, buffer);
      }
      BufferReader._configure = function() {
        if (util.Buffer)
          BufferReader.prototype._slice = util.Buffer.prototype.slice;
      };
      BufferReader.prototype.string = function read_string_buffer() {
        var len = this.uint32();
        return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
      };
      BufferReader._configure();
    }
  });

  // node_modules/protobufjs/src/rpc/service.js
  var require_service = __commonJS({
    "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
      "use strict";
      module2.exports = Service;
      var util = require_minimal();
      (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
      function Service(rpcImpl, requestDelimited, responseDelimited) {
        if (typeof rpcImpl !== "function")
          throw TypeError("rpcImpl must be a function");
        util.EventEmitter.call(this);
        this.rpcImpl = rpcImpl;
        this.requestDelimited = Boolean(requestDelimited);
        this.responseDelimited = Boolean(responseDelimited);
      }
      Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
        if (!request)
          throw TypeError("request must be specified");
        var self2 = this;
        if (!callback)
          return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
        if (!self2.rpcImpl) {
          setTimeout(function() {
            callback(Error("already ended"));
          }, 0);
          return void 0;
        }
        try {
          return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(true);
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          });
        } catch (err) {
          self2.emit("error", err, method);
          setTimeout(function() {
            callback(err);
          }, 0);
          return void 0;
        }
      };
      Service.prototype.end = function end(endedByRPC) {
        if (this.rpcImpl) {
          if (!endedByRPC)
            this.rpcImpl(null, null, null);
          this.rpcImpl = null;
          this.emit("end").off();
        }
        return this;
      };
    }
  });

  // node_modules/protobufjs/src/rpc.js
  var require_rpc = __commonJS({
    "node_modules/protobufjs/src/rpc.js"(exports2) {
      "use strict";
      var rpc = exports2;
      rpc.Service = require_service();
    }
  });

  // node_modules/protobufjs/src/roots.js
  var require_roots = __commonJS({
    "node_modules/protobufjs/src/roots.js"(exports2, module2) {
      "use strict";
      module2.exports = {};
    }
  });

  // node_modules/protobufjs/src/index-minimal.js
  var require_index_minimal = __commonJS({
    "node_modules/protobufjs/src/index-minimal.js"(exports2) {
      "use strict";
      var protobuf = exports2;
      protobuf.build = "minimal";
      protobuf.Writer = require_writer();
      protobuf.BufferWriter = require_writer_buffer();
      protobuf.Reader = require_reader();
      protobuf.BufferReader = require_reader_buffer();
      protobuf.util = require_minimal();
      protobuf.rpc = require_rpc();
      protobuf.roots = require_roots();
      protobuf.configure = configure;
      function configure() {
        protobuf.util._configure();
        protobuf.Writer._configure(protobuf.BufferWriter);
        protobuf.Reader._configure(protobuf.BufferReader);
      }
      configure();
    }
  });

  // node_modules/protobufjs/minimal.js
  var require_minimal2 = __commonJS({
    "node_modules/protobufjs/minimal.js"(exports2, module2) {
      "use strict";
      module2.exports = require_index_minimal();
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/keys.js
  var require_keys = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/keys.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-crypto-keys"] || ($protobuf.roots["libp2p-crypto-keys"] = {});
      $root.KeyType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RSA"] = 0;
        values[valuesById[1] = "Ed25519"] = 1;
        values[valuesById[2] = "Secp256k1"] = 2;
        return values;
      }();
      $root.PublicKey = function() {
        function PublicKey(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PublicKey.prototype.Type = 0;
        PublicKey.prototype.Data = $util.newBuffer([]);
        PublicKey.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          w.uint32(8).int32(m.Type);
          w.uint32(18).bytes(m.Data);
          return w;
        };
        PublicKey.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PublicKey();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.Type = r.int32();
                break;
              case 2:
                m.Data = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("Type"))
            throw $util.ProtocolError("missing required 'Type'", { instance: m });
          if (!m.hasOwnProperty("Data"))
            throw $util.ProtocolError("missing required 'Data'", { instance: m });
          return m;
        };
        PublicKey.fromObject = function fromObject(d) {
          if (d instanceof $root.PublicKey)
            return d;
          var m = new $root.PublicKey();
          switch (d.Type) {
            case "RSA":
            case 0:
              m.Type = 0;
              break;
            case "Ed25519":
            case 1:
              m.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              m.Type = 2;
              break;
          }
          if (d.Data != null) {
            if (typeof d.Data === "string")
              $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length)
              m.Data = d.Data;
          }
          return m;
        };
        PublicKey.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.Type = o.enums === String ? "RSA" : 0;
            if (o.bytes === String)
              d.Data = "";
            else {
              d.Data = [];
              if (o.bytes !== Array)
                d.Data = $util.newBuffer(d.Data);
            }
          }
          if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
          }
          if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
          }
          return d;
        };
        PublicKey.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PublicKey;
      }();
      $root.PrivateKey = function() {
        function PrivateKey(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PrivateKey.prototype.Type = 0;
        PrivateKey.prototype.Data = $util.newBuffer([]);
        PrivateKey.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          w.uint32(8).int32(m.Type);
          w.uint32(18).bytes(m.Data);
          return w;
        };
        PrivateKey.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PrivateKey();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.Type = r.int32();
                break;
              case 2:
                m.Data = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("Type"))
            throw $util.ProtocolError("missing required 'Type'", { instance: m });
          if (!m.hasOwnProperty("Data"))
            throw $util.ProtocolError("missing required 'Data'", { instance: m });
          return m;
        };
        PrivateKey.fromObject = function fromObject(d) {
          if (d instanceof $root.PrivateKey)
            return d;
          var m = new $root.PrivateKey();
          switch (d.Type) {
            case "RSA":
            case 0:
              m.Type = 0;
              break;
            case "Ed25519":
            case 1:
              m.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              m.Type = 2;
              break;
          }
          if (d.Data != null) {
            if (typeof d.Data === "string")
              $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length)
              m.Data = d.Data;
          }
          return m;
        };
        PrivateKey.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.Type = o.enums === String ? "RSA" : 0;
            if (o.bytes === String)
              d.Data = "";
            else {
              d.Data = [];
              if (o.bytes !== Array)
                d.Data = $util.newBuffer(d.Data);
            }
          }
          if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
          }
          if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
          }
          return d;
        };
        PrivateKey.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PrivateKey;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/node-forge/lib/baseN.js
  var require_baseN = __commonJS({
    "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
      var api = {};
      module2.exports = api;
      var _reverseAlphabets = {};
      api.encode = function(input, alphabet, maxline) {
        if (typeof alphabet !== "string") {
          throw new TypeError('"alphabet" must be a string.');
        }
        if (maxline !== void 0 && typeof maxline !== "number") {
          throw new TypeError('"maxline" must be a number.');
        }
        var output = "";
        if (!(input instanceof Uint8Array)) {
          output = _encodeWithByteBuffer(input, alphabet);
        } else {
          var i = 0;
          var base3 = alphabet.length;
          var first = alphabet.charAt(0);
          var digits = [0];
          for (i = 0; i < input.length; ++i) {
            for (var j = 0, carry = input[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % base3;
              carry = carry / base3 | 0;
            }
            while (carry > 0) {
              digits.push(carry % base3);
              carry = carry / base3 | 0;
            }
          }
          for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
            output += first;
          }
          for (i = digits.length - 1; i >= 0; --i) {
            output += alphabet[digits[i]];
          }
        }
        if (maxline) {
          var regex = new RegExp(".{1," + maxline + "}", "g");
          output = output.match(regex).join("\r\n");
        }
        return output;
      };
      api.decode = function(input, alphabet) {
        if (typeof input !== "string") {
          throw new TypeError('"input" must be a string.');
        }
        if (typeof alphabet !== "string") {
          throw new TypeError('"alphabet" must be a string.');
        }
        var table = _reverseAlphabets[alphabet];
        if (!table) {
          table = _reverseAlphabets[alphabet] = [];
          for (var i = 0; i < alphabet.length; ++i) {
            table[alphabet.charCodeAt(i)] = i;
          }
        }
        input = input.replace(/\s/g, "");
        var base3 = alphabet.length;
        var first = alphabet.charAt(0);
        var bytes = [0];
        for (var i = 0; i < input.length; i++) {
          var value = table[input.charCodeAt(i)];
          if (value === void 0) {
            return;
          }
          for (var j = 0, carry = value; j < bytes.length; ++j) {
            carry += bytes[j] * base3;
            bytes[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
          bytes.push(0);
        }
        if (typeof Buffer !== "undefined") {
          return Buffer.from(bytes.reverse());
        }
        return new Uint8Array(bytes.reverse());
      };
      function _encodeWithByteBuffer(input, alphabet) {
        var i = 0;
        var base3 = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length(); ++i) {
          for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        var output = "";
        for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
        return output;
      }
    }
  });

  // node_modules/node-forge/lib/util.js
  var require_util = __commonJS({
    "node_modules/node-forge/lib/util.js"(exports2, module2) {
      var forge = require_forge();
      var baseN = require_baseN();
      var util = module2.exports = forge.util = forge.util || {};
      (function() {
        if (typeof process !== "undefined" && process.nextTick && !process.browser) {
          util.nextTick = process.nextTick;
          if (typeof setImmediate === "function") {
            util.setImmediate = setImmediate;
          } else {
            util.setImmediate = util.nextTick;
          }
          return;
        }
        if (typeof setImmediate === "function") {
          util.setImmediate = function() {
            return setImmediate.apply(void 0, arguments);
          };
          util.nextTick = function(callback) {
            return setImmediate(callback);
          };
          return;
        }
        util.setImmediate = function(callback) {
          setTimeout(callback, 0);
        };
        if (typeof window !== "undefined" && typeof window.postMessage === "function") {
          let handler2 = function(event) {
            if (event.source === window && event.data === msg) {
              event.stopPropagation();
              var copy = callbacks.slice();
              callbacks.length = 0;
              copy.forEach(function(callback) {
                callback();
              });
            }
          };
          var handler = handler2;
          var msg = "forge.setImmediate";
          var callbacks = [];
          util.setImmediate = function(callback) {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              window.postMessage(msg, "*");
            }
          };
          window.addEventListener("message", handler2, true);
        }
        if (typeof MutationObserver !== "undefined") {
          var now = Date.now();
          var attr = true;
          var div = document.createElement("div");
          var callbacks = [];
          new MutationObserver(function() {
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }).observe(div, { attributes: true });
          var oldSetImmediate = util.setImmediate;
          util.setImmediate = function(callback) {
            if (Date.now() - now > 15) {
              now = Date.now();
              oldSetImmediate(callback);
            } else {
              callbacks.push(callback);
              if (callbacks.length === 1) {
                div.setAttribute("a", attr = !attr);
              }
            }
          };
        }
        util.nextTick = util.setImmediate;
      })();
      util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
      util.globalScope = function() {
        if (util.isNodejs) {
          return global;
        }
        return typeof self === "undefined" ? window : self;
      }();
      util.isArray = Array.isArray || function(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
      };
      util.isArrayBuffer = function(x) {
        return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
      };
      util.isArrayBufferView = function(x) {
        return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
      };
      function _checkBitsParam(n) {
        if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
          throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
        }
      }
      util.ByteBuffer = ByteStringBuffer;
      function ByteStringBuffer(b) {
        this.data = "";
        this.read = 0;
        if (typeof b === "string") {
          this.data = b;
        } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
          if (typeof Buffer !== "undefined" && b instanceof Buffer) {
            this.data = b.toString("binary");
          } else {
            var arr = new Uint8Array(b);
            try {
              this.data = String.fromCharCode.apply(null, arr);
            } catch (e) {
              for (var i = 0; i < arr.length; ++i) {
                this.putByte(arr[i]);
              }
            }
          }
        } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
          this.data = b.data;
          this.read = b.read;
        }
        this._constructedStringLength = 0;
      }
      util.ByteStringBuffer = ByteStringBuffer;
      var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
      util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
        this._constructedStringLength += x;
        if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
          this.data.substr(0, 1);
          this._constructedStringLength = 0;
        }
      };
      util.ByteStringBuffer.prototype.length = function() {
        return this.data.length - this.read;
      };
      util.ByteStringBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      };
      util.ByteStringBuffer.prototype.putByte = function(b) {
        return this.putBytes(String.fromCharCode(b));
      };
      util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
        b = String.fromCharCode(b);
        var d = this.data;
        while (n > 0) {
          if (n & 1) {
            d += b;
          }
          n >>>= 1;
          if (n > 0) {
            b += b;
          }
        }
        this.data = d;
        this._optimizeConstructedString(n);
        return this;
      };
      util.ByteStringBuffer.prototype.putBytes = function(bytes) {
        this.data += bytes;
        this._optimizeConstructedString(bytes.length);
        return this;
      };
      util.ByteStringBuffer.prototype.putString = function(str) {
        return this.putBytes(util.encodeUtf8(str));
      };
      util.ByteStringBuffer.prototype.putInt16 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt24 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt32 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt16Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
      };
      util.ByteStringBuffer.prototype.putInt24Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
      };
      util.ByteStringBuffer.prototype.putInt32Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
      };
      util.ByteStringBuffer.prototype.putInt = function(i, n) {
        _checkBitsParam(n);
        var bytes = "";
        do {
          n -= 8;
          bytes += String.fromCharCode(i >> n & 255);
        } while (n > 0);
        return this.putBytes(bytes);
      };
      util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
        if (i < 0) {
          i += 2 << n - 1;
        }
        return this.putInt(i, n);
      };
      util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
        return this.putBytes(buffer.getBytes());
      };
      util.ByteStringBuffer.prototype.getByte = function() {
        return this.data.charCodeAt(this.read++);
      };
      util.ByteStringBuffer.prototype.getInt16 = function() {
        var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
        this.read += 2;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt24 = function() {
        var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
        this.read += 3;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt32 = function() {
        var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
        this.read += 4;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt16Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
        this.read += 2;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt24Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
        this.read += 3;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt32Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
        this.read += 4;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt = function(n) {
        _checkBitsParam(n);
        var rval = 0;
        do {
          rval = (rval << 8) + this.data.charCodeAt(this.read++);
          n -= 8;
        } while (n > 0);
        return rval;
      };
      util.ByteStringBuffer.prototype.getSignedInt = function(n) {
        var x = this.getInt(n);
        var max = 2 << n - 2;
        if (x >= max) {
          x -= max << 1;
        }
        return x;
      };
      util.ByteStringBuffer.prototype.getBytes = function(count) {
        var rval;
        if (count) {
          count = Math.min(this.length(), count);
          rval = this.data.slice(this.read, this.read + count);
          this.read += count;
        } else if (count === 0) {
          rval = "";
        } else {
          rval = this.read === 0 ? this.data : this.data.slice(this.read);
          this.clear();
        }
        return rval;
      };
      util.ByteStringBuffer.prototype.bytes = function(count) {
        return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
      };
      util.ByteStringBuffer.prototype.at = function(i) {
        return this.data.charCodeAt(this.read + i);
      };
      util.ByteStringBuffer.prototype.setAt = function(i, b) {
        this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
        return this;
      };
      util.ByteStringBuffer.prototype.last = function() {
        return this.data.charCodeAt(this.data.length - 1);
      };
      util.ByteStringBuffer.prototype.copy = function() {
        var c = util.createBuffer(this.data);
        c.read = this.read;
        return c;
      };
      util.ByteStringBuffer.prototype.compact = function() {
        if (this.read > 0) {
          this.data = this.data.slice(this.read);
          this.read = 0;
        }
        return this;
      };
      util.ByteStringBuffer.prototype.clear = function() {
        this.data = "";
        this.read = 0;
        return this;
      };
      util.ByteStringBuffer.prototype.truncate = function(count) {
        var len = Math.max(0, this.length() - count);
        this.data = this.data.substr(this.read, len);
        this.read = 0;
        return this;
      };
      util.ByteStringBuffer.prototype.toHex = function() {
        var rval = "";
        for (var i = this.read; i < this.data.length; ++i) {
          var b = this.data.charCodeAt(i);
          if (b < 16) {
            rval += "0";
          }
          rval += b.toString(16);
        }
        return rval;
      };
      util.ByteStringBuffer.prototype.toString = function() {
        return util.decodeUtf8(this.bytes());
      };
      function DataBuffer(b, options) {
        options = options || {};
        this.read = options.readOffset || 0;
        this.growSize = options.growSize || 1024;
        var isArrayBuffer = util.isArrayBuffer(b);
        var isArrayBufferView = util.isArrayBufferView(b);
        if (isArrayBuffer || isArrayBufferView) {
          if (isArrayBuffer) {
            this.data = new DataView(b);
          } else {
            this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
          }
          this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
          return;
        }
        this.data = new DataView(new ArrayBuffer(0));
        this.write = 0;
        if (b !== null && b !== void 0) {
          this.putBytes(b);
        }
        if ("writeOffset" in options) {
          this.write = options.writeOffset;
        }
      }
      util.DataBuffer = DataBuffer;
      util.DataBuffer.prototype.length = function() {
        return this.write - this.read;
      };
      util.DataBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      };
      util.DataBuffer.prototype.accommodate = function(amount, growSize) {
        if (this.length() >= amount) {
          return this;
        }
        growSize = Math.max(growSize || this.growSize, amount);
        var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        var dst = new Uint8Array(this.length() + growSize);
        dst.set(src2);
        this.data = new DataView(dst.buffer);
        return this;
      };
      util.DataBuffer.prototype.putByte = function(b) {
        this.accommodate(1);
        this.data.setUint8(this.write++, b);
        return this;
      };
      util.DataBuffer.prototype.fillWithByte = function(b, n) {
        this.accommodate(n);
        for (var i = 0; i < n; ++i) {
          this.data.setUint8(b);
        }
        return this;
      };
      util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
        if (util.isArrayBufferView(bytes)) {
          var src2 = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          var len = src2.byteLength - src2.byteOffset;
          this.accommodate(len);
          var dst = new Uint8Array(this.data.buffer, this.write);
          dst.set(src2);
          this.write += len;
          return this;
        }
        if (util.isArrayBuffer(bytes)) {
          var src2 = new Uint8Array(bytes);
          this.accommodate(src2.byteLength);
          var dst = new Uint8Array(this.data.buffer);
          dst.set(src2, this.write);
          this.write += src2.byteLength;
          return this;
        }
        if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
          var src2 = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
          this.accommodate(src2.byteLength);
          var dst = new Uint8Array(bytes.data.byteLength, this.write);
          dst.set(src2);
          this.write += src2.byteLength;
          return this;
        }
        if (bytes instanceof util.ByteStringBuffer) {
          bytes = bytes.data;
          encoding = "binary";
        }
        encoding = encoding || "binary";
        if (typeof bytes === "string") {
          var view;
          if (encoding === "hex") {
            this.accommodate(Math.ceil(bytes.length / 2));
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.hex.decode(bytes, view, this.write);
            return this;
          }
          if (encoding === "base64") {
            this.accommodate(Math.ceil(bytes.length / 4) * 3);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.base64.decode(bytes, view, this.write);
            return this;
          }
          if (encoding === "utf8") {
            bytes = util.encodeUtf8(bytes);
            encoding = "binary";
          }
          if (encoding === "binary" || encoding === "raw") {
            this.accommodate(bytes.length);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.raw.decode(view);
            return this;
          }
          if (encoding === "utf16") {
            this.accommodate(bytes.length * 2);
            view = new Uint16Array(this.data.buffer, this.write);
            this.write += util.text.utf16.encode(view);
            return this;
          }
          throw new Error("Invalid encoding: " + encoding);
        }
        throw Error("Invalid parameter: " + bytes);
      };
      util.DataBuffer.prototype.putBuffer = function(buffer) {
        this.putBytes(buffer);
        buffer.clear();
        return this;
      };
      util.DataBuffer.prototype.putString = function(str) {
        return this.putBytes(str, "utf16");
      };
      util.DataBuffer.prototype.putInt16 = function(i) {
        this.accommodate(2);
        this.data.setInt16(this.write, i);
        this.write += 2;
        return this;
      };
      util.DataBuffer.prototype.putInt24 = function(i) {
        this.accommodate(3);
        this.data.setInt16(this.write, i >> 8 & 65535);
        this.data.setInt8(this.write, i >> 16 & 255);
        this.write += 3;
        return this;
      };
      util.DataBuffer.prototype.putInt32 = function(i) {
        this.accommodate(4);
        this.data.setInt32(this.write, i);
        this.write += 4;
        return this;
      };
      util.DataBuffer.prototype.putInt16Le = function(i) {
        this.accommodate(2);
        this.data.setInt16(this.write, i, true);
        this.write += 2;
        return this;
      };
      util.DataBuffer.prototype.putInt24Le = function(i) {
        this.accommodate(3);
        this.data.setInt8(this.write, i >> 16 & 255);
        this.data.setInt16(this.write, i >> 8 & 65535, true);
        this.write += 3;
        return this;
      };
      util.DataBuffer.prototype.putInt32Le = function(i) {
        this.accommodate(4);
        this.data.setInt32(this.write, i, true);
        this.write += 4;
        return this;
      };
      util.DataBuffer.prototype.putInt = function(i, n) {
        _checkBitsParam(n);
        this.accommodate(n / 8);
        do {
          n -= 8;
          this.data.setInt8(this.write++, i >> n & 255);
        } while (n > 0);
        return this;
      };
      util.DataBuffer.prototype.putSignedInt = function(i, n) {
        _checkBitsParam(n);
        this.accommodate(n / 8);
        if (i < 0) {
          i += 2 << n - 1;
        }
        return this.putInt(i, n);
      };
      util.DataBuffer.prototype.getByte = function() {
        return this.data.getInt8(this.read++);
      };
      util.DataBuffer.prototype.getInt16 = function() {
        var rval = this.data.getInt16(this.read);
        this.read += 2;
        return rval;
      };
      util.DataBuffer.prototype.getInt24 = function() {
        var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
        this.read += 3;
        return rval;
      };
      util.DataBuffer.prototype.getInt32 = function() {
        var rval = this.data.getInt32(this.read);
        this.read += 4;
        return rval;
      };
      util.DataBuffer.prototype.getInt16Le = function() {
        var rval = this.data.getInt16(this.read, true);
        this.read += 2;
        return rval;
      };
      util.DataBuffer.prototype.getInt24Le = function() {
        var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
        this.read += 3;
        return rval;
      };
      util.DataBuffer.prototype.getInt32Le = function() {
        var rval = this.data.getInt32(this.read, true);
        this.read += 4;
        return rval;
      };
      util.DataBuffer.prototype.getInt = function(n) {
        _checkBitsParam(n);
        var rval = 0;
        do {
          rval = (rval << 8) + this.data.getInt8(this.read++);
          n -= 8;
        } while (n > 0);
        return rval;
      };
      util.DataBuffer.prototype.getSignedInt = function(n) {
        var x = this.getInt(n);
        var max = 2 << n - 2;
        if (x >= max) {
          x -= max << 1;
        }
        return x;
      };
      util.DataBuffer.prototype.getBytes = function(count) {
        var rval;
        if (count) {
          count = Math.min(this.length(), count);
          rval = this.data.slice(this.read, this.read + count);
          this.read += count;
        } else if (count === 0) {
          rval = "";
        } else {
          rval = this.read === 0 ? this.data : this.data.slice(this.read);
          this.clear();
        }
        return rval;
      };
      util.DataBuffer.prototype.bytes = function(count) {
        return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
      };
      util.DataBuffer.prototype.at = function(i) {
        return this.data.getUint8(this.read + i);
      };
      util.DataBuffer.prototype.setAt = function(i, b) {
        this.data.setUint8(i, b);
        return this;
      };
      util.DataBuffer.prototype.last = function() {
        return this.data.getUint8(this.write - 1);
      };
      util.DataBuffer.prototype.copy = function() {
        return new util.DataBuffer(this);
      };
      util.DataBuffer.prototype.compact = function() {
        if (this.read > 0) {
          var src2 = new Uint8Array(this.data.buffer, this.read);
          var dst = new Uint8Array(src2.byteLength);
          dst.set(src2);
          this.data = new DataView(dst);
          this.write -= this.read;
          this.read = 0;
        }
        return this;
      };
      util.DataBuffer.prototype.clear = function() {
        this.data = new DataView(new ArrayBuffer(0));
        this.read = this.write = 0;
        return this;
      };
      util.DataBuffer.prototype.truncate = function(count) {
        this.write = Math.max(0, this.length() - count);
        this.read = Math.min(this.read, this.write);
        return this;
      };
      util.DataBuffer.prototype.toHex = function() {
        var rval = "";
        for (var i = this.read; i < this.data.byteLength; ++i) {
          var b = this.data.getUint8(i);
          if (b < 16) {
            rval += "0";
          }
          rval += b.toString(16);
        }
        return rval;
      };
      util.DataBuffer.prototype.toString = function(encoding) {
        var view = new Uint8Array(this.data, this.read, this.length());
        encoding = encoding || "utf8";
        if (encoding === "binary" || encoding === "raw") {
          return util.binary.raw.encode(view);
        }
        if (encoding === "hex") {
          return util.binary.hex.encode(view);
        }
        if (encoding === "base64") {
          return util.binary.base64.encode(view);
        }
        if (encoding === "utf8") {
          return util.text.utf8.decode(view);
        }
        if (encoding === "utf16") {
          return util.text.utf16.decode(view);
        }
        throw new Error("Invalid encoding: " + encoding);
      };
      util.createBuffer = function(input, encoding) {
        encoding = encoding || "raw";
        if (input !== void 0 && encoding === "utf8") {
          input = util.encodeUtf8(input);
        }
        return new util.ByteBuffer(input);
      };
      util.fillString = function(c, n) {
        var s = "";
        while (n > 0) {
          if (n & 1) {
            s += c;
          }
          n >>>= 1;
          if (n > 0) {
            c += c;
          }
        }
        return s;
      };
      util.xorBytes = function(s1, s2, n) {
        var s3 = "";
        var b = "";
        var t = "";
        var i = 0;
        var c = 0;
        for (; n > 0; --n, ++i) {
          b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
          if (c >= 10) {
            s3 += t;
            t = "";
            c = 0;
          }
          t += String.fromCharCode(b);
          ++c;
        }
        s3 += t;
        return s3;
      };
      util.hexToBytes = function(hex) {
        var rval = "";
        var i = 0;
        if (hex.length & true) {
          i = 1;
          rval += String.fromCharCode(parseInt(hex[0], 16));
        }
        for (; i < hex.length; i += 2) {
          rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
        }
        return rval;
      };
      util.bytesToHex = function(bytes) {
        return util.createBuffer(bytes).toHex();
      };
      util.int32ToBytes = function(i) {
        return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
      };
      var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var _base64Idx = [
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        64,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51
      ];
      var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      util.encode64 = function(input, maxline) {
        var line = "";
        var output = "";
        var chr1, chr2, chr3;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          line += _base64.charAt(chr1 >> 2);
          line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
          if (isNaN(chr2)) {
            line += "==";
          } else {
            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
            line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
          }
          if (maxline && line.length > maxline) {
            output += line.substr(0, maxline) + "\r\n";
            line = line.substr(maxline);
          }
        }
        output += line;
        return output;
      };
      util.decode64 = function(input) {
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        var output = "";
        var enc1, enc2, enc3, enc4;
        var i = 0;
        while (i < input.length) {
          enc1 = _base64Idx[input.charCodeAt(i++) - 43];
          enc2 = _base64Idx[input.charCodeAt(i++) - 43];
          enc3 = _base64Idx[input.charCodeAt(i++) - 43];
          enc4 = _base64Idx[input.charCodeAt(i++) - 43];
          output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
          if (enc3 !== 64) {
            output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
            if (enc4 !== 64) {
              output += String.fromCharCode((enc3 & 3) << 6 | enc4);
            }
          }
        }
        return output;
      };
      util.encodeUtf8 = function(str) {
        return unescape(encodeURIComponent(str));
      };
      util.decodeUtf8 = function(str) {
        return decodeURIComponent(escape(str));
      };
      util.binary = {
        raw: {},
        hex: {},
        base64: {},
        base58: {},
        baseN: {
          encode: baseN.encode,
          decode: baseN.decode
        }
      };
      util.binary.raw.encode = function(bytes) {
        return String.fromCharCode.apply(null, bytes);
      };
      util.binary.raw.decode = function(str, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length);
        }
        offset = offset || 0;
        var j = offset;
        for (var i = 0; i < str.length; ++i) {
          out[j++] = str.charCodeAt(i);
        }
        return output ? j - offset : out;
      };
      util.binary.hex.encode = util.bytesToHex;
      util.binary.hex.decode = function(hex, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(Math.ceil(hex.length / 2));
        }
        offset = offset || 0;
        var i = 0, j = offset;
        if (hex.length & 1) {
          i = 1;
          out[j++] = parseInt(hex[0], 16);
        }
        for (; i < hex.length; i += 2) {
          out[j++] = parseInt(hex.substr(i, 2), 16);
        }
        return output ? j - offset : out;
      };
      util.binary.base64.encode = function(input, maxline) {
        var line = "";
        var output = "";
        var chr1, chr2, chr3;
        var i = 0;
        while (i < input.byteLength) {
          chr1 = input[i++];
          chr2 = input[i++];
          chr3 = input[i++];
          line += _base64.charAt(chr1 >> 2);
          line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
          if (isNaN(chr2)) {
            line += "==";
          } else {
            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
            line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
          }
          if (maxline && line.length > maxline) {
            output += line.substr(0, maxline) + "\r\n";
            line = line.substr(maxline);
          }
        }
        output += line;
        return output;
      };
      util.binary.base64.decode = function(input, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(Math.ceil(input.length / 4) * 3);
        }
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        offset = offset || 0;
        var enc1, enc2, enc3, enc4;
        var i = 0, j = offset;
        while (i < input.length) {
          enc1 = _base64Idx[input.charCodeAt(i++) - 43];
          enc2 = _base64Idx[input.charCodeAt(i++) - 43];
          enc3 = _base64Idx[input.charCodeAt(i++) - 43];
          enc4 = _base64Idx[input.charCodeAt(i++) - 43];
          out[j++] = enc1 << 2 | enc2 >> 4;
          if (enc3 !== 64) {
            out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
            if (enc4 !== 64) {
              out[j++] = (enc3 & 3) << 6 | enc4;
            }
          }
        }
        return output ? j - offset : out.subarray(0, j);
      };
      util.binary.base58.encode = function(input, maxline) {
        return util.binary.baseN.encode(input, _base58, maxline);
      };
      util.binary.base58.decode = function(input, maxline) {
        return util.binary.baseN.decode(input, _base58, maxline);
      };
      util.text = {
        utf8: {},
        utf16: {}
      };
      util.text.utf8.encode = function(str, output, offset) {
        str = util.encodeUtf8(str);
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length);
        }
        offset = offset || 0;
        var j = offset;
        for (var i = 0; i < str.length; ++i) {
          out[j++] = str.charCodeAt(i);
        }
        return output ? j - offset : out;
      };
      util.text.utf8.decode = function(bytes) {
        return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
      };
      util.text.utf16.encode = function(str, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length * 2);
        }
        var view = new Uint16Array(out.buffer);
        offset = offset || 0;
        var j = offset;
        var k = offset;
        for (var i = 0; i < str.length; ++i) {
          view[k++] = str.charCodeAt(i);
          j += 2;
        }
        return output ? j - offset : out;
      };
      util.text.utf16.decode = function(bytes) {
        return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
      };
      util.deflate = function(api, bytes, raw) {
        bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
        if (raw) {
          var start = 2;
          var flg = bytes.charCodeAt(1);
          if (flg & 32) {
            start = 6;
          }
          bytes = bytes.substring(start, bytes.length - 4);
        }
        return bytes;
      };
      util.inflate = function(api, bytes, raw) {
        var rval = api.inflate(util.encode64(bytes)).rval;
        return rval === null ? null : util.decode64(rval);
      };
      var _setStorageObject = function(api, id, obj) {
        if (!api) {
          throw new Error("WebStorage not available.");
        }
        var rval;
        if (obj === null) {
          rval = api.removeItem(id);
        } else {
          obj = util.encode64(JSON.stringify(obj));
          rval = api.setItem(id, obj);
        }
        if (typeof rval !== "undefined" && rval.rval !== true) {
          var error = new Error(rval.error.message);
          error.id = rval.error.id;
          error.name = rval.error.name;
          throw error;
        }
      };
      var _getStorageObject = function(api, id) {
        if (!api) {
          throw new Error("WebStorage not available.");
        }
        var rval = api.getItem(id);
        if (api.init) {
          if (rval.rval === null) {
            if (rval.error) {
              var error = new Error(rval.error.message);
              error.id = rval.error.id;
              error.name = rval.error.name;
              throw error;
            }
            rval = null;
          } else {
            rval = rval.rval;
          }
        }
        if (rval !== null) {
          rval = JSON.parse(util.decode64(rval));
        }
        return rval;
      };
      var _setItem = function(api, id, key, data) {
        var obj = _getStorageObject(api, id);
        if (obj === null) {
          obj = {};
        }
        obj[key] = data;
        _setStorageObject(api, id, obj);
      };
      var _getItem = function(api, id, key) {
        var rval = _getStorageObject(api, id);
        if (rval !== null) {
          rval = key in rval ? rval[key] : null;
        }
        return rval;
      };
      var _removeItem = function(api, id, key) {
        var obj = _getStorageObject(api, id);
        if (obj !== null && key in obj) {
          delete obj[key];
          var empty2 = true;
          for (var prop in obj) {
            empty2 = false;
            break;
          }
          if (empty2) {
            obj = null;
          }
          _setStorageObject(api, id, obj);
        }
      };
      var _clearItems = function(api, id) {
        _setStorageObject(api, id, null);
      };
      var _callStorageFunction = function(func, args, location) {
        var rval = null;
        if (typeof location === "undefined") {
          location = ["web", "flash"];
        }
        var type;
        var done = false;
        var exception = null;
        for (var idx in location) {
          type = location[idx];
          try {
            if (type === "flash" || type === "both") {
              if (args[0] === null) {
                throw new Error("Flash local storage not available.");
              }
              rval = func.apply(this, args);
              done = type === "flash";
            }
            if (type === "web" || type === "both") {
              args[0] = localStorage;
              rval = func.apply(this, args);
              done = true;
            }
          } catch (ex) {
            exception = ex;
          }
          if (done) {
            break;
          }
        }
        if (!done) {
          throw exception;
        }
        return rval;
      };
      util.setItem = function(api, id, key, data, location) {
        _callStorageFunction(_setItem, arguments, location);
      };
      util.getItem = function(api, id, key, location) {
        return _callStorageFunction(_getItem, arguments, location);
      };
      util.removeItem = function(api, id, key, location) {
        _callStorageFunction(_removeItem, arguments, location);
      };
      util.clearItems = function(api, id, location) {
        _callStorageFunction(_clearItems, arguments, location);
      };
      util.parseUrl = function(str) {
        var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
        regex.lastIndex = 0;
        var m = regex.exec(str);
        var url = m === null ? null : {
          full: str,
          scheme: m[1],
          host: m[2],
          port: m[3],
          path: m[4]
        };
        if (url) {
          url.fullHost = url.host;
          if (url.port) {
            if (url.port !== 80 && url.scheme === "http") {
              url.fullHost += ":" + url.port;
            } else if (url.port !== 443 && url.scheme === "https") {
              url.fullHost += ":" + url.port;
            }
          } else if (url.scheme === "http") {
            url.port = 80;
          } else if (url.scheme === "https") {
            url.port = 443;
          }
          url.full = url.scheme + "://" + url.fullHost;
        }
        return url;
      };
      var _queryVariables = null;
      util.getQueryVariables = function(query) {
        var parse = function(q) {
          var rval2 = {};
          var kvpairs = q.split("&");
          for (var i = 0; i < kvpairs.length; i++) {
            var pos = kvpairs[i].indexOf("=");
            var key;
            var val;
            if (pos > 0) {
              key = kvpairs[i].substring(0, pos);
              val = kvpairs[i].substring(pos + 1);
            } else {
              key = kvpairs[i];
              val = null;
            }
            if (!(key in rval2)) {
              rval2[key] = [];
            }
            if (!(key in Object.prototype) && val !== null) {
              rval2[key].push(unescape(val));
            }
          }
          return rval2;
        };
        var rval;
        if (typeof query === "undefined") {
          if (_queryVariables === null) {
            if (typeof window !== "undefined" && window.location && window.location.search) {
              _queryVariables = parse(window.location.search.substring(1));
            } else {
              _queryVariables = {};
            }
          }
          rval = _queryVariables;
        } else {
          rval = parse(query);
        }
        return rval;
      };
      util.parseFragment = function(fragment) {
        var fp = fragment;
        var fq = "";
        var pos = fragment.indexOf("?");
        if (pos > 0) {
          fp = fragment.substring(0, pos);
          fq = fragment.substring(pos + 1);
        }
        var path = fp.split("/");
        if (path.length > 0 && path[0] === "") {
          path.shift();
        }
        var query = fq === "" ? {} : util.getQueryVariables(fq);
        return {
          pathString: fp,
          queryString: fq,
          path,
          query
        };
      };
      util.makeRequest = function(reqString) {
        var frag = util.parseFragment(reqString);
        var req = {
          path: frag.pathString,
          query: frag.queryString,
          getPath: function(i) {
            return typeof i === "undefined" ? frag.path : frag.path[i];
          },
          getQuery: function(k, i) {
            var rval;
            if (typeof k === "undefined") {
              rval = frag.query;
            } else {
              rval = frag.query[k];
              if (rval && typeof i !== "undefined") {
                rval = rval[i];
              }
            }
            return rval;
          },
          getQueryLast: function(k, _default) {
            var rval;
            var vals = req.getQuery(k);
            if (vals) {
              rval = vals[vals.length - 1];
            } else {
              rval = _default;
            }
            return rval;
          }
        };
        return req;
      };
      util.makeLink = function(path, query, fragment) {
        path = jQuery.isArray(path) ? path.join("/") : path;
        var qstr = jQuery.param(query || {});
        fragment = fragment || "";
        return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
      };
      util.isEmpty = function(obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            return false;
          }
        }
        return true;
      };
      util.format = function(format) {
        var re = /%./g;
        var match;
        var part;
        var argi = 0;
        var parts = [];
        var last = 0;
        while (match = re.exec(format)) {
          part = format.substring(last, re.lastIndex - 2);
          if (part.length > 0) {
            parts.push(part);
          }
          last = re.lastIndex;
          var code = match[0][1];
          switch (code) {
            case "s":
            case "o":
              if (argi < arguments.length) {
                parts.push(arguments[argi++ + 1]);
              } else {
                parts.push("<?>");
              }
              break;
            case "%":
              parts.push("%");
              break;
            default:
              parts.push("<%" + code + "?>");
          }
        }
        parts.push(format.substring(last));
        return parts.join("");
      };
      util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
        var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
        var d = dec_point === void 0 ? "," : dec_point;
        var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
        var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
        var j = i.length > 3 ? i.length % 3 : 0;
        return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
      };
      util.formatSize = function(size) {
        if (size >= 1073741824) {
          size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
        } else if (size >= 1048576) {
          size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
        } else if (size >= 1024) {
          size = util.formatNumber(size / 1024, 0) + " KiB";
        } else {
          size = util.formatNumber(size, 0) + " bytes";
        }
        return size;
      };
      util.bytesFromIP = function(ip) {
        if (ip.indexOf(".") !== -1) {
          return util.bytesFromIPv4(ip);
        }
        if (ip.indexOf(":") !== -1) {
          return util.bytesFromIPv6(ip);
        }
        return null;
      };
      util.bytesFromIPv4 = function(ip) {
        ip = ip.split(".");
        if (ip.length !== 4) {
          return null;
        }
        var b = util.createBuffer();
        for (var i = 0; i < ip.length; ++i) {
          var num = parseInt(ip[i], 10);
          if (isNaN(num)) {
            return null;
          }
          b.putByte(num);
        }
        return b.getBytes();
      };
      util.bytesFromIPv6 = function(ip) {
        var blanks = 0;
        ip = ip.split(":").filter(function(e) {
          if (e.length === 0)
            ++blanks;
          return true;
        });
        var zeros = (8 - ip.length + blanks) * 2;
        var b = util.createBuffer();
        for (var i = 0; i < 8; ++i) {
          if (!ip[i] || ip[i].length === 0) {
            b.fillWithByte(0, zeros);
            zeros = 0;
            continue;
          }
          var bytes = util.hexToBytes(ip[i]);
          if (bytes.length < 2) {
            b.putByte(0);
          }
          b.putBytes(bytes);
        }
        return b.getBytes();
      };
      util.bytesToIP = function(bytes) {
        if (bytes.length === 4) {
          return util.bytesToIPv4(bytes);
        }
        if (bytes.length === 16) {
          return util.bytesToIPv6(bytes);
        }
        return null;
      };
      util.bytesToIPv4 = function(bytes) {
        if (bytes.length !== 4) {
          return null;
        }
        var ip = [];
        for (var i = 0; i < bytes.length; ++i) {
          ip.push(bytes.charCodeAt(i));
        }
        return ip.join(".");
      };
      util.bytesToIPv6 = function(bytes) {
        if (bytes.length !== 16) {
          return null;
        }
        var ip = [];
        var zeroGroups = [];
        var zeroMaxGroup = 0;
        for (var i = 0; i < bytes.length; i += 2) {
          var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
          while (hex[0] === "0" && hex !== "0") {
            hex = hex.substr(1);
          }
          if (hex === "0") {
            var last = zeroGroups[zeroGroups.length - 1];
            var idx = ip.length;
            if (!last || idx !== last.end + 1) {
              zeroGroups.push({ start: idx, end: idx });
            } else {
              last.end = idx;
              if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
                zeroMaxGroup = zeroGroups.length - 1;
              }
            }
          }
          ip.push(hex);
        }
        if (zeroGroups.length > 0) {
          var group = zeroGroups[zeroMaxGroup];
          if (group.end - group.start > 0) {
            ip.splice(group.start, group.end - group.start + 1, "");
            if (group.start === 0) {
              ip.unshift("");
            }
            if (group.end === 7) {
              ip.push("");
            }
          }
        }
        return ip.join(":");
      };
      util.estimateCores = function(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        if ("cores" in util && !options.update) {
          return callback(null, util.cores);
        }
        if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
          util.cores = navigator.hardwareConcurrency;
          return callback(null, util.cores);
        }
        if (typeof Worker === "undefined") {
          util.cores = 1;
          return callback(null, util.cores);
        }
        if (typeof Blob === "undefined") {
          util.cores = 2;
          return callback(null, util.cores);
        }
        var blobUrl = URL.createObjectURL(new Blob([
          "(",
          function() {
            self.addEventListener("message", function(e) {
              var st = Date.now();
              var et = st + 4;
              while (Date.now() < et)
                ;
              self.postMessage({ st, et });
            });
          }.toString(),
          ")()"
        ], { type: "application/javascript" }));
        sample([], 5, 16);
        function sample(max, samples, numWorkers) {
          if (samples === 0) {
            var avg = Math.floor(max.reduce(function(avg2, x) {
              return avg2 + x;
            }, 0) / max.length);
            util.cores = Math.max(1, avg);
            URL.revokeObjectURL(blobUrl);
            return callback(null, util.cores);
          }
          map(numWorkers, function(err, results) {
            max.push(reduce(numWorkers, results));
            sample(max, samples - 1, numWorkers);
          });
        }
        function map(numWorkers, callback2) {
          var workers = [];
          var results = [];
          for (var i = 0; i < numWorkers; ++i) {
            var worker = new Worker(blobUrl);
            worker.addEventListener("message", function(e) {
              results.push(e.data);
              if (results.length === numWorkers) {
                for (var i2 = 0; i2 < numWorkers; ++i2) {
                  workers[i2].terminate();
                }
                callback2(null, results);
              }
            });
            workers.push(worker);
          }
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].postMessage(i);
          }
        }
        function reduce(numWorkers, results) {
          var overlaps = [];
          for (var n = 0; n < numWorkers; ++n) {
            var r1 = results[n];
            var overlap = overlaps[n] = [];
            for (var i = 0; i < numWorkers; ++i) {
              if (n === i) {
                continue;
              }
              var r2 = results[i];
              if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
                overlap.push(i);
              }
            }
          }
          return overlaps.reduce(function(max, overlap2) {
            return Math.max(max, overlap2.length);
          }, 0);
        }
      };
    }
  });

  // node_modules/node-forge/lib/oids.js
  var require_oids = __commonJS({
    "node_modules/node-forge/lib/oids.js"(exports2, module2) {
      var forge = require_forge();
      forge.pki = forge.pki || {};
      var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
      function _IN(id, name) {
        oids[id] = name;
        oids[name] = id;
      }
      function _I_(id, name) {
        oids[id] = name;
      }
      _IN("1.2.840.113549.1.1.1", "rsaEncryption");
      _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
      _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
      _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
      _IN("1.2.840.113549.1.1.8", "mgf1");
      _IN("1.2.840.113549.1.1.9", "pSpecified");
      _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
      _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
      _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
      _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
      _IN("1.3.101.112", "EdDSA25519");
      _IN("1.2.840.10040.4.3", "dsa-with-sha1");
      _IN("1.3.14.3.2.7", "desCBC");
      _IN("1.3.14.3.2.26", "sha1");
      _IN("2.16.840.1.101.3.4.2.1", "sha256");
      _IN("2.16.840.1.101.3.4.2.2", "sha384");
      _IN("2.16.840.1.101.3.4.2.3", "sha512");
      _IN("1.2.840.113549.2.5", "md5");
      _IN("1.2.840.113549.1.7.1", "data");
      _IN("1.2.840.113549.1.7.2", "signedData");
      _IN("1.2.840.113549.1.7.3", "envelopedData");
      _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
      _IN("1.2.840.113549.1.7.5", "digestedData");
      _IN("1.2.840.113549.1.7.6", "encryptedData");
      _IN("1.2.840.113549.1.9.1", "emailAddress");
      _IN("1.2.840.113549.1.9.2", "unstructuredName");
      _IN("1.2.840.113549.1.9.3", "contentType");
      _IN("1.2.840.113549.1.9.4", "messageDigest");
      _IN("1.2.840.113549.1.9.5", "signingTime");
      _IN("1.2.840.113549.1.9.6", "counterSignature");
      _IN("1.2.840.113549.1.9.7", "challengePassword");
      _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
      _IN("1.2.840.113549.1.9.14", "extensionRequest");
      _IN("1.2.840.113549.1.9.20", "friendlyName");
      _IN("1.2.840.113549.1.9.21", "localKeyId");
      _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
      _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
      _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
      _IN("1.2.840.113549.1.12.10.1.3", "certBag");
      _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
      _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
      _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
      _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
      _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
      _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
      _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
      _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
      _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
      _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
      _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
      _IN("1.2.840.113549.2.7", "hmacWithSHA1");
      _IN("1.2.840.113549.2.8", "hmacWithSHA224");
      _IN("1.2.840.113549.2.9", "hmacWithSHA256");
      _IN("1.2.840.113549.2.10", "hmacWithSHA384");
      _IN("1.2.840.113549.2.11", "hmacWithSHA512");
      _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
      _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
      _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
      _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
      _IN("2.5.4.3", "commonName");
      _IN("2.5.4.5", "serialName");
      _IN("2.5.4.6", "countryName");
      _IN("2.5.4.7", "localityName");
      _IN("2.5.4.8", "stateOrProvinceName");
      _IN("2.5.4.9", "streetAddress");
      _IN("2.5.4.10", "organizationName");
      _IN("2.5.4.11", "organizationalUnitName");
      _IN("2.5.4.13", "description");
      _IN("2.5.4.15", "businessCategory");
      _IN("2.5.4.17", "postalCode");
      _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
      _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
      _IN("2.16.840.1.113730.1.1", "nsCertType");
      _IN("2.16.840.1.113730.1.13", "nsComment");
      _I_("2.5.29.1", "authorityKeyIdentifier");
      _I_("2.5.29.2", "keyAttributes");
      _I_("2.5.29.3", "certificatePolicies");
      _I_("2.5.29.4", "keyUsageRestriction");
      _I_("2.5.29.5", "policyMapping");
      _I_("2.5.29.6", "subtreesConstraint");
      _I_("2.5.29.7", "subjectAltName");
      _I_("2.5.29.8", "issuerAltName");
      _I_("2.5.29.9", "subjectDirectoryAttributes");
      _I_("2.5.29.10", "basicConstraints");
      _I_("2.5.29.11", "nameConstraints");
      _I_("2.5.29.12", "policyConstraints");
      _I_("2.5.29.13", "basicConstraints");
      _IN("2.5.29.14", "subjectKeyIdentifier");
      _IN("2.5.29.15", "keyUsage");
      _I_("2.5.29.16", "privateKeyUsagePeriod");
      _IN("2.5.29.17", "subjectAltName");
      _IN("2.5.29.18", "issuerAltName");
      _IN("2.5.29.19", "basicConstraints");
      _I_("2.5.29.20", "cRLNumber");
      _I_("2.5.29.21", "cRLReason");
      _I_("2.5.29.22", "expirationDate");
      _I_("2.5.29.23", "instructionCode");
      _I_("2.5.29.24", "invalidityDate");
      _I_("2.5.29.25", "cRLDistributionPoints");
      _I_("2.5.29.26", "issuingDistributionPoint");
      _I_("2.5.29.27", "deltaCRLIndicator");
      _I_("2.5.29.28", "issuingDistributionPoint");
      _I_("2.5.29.29", "certificateIssuer");
      _I_("2.5.29.30", "nameConstraints");
      _IN("2.5.29.31", "cRLDistributionPoints");
      _IN("2.5.29.32", "certificatePolicies");
      _I_("2.5.29.33", "policyMappings");
      _I_("2.5.29.34", "policyConstraints");
      _IN("2.5.29.35", "authorityKeyIdentifier");
      _I_("2.5.29.36", "policyConstraints");
      _IN("2.5.29.37", "extKeyUsage");
      _I_("2.5.29.46", "freshestCRL");
      _I_("2.5.29.54", "inhibitAnyPolicy");
      _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
      _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
      _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
      _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
      _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
      _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
      _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
    }
  });

  // node_modules/node-forge/lib/asn1.js
  var require_asn1 = __commonJS({
    "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      require_oids();
      var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
      asn1.Class = {
        UNIVERSAL: 0,
        APPLICATION: 64,
        CONTEXT_SPECIFIC: 128,
        PRIVATE: 192
      };
      asn1.Type = {
        NONE: 0,
        BOOLEAN: 1,
        INTEGER: 2,
        BITSTRING: 3,
        OCTETSTRING: 4,
        NULL: 5,
        OID: 6,
        ODESC: 7,
        EXTERNAL: 8,
        REAL: 9,
        ENUMERATED: 10,
        EMBEDDED: 11,
        UTF8: 12,
        ROID: 13,
        SEQUENCE: 16,
        SET: 17,
        PRINTABLESTRING: 19,
        IA5STRING: 22,
        UTCTIME: 23,
        GENERALIZEDTIME: 24,
        BMPSTRING: 30
      };
      asn1.create = function(tagClass, type, constructed, value, options) {
        if (forge.util.isArray(value)) {
          var tmp = [];
          for (var i = 0; i < value.length; ++i) {
            if (value[i] !== void 0) {
              tmp.push(value[i]);
            }
          }
          value = tmp;
        }
        var obj = {
          tagClass,
          type,
          constructed,
          composed: constructed || forge.util.isArray(value),
          value
        };
        if (options && "bitStringContents" in options) {
          obj.bitStringContents = options.bitStringContents;
          obj.original = asn1.copy(obj);
        }
        return obj;
      };
      asn1.copy = function(obj, options) {
        var copy;
        if (forge.util.isArray(obj)) {
          copy = [];
          for (var i = 0; i < obj.length; ++i) {
            copy.push(asn1.copy(obj[i], options));
          }
          return copy;
        }
        if (typeof obj === "string") {
          return obj;
        }
        copy = {
          tagClass: obj.tagClass,
          type: obj.type,
          constructed: obj.constructed,
          composed: obj.composed,
          value: asn1.copy(obj.value, options)
        };
        if (options && !options.excludeBitStringContents) {
          copy.bitStringContents = obj.bitStringContents;
        }
        return copy;
      };
      asn1.equals = function(obj1, obj2, options) {
        if (forge.util.isArray(obj1)) {
          if (!forge.util.isArray(obj2)) {
            return false;
          }
          if (obj1.length !== obj2.length) {
            return false;
          }
          for (var i = 0; i < obj1.length; ++i) {
            if (!asn1.equals(obj1[i], obj2[i])) {
              return false;
            }
          }
          return true;
        }
        if (typeof obj1 !== typeof obj2) {
          return false;
        }
        if (typeof obj1 === "string") {
          return obj1 === obj2;
        }
        var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
        if (options && options.includeBitStringContents) {
          equal = equal && obj1.bitStringContents === obj2.bitStringContents;
        }
        return equal;
      };
      asn1.getBerValueLength = function(b) {
        var b2 = b.getByte();
        if (b2 === 128) {
          return void 0;
        }
        var length2;
        var longForm = b2 & 128;
        if (!longForm) {
          length2 = b2;
        } else {
          length2 = b.getInt((b2 & 127) << 3);
        }
        return length2;
      };
      function _checkBufferLength(bytes, remaining, n) {
        if (n > remaining) {
          var error = new Error("Too few bytes to parse DER.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = n;
          throw error;
        }
      }
      var _getValueLength = function(bytes, remaining) {
        var b2 = bytes.getByte();
        remaining--;
        if (b2 === 128) {
          return void 0;
        }
        var length2;
        var longForm = b2 & 128;
        if (!longForm) {
          length2 = b2;
        } else {
          var longFormBytes = b2 & 127;
          _checkBufferLength(bytes, remaining, longFormBytes);
          length2 = bytes.getInt(longFormBytes << 3);
        }
        if (length2 < 0) {
          throw new Error("Negative length: " + length2);
        }
        return length2;
      };
      asn1.fromDer = function(bytes, options) {
        if (options === void 0) {
          options = {
            strict: true,
            decodeBitStrings: true
          };
        }
        if (typeof options === "boolean") {
          options = {
            strict: options,
            decodeBitStrings: true
          };
        }
        if (!("strict" in options)) {
          options.strict = true;
        }
        if (!("decodeBitStrings" in options)) {
          options.decodeBitStrings = true;
        }
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        return _fromDer(bytes, bytes.length(), 0, options);
      };
      function _fromDer(bytes, remaining, depth, options) {
        var start;
        _checkBufferLength(bytes, remaining, 2);
        var b1 = bytes.getByte();
        remaining--;
        var tagClass = b1 & 192;
        var type = b1 & 31;
        start = bytes.length();
        var length2 = _getValueLength(bytes, remaining);
        remaining -= start - bytes.length();
        if (length2 !== void 0 && length2 > remaining) {
          if (options.strict) {
            var error = new Error("Too few bytes to read ASN.1 value.");
            error.available = bytes.length();
            error.remaining = remaining;
            error.requested = length2;
            throw error;
          }
          length2 = remaining;
        }
        var value;
        var bitStringContents;
        var constructed = (b1 & 32) === 32;
        if (constructed) {
          value = [];
          if (length2 === void 0) {
            for (; ; ) {
              _checkBufferLength(bytes, remaining, 2);
              if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                bytes.getBytes(2);
                remaining -= 2;
                break;
              }
              start = bytes.length();
              value.push(_fromDer(bytes, remaining, depth + 1, options));
              remaining -= start - bytes.length();
            }
          } else {
            while (length2 > 0) {
              start = bytes.length();
              value.push(_fromDer(bytes, length2, depth + 1, options));
              remaining -= start - bytes.length();
              length2 -= start - bytes.length();
            }
          }
        }
        if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
          bitStringContents = bytes.bytes(length2);
        }
        if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length2 > 1) {
          var savedRead = bytes.read;
          var savedRemaining = remaining;
          var unused = 0;
          if (type === asn1.Type.BITSTRING) {
            _checkBufferLength(bytes, remaining, 1);
            unused = bytes.getByte();
            remaining--;
          }
          if (unused === 0) {
            try {
              start = bytes.length();
              var subOptions = {
                verbose: options.verbose,
                strict: true,
                decodeBitStrings: true
              };
              var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
              var used = start - bytes.length();
              remaining -= used;
              if (type == asn1.Type.BITSTRING) {
                used++;
              }
              var tc = composed.tagClass;
              if (used === length2 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
                value = [composed];
              }
            } catch (ex) {
            }
          }
          if (value === void 0) {
            bytes.read = savedRead;
            remaining = savedRemaining;
          }
        }
        if (value === void 0) {
          if (length2 === void 0) {
            if (options.strict) {
              throw new Error("Non-constructed ASN.1 object of indefinite length.");
            }
            length2 = remaining;
          }
          if (type === asn1.Type.BMPSTRING) {
            value = "";
            for (; length2 > 0; length2 -= 2) {
              _checkBufferLength(bytes, remaining, 2);
              value += String.fromCharCode(bytes.getInt16());
              remaining -= 2;
            }
          } else {
            value = bytes.getBytes(length2);
          }
        }
        var asn1Options = bitStringContents === void 0 ? null : {
          bitStringContents
        };
        return asn1.create(tagClass, type, constructed, value, asn1Options);
      }
      asn1.toDer = function(obj) {
        var bytes = forge.util.createBuffer();
        var b1 = obj.tagClass | obj.type;
        var value = forge.util.createBuffer();
        var useBitStringContents = false;
        if ("bitStringContents" in obj) {
          useBitStringContents = true;
          if (obj.original) {
            useBitStringContents = asn1.equals(obj, obj.original);
          }
        }
        if (useBitStringContents) {
          value.putBytes(obj.bitStringContents);
        } else if (obj.composed) {
          if (obj.constructed) {
            b1 |= 32;
          } else {
            value.putByte(0);
          }
          for (var i = 0; i < obj.value.length; ++i) {
            if (obj.value[i] !== void 0) {
              value.putBuffer(asn1.toDer(obj.value[i]));
            }
          }
        } else {
          if (obj.type === asn1.Type.BMPSTRING) {
            for (var i = 0; i < obj.value.length; ++i) {
              value.putInt16(obj.value.charCodeAt(i));
            }
          } else {
            if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
              value.putBytes(obj.value.substr(1));
            } else {
              value.putBytes(obj.value);
            }
          }
        }
        bytes.putByte(b1);
        if (value.length() <= 127) {
          bytes.putByte(value.length() & 127);
        } else {
          var len = value.length();
          var lenBytes = "";
          do {
            lenBytes += String.fromCharCode(len & 255);
            len = len >>> 8;
          } while (len > 0);
          bytes.putByte(lenBytes.length | 128);
          for (var i = lenBytes.length - 1; i >= 0; --i) {
            bytes.putByte(lenBytes.charCodeAt(i));
          }
        }
        bytes.putBuffer(value);
        return bytes;
      };
      asn1.oidToDer = function(oid) {
        var values = oid.split(".");
        var bytes = forge.util.createBuffer();
        bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
        var last, valueBytes, value, b;
        for (var i = 2; i < values.length; ++i) {
          last = true;
          valueBytes = [];
          value = parseInt(values[i], 10);
          do {
            b = value & 127;
            value = value >>> 7;
            if (!last) {
              b |= 128;
            }
            valueBytes.push(b);
            last = false;
          } while (value > 0);
          for (var n = valueBytes.length - 1; n >= 0; --n) {
            bytes.putByte(valueBytes[n]);
          }
        }
        return bytes;
      };
      asn1.derToOid = function(bytes) {
        var oid;
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        var b = bytes.getByte();
        oid = Math.floor(b / 40) + "." + b % 40;
        var value = 0;
        while (bytes.length() > 0) {
          b = bytes.getByte();
          value = value << 7;
          if (b & 128) {
            value += b & 127;
          } else {
            oid += "." + (value + b);
            value = 0;
          }
        }
        return oid;
      };
      asn1.utcTimeToDate = function(utc) {
        var date = new Date();
        var year = parseInt(utc.substr(0, 2), 10);
        year = year >= 50 ? 1900 + year : 2e3 + year;
        var MM = parseInt(utc.substr(2, 2), 10) - 1;
        var DD = parseInt(utc.substr(4, 2), 10);
        var hh = parseInt(utc.substr(6, 2), 10);
        var mm = parseInt(utc.substr(8, 2), 10);
        var ss = 0;
        if (utc.length > 11) {
          var c = utc.charAt(10);
          var end = 10;
          if (c !== "+" && c !== "-") {
            ss = parseInt(utc.substr(10, 2), 10);
            end += 2;
          }
        }
        date.setUTCFullYear(year, MM, DD);
        date.setUTCHours(hh, mm, ss, 0);
        if (end) {
          c = utc.charAt(end);
          if (c === "+" || c === "-") {
            var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
            var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
            var offset = hhoffset * 60 + mmoffset;
            offset *= 6e4;
            if (c === "+") {
              date.setTime(+date - offset);
            } else {
              date.setTime(+date + offset);
            }
          }
        }
        return date;
      };
      asn1.generalizedTimeToDate = function(gentime) {
        var date = new Date();
        var YYYY = parseInt(gentime.substr(0, 4), 10);
        var MM = parseInt(gentime.substr(4, 2), 10) - 1;
        var DD = parseInt(gentime.substr(6, 2), 10);
        var hh = parseInt(gentime.substr(8, 2), 10);
        var mm = parseInt(gentime.substr(10, 2), 10);
        var ss = parseInt(gentime.substr(12, 2), 10);
        var fff = 0;
        var offset = 0;
        var isUTC = false;
        if (gentime.charAt(gentime.length - 1) === "Z") {
          isUTC = true;
        }
        var end = gentime.length - 5, c = gentime.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
          var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
          offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            offset *= -1;
          }
          isUTC = true;
        }
        if (gentime.charAt(14) === ".") {
          fff = parseFloat(gentime.substr(14), 10) * 1e3;
        }
        if (isUTC) {
          date.setUTCFullYear(YYYY, MM, DD);
          date.setUTCHours(hh, mm, ss, fff);
          date.setTime(+date + offset);
        } else {
          date.setFullYear(YYYY, MM, DD);
          date.setHours(hh, mm, ss, fff);
        }
        return date;
      };
      asn1.dateToUtcTime = function(date) {
        if (typeof date === "string") {
          return date;
        }
        var rval = "";
        var format = [];
        format.push(("" + date.getUTCFullYear()).substr(2));
        format.push("" + (date.getUTCMonth() + 1));
        format.push("" + date.getUTCDate());
        format.push("" + date.getUTCHours());
        format.push("" + date.getUTCMinutes());
        format.push("" + date.getUTCSeconds());
        for (var i = 0; i < format.length; ++i) {
          if (format[i].length < 2) {
            rval += "0";
          }
          rval += format[i];
        }
        rval += "Z";
        return rval;
      };
      asn1.dateToGeneralizedTime = function(date) {
        if (typeof date === "string") {
          return date;
        }
        var rval = "";
        var format = [];
        format.push("" + date.getUTCFullYear());
        format.push("" + (date.getUTCMonth() + 1));
        format.push("" + date.getUTCDate());
        format.push("" + date.getUTCHours());
        format.push("" + date.getUTCMinutes());
        format.push("" + date.getUTCSeconds());
        for (var i = 0; i < format.length; ++i) {
          if (format[i].length < 2) {
            rval += "0";
          }
          rval += format[i];
        }
        rval += "Z";
        return rval;
      };
      asn1.integerToDer = function(x) {
        var rval = forge.util.createBuffer();
        if (x >= -128 && x < 128) {
          return rval.putSignedInt(x, 8);
        }
        if (x >= -32768 && x < 32768) {
          return rval.putSignedInt(x, 16);
        }
        if (x >= -8388608 && x < 8388608) {
          return rval.putSignedInt(x, 24);
        }
        if (x >= -2147483648 && x < 2147483648) {
          return rval.putSignedInt(x, 32);
        }
        var error = new Error("Integer too large; max is 32-bits.");
        error.integer = x;
        throw error;
      };
      asn1.derToInteger = function(bytes) {
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        var n = bytes.length() * 8;
        if (n > 32) {
          throw new Error("Integer too large; max is 32-bits.");
        }
        return bytes.getSignedInt(n);
      };
      asn1.validate = function(obj, v, capture, errors) {
        var rval = false;
        if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
          if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
            rval = true;
            if (v.value && forge.util.isArray(v.value)) {
              var j = 0;
              for (var i = 0; rval && i < v.value.length; ++i) {
                rval = v.value[i].optional || false;
                if (obj.value[j]) {
                  rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                  if (rval) {
                    ++j;
                  } else if (v.value[i].optional) {
                    rval = true;
                  }
                }
                if (!rval && errors) {
                  errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
                }
              }
            }
            if (rval && capture) {
              if (v.capture) {
                capture[v.capture] = obj.value;
              }
              if (v.captureAsn1) {
                capture[v.captureAsn1] = obj;
              }
              if (v.captureBitStringContents && "bitStringContents" in obj) {
                capture[v.captureBitStringContents] = obj.bitStringContents;
              }
              if (v.captureBitStringValue && "bitStringContents" in obj) {
                var value;
                if (obj.bitStringContents.length < 2) {
                  capture[v.captureBitStringValue] = "";
                } else {
                  var unused = obj.bitStringContents.charCodeAt(0);
                  if (unused !== 0) {
                    throw new Error("captureBitStringValue only supported for zero unused bits");
                  }
                  capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
                }
              }
            }
          } else if (errors) {
            errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
          }
        } else if (errors) {
          if (obj.tagClass !== v.tagClass) {
            errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
          }
          if (obj.type !== v.type) {
            errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
          }
        }
        return rval;
      };
      var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
      asn1.prettyPrint = function(obj, level, indentation) {
        var rval = "";
        level = level || 0;
        indentation = indentation || 2;
        if (level > 0) {
          rval += "\n";
        }
        var indent = "";
        for (var i = 0; i < level * indentation; ++i) {
          indent += " ";
        }
        rval += indent + "Tag: ";
        switch (obj.tagClass) {
          case asn1.Class.UNIVERSAL:
            rval += "Universal:";
            break;
          case asn1.Class.APPLICATION:
            rval += "Application:";
            break;
          case asn1.Class.CONTEXT_SPECIFIC:
            rval += "Context-Specific:";
            break;
          case asn1.Class.PRIVATE:
            rval += "Private:";
            break;
        }
        if (obj.tagClass === asn1.Class.UNIVERSAL) {
          rval += obj.type;
          switch (obj.type) {
            case asn1.Type.NONE:
              rval += " (None)";
              break;
            case asn1.Type.BOOLEAN:
              rval += " (Boolean)";
              break;
            case asn1.Type.INTEGER:
              rval += " (Integer)";
              break;
            case asn1.Type.BITSTRING:
              rval += " (Bit string)";
              break;
            case asn1.Type.OCTETSTRING:
              rval += " (Octet string)";
              break;
            case asn1.Type.NULL:
              rval += " (Null)";
              break;
            case asn1.Type.OID:
              rval += " (Object Identifier)";
              break;
            case asn1.Type.ODESC:
              rval += " (Object Descriptor)";
              break;
            case asn1.Type.EXTERNAL:
              rval += " (External or Instance of)";
              break;
            case asn1.Type.REAL:
              rval += " (Real)";
              break;
            case asn1.Type.ENUMERATED:
              rval += " (Enumerated)";
              break;
            case asn1.Type.EMBEDDED:
              rval += " (Embedded PDV)";
              break;
            case asn1.Type.UTF8:
              rval += " (UTF8)";
              break;
            case asn1.Type.ROID:
              rval += " (Relative Object Identifier)";
              break;
            case asn1.Type.SEQUENCE:
              rval += " (Sequence)";
              break;
            case asn1.Type.SET:
              rval += " (Set)";
              break;
            case asn1.Type.PRINTABLESTRING:
              rval += " (Printable String)";
              break;
            case asn1.Type.IA5String:
              rval += " (IA5String (ASCII))";
              break;
            case asn1.Type.UTCTIME:
              rval += " (UTC time)";
              break;
            case asn1.Type.GENERALIZEDTIME:
              rval += " (Generalized time)";
              break;
            case asn1.Type.BMPSTRING:
              rval += " (BMP String)";
              break;
          }
        } else {
          rval += obj.type;
        }
        rval += "\n";
        rval += indent + "Constructed: " + obj.constructed + "\n";
        if (obj.composed) {
          var subvalues = 0;
          var sub = "";
          for (var i = 0; i < obj.value.length; ++i) {
            if (obj.value[i] !== void 0) {
              subvalues += 1;
              sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
              if (i + 1 < obj.value.length) {
                sub += ",";
              }
            }
          }
          rval += indent + "Sub values: " + subvalues + sub;
        } else {
          rval += indent + "Value: ";
          if (obj.type === asn1.Type.OID) {
            var oid = asn1.derToOid(obj.value);
            rval += oid;
            if (forge.pki && forge.pki.oids) {
              if (oid in forge.pki.oids) {
                rval += " (" + forge.pki.oids[oid] + ") ";
              }
            }
          }
          if (obj.type === asn1.Type.INTEGER) {
            try {
              rval += asn1.derToInteger(obj.value);
            } catch (ex) {
              rval += "0x" + forge.util.bytesToHex(obj.value);
            }
          } else if (obj.type === asn1.Type.BITSTRING) {
            if (obj.value.length > 1) {
              rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
            } else {
              rval += "(none)";
            }
            if (obj.value.length > 0) {
              var unused = obj.value.charCodeAt(0);
              if (unused == 1) {
                rval += " (1 unused bit shown)";
              } else if (unused > 1) {
                rval += " (" + unused + " unused bits shown)";
              }
            }
          } else if (obj.type === asn1.Type.OCTETSTRING) {
            if (!_nonLatinRegex.test(obj.value)) {
              rval += "(" + obj.value + ") ";
            }
            rval += "0x" + forge.util.bytesToHex(obj.value);
          } else if (obj.type === asn1.Type.UTF8) {
            rval += forge.util.decodeUtf8(obj.value);
          } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
            rval += obj.value;
          } else if (_nonLatinRegex.test(obj.value)) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          } else if (obj.value.length === 0) {
            rval += "[null]";
          } else {
            rval += obj.value;
          }
        }
        return rval;
      };
    }
  });

  // node_modules/node-forge/lib/cipher.js
  var require_cipher = __commonJS({
    "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      module2.exports = forge.cipher = forge.cipher || {};
      forge.cipher.algorithms = forge.cipher.algorithms || {};
      forge.cipher.createCipher = function(algorithm, key) {
        var api = algorithm;
        if (typeof api === "string") {
          api = forge.cipher.getAlgorithm(api);
          if (api) {
            api = api();
          }
        }
        if (!api) {
          throw new Error("Unsupported algorithm: " + algorithm);
        }
        return new forge.cipher.BlockCipher({
          algorithm: api,
          key,
          decrypt: false
        });
      };
      forge.cipher.createDecipher = function(algorithm, key) {
        var api = algorithm;
        if (typeof api === "string") {
          api = forge.cipher.getAlgorithm(api);
          if (api) {
            api = api();
          }
        }
        if (!api) {
          throw new Error("Unsupported algorithm: " + algorithm);
        }
        return new forge.cipher.BlockCipher({
          algorithm: api,
          key,
          decrypt: true
        });
      };
      forge.cipher.registerAlgorithm = function(name, algorithm) {
        name = name.toUpperCase();
        forge.cipher.algorithms[name] = algorithm;
      };
      forge.cipher.getAlgorithm = function(name) {
        name = name.toUpperCase();
        if (name in forge.cipher.algorithms) {
          return forge.cipher.algorithms[name];
        }
        return null;
      };
      var BlockCipher = forge.cipher.BlockCipher = function(options) {
        this.algorithm = options.algorithm;
        this.mode = this.algorithm.mode;
        this.blockSize = this.mode.blockSize;
        this._finish = false;
        this._input = null;
        this.output = null;
        this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
        this._decrypt = options.decrypt;
        this.algorithm.initialize(options);
      };
      BlockCipher.prototype.start = function(options) {
        options = options || {};
        var opts = {};
        for (var key in options) {
          opts[key] = options[key];
        }
        opts.decrypt = this._decrypt;
        this._finish = false;
        this._input = forge.util.createBuffer();
        this.output = options.output || forge.util.createBuffer();
        this.mode.start(opts);
      };
      BlockCipher.prototype.update = function(input) {
        if (input) {
          this._input.putBuffer(input);
        }
        while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
        }
        this._input.compact();
      };
      BlockCipher.prototype.finish = function(pad) {
        if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
          this.mode.pad = function(input) {
            return pad(this.blockSize, input, false);
          };
          this.mode.unpad = function(output) {
            return pad(this.blockSize, output, true);
          };
        }
        var options = {};
        options.decrypt = this._decrypt;
        options.overflow = this._input.length() % this.blockSize;
        if (!this._decrypt && this.mode.pad) {
          if (!this.mode.pad(this._input, options)) {
            return false;
          }
        }
        this._finish = true;
        this.update();
        if (this._decrypt && this.mode.unpad) {
          if (!this.mode.unpad(this.output, options)) {
            return false;
          }
        }
        if (this.mode.afterFinish) {
          if (!this.mode.afterFinish(this.output, options)) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/node-forge/lib/cipherModes.js
  var require_cipherModes = __commonJS({
    "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      forge.cipher = forge.cipher || {};
      var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
      modes.ecb = function(options) {
        options = options || {};
        this.name = "ECB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
      };
      modes.ecb.prototype.start = function(options) {
      };
      modes.ecb.prototype.encrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
      };
      modes.ecb.prototype.decrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
      };
      modes.ecb.prototype.pad = function(input, options) {
        var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
        input.fillWithByte(padding, padding);
        return true;
      };
      modes.ecb.prototype.unpad = function(output, options) {
        if (options.overflow > 0) {
          return false;
        }
        var len = output.length();
        var count = output.at(len - 1);
        if (count > this.blockSize << 2) {
          return false;
        }
        output.truncate(count);
        return true;
      };
      modes.cbc = function(options) {
        options = options || {};
        this.name = "CBC";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
      };
      modes.cbc.prototype.start = function(options) {
        if (options.iv === null) {
          if (!this._prev) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = this._prev.slice(0);
        } else if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        } else {
          this._iv = transformIV(options.iv, this.blockSize);
          this._prev = this._iv.slice(0);
        }
      };
      modes.cbc.prototype.encrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._prev[i] ^ input.getInt32();
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
        this._prev = this._outBlock;
      };
      modes.cbc.prototype.decrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._prev[i] ^ this._outBlock[i]);
        }
        this._prev = this._inBlock.slice(0);
      };
      modes.cbc.prototype.pad = function(input, options) {
        var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
        input.fillWithByte(padding, padding);
        return true;
      };
      modes.cbc.prototype.unpad = function(output, options) {
        if (options.overflow > 0) {
          return false;
        }
        var len = output.length();
        var count = output.at(len - 1);
        if (count > this.blockSize << 2) {
          return false;
        }
        output.truncate(count);
        return true;
      };
      modes.cfb = function(options) {
        options = options || {};
        this.name = "CFB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.cfb.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.cfb.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
            output.putInt32(this._inBlock[i]);
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
          this._partialOutput.putInt32(this._partialBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._partialBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.cfb.prototype.decrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
            output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialBlock[i] = input.getInt32();
          this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._partialBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.ofb = function(options) {
        options = options || {};
        this.name = "OFB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.ofb.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.ofb.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (input.length() === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(input.getInt32() ^ this._outBlock[i]);
            this._inBlock[i] = this._outBlock[i];
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._outBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
      modes.ctr = function(options) {
        options = options || {};
        this.name = "CTR";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.ctr.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.ctr.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
        } else {
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
          this._partialBytes = 0;
        }
        inc32(this._inBlock);
      };
      modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
      modes.gcm = function(options) {
        options = options || {};
        this.name = "GCM";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
        this._R = 3774873600;
      };
      modes.gcm.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        var iv = forge.util.createBuffer(options.iv);
        this._cipherLength = 0;
        var additionalData;
        if ("additionalData" in options) {
          additionalData = forge.util.createBuffer(options.additionalData);
        } else {
          additionalData = forge.util.createBuffer();
        }
        if ("tagLength" in options) {
          this._tagLength = options.tagLength;
        } else {
          this._tagLength = 128;
        }
        this._tag = null;
        if (options.decrypt) {
          this._tag = forge.util.createBuffer(options.tag).getBytes();
          if (this._tag.length !== this._tagLength / 8) {
            throw new Error("Authentication tag does not match tag length.");
          }
        }
        this._hashBlock = new Array(this._ints);
        this.tag = null;
        this._hashSubkey = new Array(this._ints);
        this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
        this.componentBits = 4;
        this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
        var ivLength = iv.length();
        if (ivLength === 12) {
          this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
        } else {
          this._j0 = [0, 0, 0, 0];
          while (iv.length() > 0) {
            this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
          }
          this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
        }
        this._inBlock = this._j0.slice(0);
        inc32(this._inBlock);
        this._partialBytes = 0;
        additionalData = forge.util.createBuffer(additionalData);
        this._aDataLength = from64To32(additionalData.length() * 8);
        var overflow = additionalData.length() % this.blockSize;
        if (overflow) {
          additionalData.fillWithByte(0, this.blockSize - overflow);
        }
        this._s = [0, 0, 0, 0];
        while (additionalData.length() > 0) {
          this._s = this.ghash(this._hashSubkey, this._s, [
            additionalData.getInt32(),
            additionalData.getInt32(),
            additionalData.getInt32(),
            additionalData.getInt32()
          ]);
        }
      };
      modes.gcm.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i] ^= input.getInt32());
          }
          this._cipherLength += this.blockSize;
        } else {
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes <= 0 || finish) {
            if (finish) {
              var overflow = inputLength % this.blockSize;
              this._cipherLength += overflow;
              this._partialOutput.truncate(this.blockSize - overflow);
            } else {
              this._cipherLength += this.blockSize;
            }
            for (var i = 0; i < this._ints; ++i) {
              this._outBlock[i] = this._partialOutput.getInt32();
            }
            this._partialOutput.read -= this.blockSize;
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            input.read -= this.blockSize;
            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
          this._partialBytes = 0;
        }
        this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
        inc32(this._inBlock);
      };
      modes.gcm.prototype.decrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        inc32(this._inBlock);
        this._hashBlock[0] = input.getInt32();
        this._hashBlock[1] = input.getInt32();
        this._hashBlock[2] = input.getInt32();
        this._hashBlock[3] = input.getInt32();
        this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
        }
        if (inputLength < this.blockSize) {
          this._cipherLength += inputLength % this.blockSize;
        } else {
          this._cipherLength += this.blockSize;
        }
      };
      modes.gcm.prototype.afterFinish = function(output, options) {
        var rval = true;
        if (options.decrypt && options.overflow) {
          output.truncate(this.blockSize - options.overflow);
        }
        this.tag = forge.util.createBuffer();
        var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
        this._s = this.ghash(this._hashSubkey, this._s, lengths);
        var tag = [];
        this.cipher.encrypt(this._j0, tag);
        for (var i = 0; i < this._ints; ++i) {
          this.tag.putInt32(this._s[i] ^ tag[i]);
        }
        this.tag.truncate(this.tag.length() % (this._tagLength / 8));
        if (options.decrypt && this.tag.bytes() !== this._tag) {
          rval = false;
        }
        return rval;
      };
      modes.gcm.prototype.multiply = function(x, y) {
        var z_i = [0, 0, 0, 0];
        var v_i = y.slice(0);
        for (var i = 0; i < 128; ++i) {
          var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
          if (x_i) {
            z_i[0] ^= v_i[0];
            z_i[1] ^= v_i[1];
            z_i[2] ^= v_i[2];
            z_i[3] ^= v_i[3];
          }
          this.pow(v_i, v_i);
        }
        return z_i;
      };
      modes.gcm.prototype.pow = function(x, out) {
        var lsb = x[3] & 1;
        for (var i = 3; i > 0; --i) {
          out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
        }
        out[0] = x[0] >>> 1;
        if (lsb) {
          out[0] ^= this._R;
        }
      };
      modes.gcm.prototype.tableMultiply = function(x) {
        var z = [0, 0, 0, 0];
        for (var i = 0; i < 32; ++i) {
          var idx = i / 8 | 0;
          var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
          var ah = this._m[i][x_i];
          z[0] ^= ah[0];
          z[1] ^= ah[1];
          z[2] ^= ah[2];
          z[3] ^= ah[3];
        }
        return z;
      };
      modes.gcm.prototype.ghash = function(h, y, x) {
        y[0] ^= x[0];
        y[1] ^= x[1];
        y[2] ^= x[2];
        y[3] ^= x[3];
        return this.tableMultiply(y);
      };
      modes.gcm.prototype.generateHashTable = function(h, bits) {
        var multiplier = 8 / bits;
        var perInt = 4 * multiplier;
        var size = 16 * multiplier;
        var m = new Array(size);
        for (var i = 0; i < size; ++i) {
          var tmp = [0, 0, 0, 0];
          var idx = i / perInt | 0;
          var shft = (perInt - 1 - i % perInt) * bits;
          tmp[idx] = 1 << bits - 1 << shft;
          m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
        }
        return m;
      };
      modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
        var size = 1 << bits;
        var half = size >>> 1;
        var m = new Array(size);
        m[half] = mid.slice(0);
        var i = half >>> 1;
        while (i > 0) {
          this.pow(m[2 * i], m[i] = []);
          i >>= 1;
        }
        i = 2;
        while (i < half) {
          for (var j = 1; j < i; ++j) {
            var m_i = m[i];
            var m_j = m[j];
            m[i + j] = [
              m_i[0] ^ m_j[0],
              m_i[1] ^ m_j[1],
              m_i[2] ^ m_j[2],
              m_i[3] ^ m_j[3]
            ];
          }
          i *= 2;
        }
        m[0] = [0, 0, 0, 0];
        for (i = half + 1; i < size; ++i) {
          var c = m[i ^ half];
          m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
        }
        return m;
      };
      function transformIV(iv, blockSize) {
        if (typeof iv === "string") {
          iv = forge.util.createBuffer(iv);
        }
        if (forge.util.isArray(iv) && iv.length > 4) {
          var tmp = iv;
          iv = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            iv.putByte(tmp[i]);
          }
        }
        if (iv.length() < blockSize) {
          throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
        }
        if (!forge.util.isArray(iv)) {
          var ints = [];
          var blocks = blockSize / 4;
          for (var i = 0; i < blocks; ++i) {
            ints.push(iv.getInt32());
          }
          iv = ints;
        }
        return iv;
      }
      function inc32(block) {
        block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
      }
      function from64To32(num) {
        return [num / 4294967296 | 0, num & 4294967295];
      }
    }
  });

  // node_modules/node-forge/lib/aes.js
  var require_aes = __commonJS({
    "node_modules/node-forge/lib/aes.js"(exports2, module2) {
      var forge = require_forge();
      require_cipher();
      require_cipherModes();
      require_util();
      module2.exports = forge.aes = forge.aes || {};
      forge.aes.startEncrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: false,
          mode
        });
        cipher.start(iv);
        return cipher;
      };
      forge.aes.createEncryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: false,
          mode
        });
      };
      forge.aes.startDecrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: true,
          mode
        });
        cipher.start(iv);
        return cipher;
      };
      forge.aes.createDecryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: true,
          mode
        });
      };
      forge.aes.Algorithm = function(name, mode) {
        if (!init) {
          initialize();
        }
        var self2 = this;
        self2.name = name;
        self2.mode = new mode({
          blockSize: 16,
          cipher: {
            encrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._w, inBlock, outBlock, false);
            },
            decrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._w, inBlock, outBlock, true);
            }
          }
        });
        self2._init = false;
      };
      forge.aes.Algorithm.prototype.initialize = function(options) {
        if (this._init) {
          return;
        }
        var key = options.key;
        var tmp;
        if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
          key = forge.util.createBuffer(key);
        } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
          tmp = key;
          key = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            key.putByte(tmp[i]);
          }
        }
        if (!forge.util.isArray(key)) {
          tmp = key;
          key = [];
          var len = tmp.length();
          if (len === 16 || len === 24 || len === 32) {
            len = len >>> 2;
            for (var i = 0; i < len; ++i) {
              key.push(tmp.getInt32());
            }
          }
        }
        if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
          throw new Error("Invalid key parameter.");
        }
        var mode = this.mode.name;
        var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
        this._w = _expandKey(key, options.decrypt && !encryptOp);
        this._init = true;
      };
      forge.aes._expandKey = function(key, decrypt) {
        if (!init) {
          initialize();
        }
        return _expandKey(key, decrypt);
      };
      forge.aes._updateBlock = _updateBlock;
      registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
      registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
      function registerAlgorithm(name, mode) {
        var factory = function() {
          return new forge.aes.Algorithm(name, mode);
        };
        forge.cipher.registerAlgorithm(name, factory);
      }
      var init = false;
      var Nb = 4;
      var sbox;
      var isbox;
      var rcon;
      var mix;
      var imix;
      function initialize() {
        init = true;
        rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var xtime = new Array(256);
        for (var i = 0; i < 128; ++i) {
          xtime[i] = i << 1;
          xtime[i + 128] = i + 128 << 1 ^ 283;
        }
        sbox = new Array(256);
        isbox = new Array(256);
        mix = new Array(4);
        imix = new Array(4);
        for (var i = 0; i < 4; ++i) {
          mix[i] = new Array(256);
          imix[i] = new Array(256);
        }
        var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
        for (var i = 0; i < 256; ++i) {
          sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
          sx = sx >> 8 ^ sx & 255 ^ 99;
          sbox[e] = sx;
          isbox[sx] = e;
          sx2 = xtime[sx];
          e2 = xtime[e];
          e4 = xtime[e2];
          e8 = xtime[e4];
          me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
          ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
          for (var n = 0; n < 4; ++n) {
            mix[n][e] = me;
            imix[n][sx] = ime;
            me = me << 24 | me >>> 8;
            ime = ime << 24 | ime >>> 8;
          }
          if (e === 0) {
            e = ei = 1;
          } else {
            e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
            ei ^= xtime[xtime[ei]];
          }
        }
      }
      function _expandKey(key, decrypt) {
        var w = key.slice(0);
        var temp, iNk = 1;
        var Nk = w.length;
        var Nr1 = Nk + 6 + 1;
        var end = Nb * Nr1;
        for (var i = Nk; i < end; ++i) {
          temp = w[i - 1];
          if (i % Nk === 0) {
            temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
            iNk++;
          } else if (Nk > 6 && i % Nk === 4) {
            temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
          }
          w[i] = w[i - Nk] ^ temp;
        }
        if (decrypt) {
          var tmp;
          var m0 = imix[0];
          var m1 = imix[1];
          var m2 = imix[2];
          var m3 = imix[3];
          var wnew = w.slice(0);
          end = w.length;
          for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
            if (i === 0 || i === end - Nb) {
              wnew[i] = w[wi];
              wnew[i + 1] = w[wi + 3];
              wnew[i + 2] = w[wi + 2];
              wnew[i + 3] = w[wi + 1];
            } else {
              for (var n = 0; n < Nb; ++n) {
                tmp = w[wi + n];
                wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
              }
            }
          }
          w = wnew;
        }
        return w;
      }
      function _updateBlock(w, input, output, decrypt) {
        var Nr = w.length / 4 - 1;
        var m0, m1, m2, m3, sub;
        if (decrypt) {
          m0 = imix[0];
          m1 = imix[1];
          m2 = imix[2];
          m3 = imix[3];
          sub = isbox;
        } else {
          m0 = mix[0];
          m1 = mix[1];
          m2 = mix[2];
          m3 = mix[3];
          sub = sbox;
        }
        var a, b, c, d, a2, b2, c2;
        a = input[0] ^ w[0];
        b = input[decrypt ? 3 : 1] ^ w[1];
        c = input[2] ^ w[2];
        d = input[decrypt ? 1 : 3] ^ w[3];
        var i = 3;
        for (var round = 1; round < Nr; ++round) {
          a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
          b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
          c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
          d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
          a = a2;
          b = b2;
          c = c2;
        }
        output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
        output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
        output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
        output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
      }
      function _createCipher(options) {
        options = options || {};
        var mode = (options.mode || "CBC").toUpperCase();
        var algorithm = "AES-" + mode;
        var cipher;
        if (options.decrypt) {
          cipher = forge.cipher.createDecipher(algorithm, options.key);
        } else {
          cipher = forge.cipher.createCipher(algorithm, options.key);
        }
        var start = cipher.start;
        cipher.start = function(iv, options2) {
          var output = null;
          if (options2 instanceof forge.util.ByteBuffer) {
            output = options2;
            options2 = {};
          }
          options2 = options2 || {};
          options2.output = output;
          options2.iv = iv;
          start.call(cipher, options2);
        };
        return cipher;
      }
    }
  });

  // node_modules/node-forge/lib/des.js
  var require_des = __commonJS({
    "node_modules/node-forge/lib/des.js"(exports2, module2) {
      var forge = require_forge();
      require_cipher();
      require_cipherModes();
      require_util();
      module2.exports = forge.des = forge.des || {};
      forge.des.startEncrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: false,
          mode: mode || (iv === null ? "ECB" : "CBC")
        });
        cipher.start(iv);
        return cipher;
      };
      forge.des.createEncryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: false,
          mode
        });
      };
      forge.des.startDecrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: true,
          mode: mode || (iv === null ? "ECB" : "CBC")
        });
        cipher.start(iv);
        return cipher;
      };
      forge.des.createDecryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: true,
          mode
        });
      };
      forge.des.Algorithm = function(name, mode) {
        var self2 = this;
        self2.name = name;
        self2.mode = new mode({
          blockSize: 8,
          cipher: {
            encrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._keys, inBlock, outBlock, false);
            },
            decrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._keys, inBlock, outBlock, true);
            }
          }
        });
        self2._init = false;
      };
      forge.des.Algorithm.prototype.initialize = function(options) {
        if (this._init) {
          return;
        }
        var key = forge.util.createBuffer(options.key);
        if (this.name.indexOf("3DES") === 0) {
          if (key.length() !== 24) {
            throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
          }
        }
        this._keys = _createKeys(key);
        this._init = true;
      };
      registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
      registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
      function registerAlgorithm(name, mode) {
        var factory = function() {
          return new forge.des.Algorithm(name, mode);
        };
        forge.cipher.registerAlgorithm(name, factory);
      }
      var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
      var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
      var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
      var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
      var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
      var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
      var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
      var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
      function _createKeys(key) {
        var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
        var iterations = key.length() > 8 ? 3 : 1;
        var keys = [];
        var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
        var n = 0, tmp;
        for (var j = 0; j < iterations; j++) {
          var left = key.getInt32();
          var right = key.getInt32();
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          tmp = (right >>> -16 ^ left) & 65535;
          left ^= tmp;
          right ^= tmp << -16;
          tmp = (left >>> 2 ^ right) & 858993459;
          right ^= tmp;
          left ^= tmp << 2;
          tmp = (right >>> -16 ^ left) & 65535;
          left ^= tmp;
          right ^= tmp << -16;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = left << 8 | right >>> 20 & 240;
          left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
          right = tmp;
          for (var i = 0; i < shifts.length; ++i) {
            if (shifts[i]) {
              left = left << 2 | left >>> 26;
              right = right << 2 | right >>> 26;
            } else {
              left = left << 1 | left >>> 27;
              right = right << 1 | right >>> 27;
            }
            left &= -15;
            right &= -15;
            var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
            var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
            tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
            keys[n++] = lefttmp ^ tmp;
            keys[n++] = righttmp ^ tmp << 16;
          }
        }
        return keys;
      }
      function _updateBlock(keys, input, output, decrypt) {
        var iterations = keys.length === 32 ? 3 : 9;
        var looping;
        if (iterations === 3) {
          looping = decrypt ? [30, -2, -2] : [0, 32, 2];
        } else {
          looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
        }
        var tmp;
        var left = input[0];
        var right = input[1];
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (left >>> 16 ^ right) & 65535;
        right ^= tmp;
        left ^= tmp << 16;
        tmp = (right >>> 2 ^ left) & 858993459;
        left ^= tmp;
        right ^= tmp << 2;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        left = left << 1 | left >>> 31;
        right = right << 1 | right >>> 31;
        for (var j = 0; j < iterations; j += 3) {
          var endloop = looping[j + 1];
          var loopinc = looping[j + 2];
          for (var i = looping[j]; i != endloop; i += loopinc) {
            var right1 = right ^ keys[i];
            var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
            tmp = left;
            left = right;
            right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
          }
          tmp = left;
          left = right;
          right = tmp;
        }
        left = left >>> 1 | left << 31;
        right = right >>> 1 | right << 31;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (right >>> 2 ^ left) & 858993459;
        left ^= tmp;
        right ^= tmp << 2;
        tmp = (left >>> 16 ^ right) & 65535;
        right ^= tmp;
        left ^= tmp << 16;
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        output[0] = left;
        output[1] = right;
      }
      function _createCipher(options) {
        options = options || {};
        var mode = (options.mode || "CBC").toUpperCase();
        var algorithm = "DES-" + mode;
        var cipher;
        if (options.decrypt) {
          cipher = forge.cipher.createDecipher(algorithm, options.key);
        } else {
          cipher = forge.cipher.createCipher(algorithm, options.key);
        }
        var start = cipher.start;
        cipher.start = function(iv, options2) {
          var output = null;
          if (options2 instanceof forge.util.ByteBuffer) {
            output = options2;
            options2 = {};
          }
          options2 = options2 || {};
          options2.output = output;
          options2.iv = iv;
          start.call(cipher, options2);
        };
        return cipher;
      }
    }
  });

  // node_modules/node-forge/lib/md.js
  var require_md = __commonJS({
    "node_modules/node-forge/lib/md.js"(exports2, module2) {
      var forge = require_forge();
      module2.exports = forge.md = forge.md || {};
      forge.md.algorithms = forge.md.algorithms || {};
    }
  });

  // node_modules/node-forge/lib/hmac.js
  var require_hmac2 = __commonJS({
    "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
      var forge = require_forge();
      require_md();
      require_util();
      var hmac = module2.exports = forge.hmac = forge.hmac || {};
      hmac.create = function() {
        var _key = null;
        var _md = null;
        var _ipadding = null;
        var _opadding = null;
        var ctx = {};
        ctx.start = function(md, key) {
          if (md !== null) {
            if (typeof md === "string") {
              md = md.toLowerCase();
              if (md in forge.md.algorithms) {
                _md = forge.md.algorithms[md].create();
              } else {
                throw new Error('Unknown hash algorithm "' + md + '"');
              }
            } else {
              _md = md;
            }
          }
          if (key === null) {
            key = _key;
          } else {
            if (typeof key === "string") {
              key = forge.util.createBuffer(key);
            } else if (forge.util.isArray(key)) {
              var tmp = key;
              key = forge.util.createBuffer();
              for (var i = 0; i < tmp.length; ++i) {
                key.putByte(tmp[i]);
              }
            }
            var keylen = key.length();
            if (keylen > _md.blockLength) {
              _md.start();
              _md.update(key.bytes());
              key = _md.digest();
            }
            _ipadding = forge.util.createBuffer();
            _opadding = forge.util.createBuffer();
            keylen = key.length();
            for (var i = 0; i < keylen; ++i) {
              var tmp = key.at(i);
              _ipadding.putByte(54 ^ tmp);
              _opadding.putByte(92 ^ tmp);
            }
            if (keylen < _md.blockLength) {
              var tmp = _md.blockLength - keylen;
              for (var i = 0; i < tmp; ++i) {
                _ipadding.putByte(54);
                _opadding.putByte(92);
              }
            }
            _key = key;
            _ipadding = _ipadding.bytes();
            _opadding = _opadding.bytes();
          }
          _md.start();
          _md.update(_ipadding);
        };
        ctx.update = function(bytes) {
          _md.update(bytes);
        };
        ctx.getMac = function() {
          var inner = _md.digest().bytes();
          _md.start();
          _md.update(_opadding);
          _md.update(inner);
          return _md.digest();
        };
        ctx.digest = ctx.getMac;
        return ctx;
      };
    }
  });

  // node_modules/node-forge/lib/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
      var forge = require_forge();
      require_hmac2();
      require_md();
      require_util();
      var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
      var crypto2;
      if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
        crypto2 = require_crypto();
      }
      module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
        if (typeof md === "function") {
          callback = md;
          md = null;
        }
        if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
          if (typeof md !== "string") {
            md = "sha1";
          }
          p = Buffer.from(p, "binary");
          s = Buffer.from(s, "binary");
          if (!callback) {
            if (crypto2.pbkdf2Sync.length === 4) {
              return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
            }
            return crypto2.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
          }
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2(p, s, c, dkLen, function(err2, key) {
              if (err2) {
                return callback(err2);
              }
              callback(null, key.toString("binary"));
            });
          }
          return crypto2.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        if (typeof md === "undefined" || md === null) {
          md = "sha1";
        }
        if (typeof md === "string") {
          if (!(md in forge.md.algorithms)) {
            throw new Error("Unknown hash algorithm: " + md);
          }
          md = forge.md[md].create();
        }
        var hLen = md.digestLength;
        if (dkLen > 4294967295 * hLen) {
          var err = new Error("Derived key is too long.");
          if (callback) {
            return callback(err);
          }
          throw err;
        }
        var len = Math.ceil(dkLen / hLen);
        var r = dkLen - (len - 1) * hLen;
        var prf = forge.hmac.create();
        prf.start(md, p);
        var dk = "";
        var xor, u_c, u_c1;
        if (!callback) {
          for (var i = 1; i <= len; ++i) {
            prf.start(null, null);
            prf.update(s);
            prf.update(forge.util.int32ToBytes(i));
            xor = u_c1 = prf.digest().getBytes();
            for (var j = 2; j <= c; ++j) {
              prf.start(null, null);
              prf.update(u_c1);
              u_c = prf.digest().getBytes();
              xor = forge.util.xorBytes(xor, u_c, hLen);
              u_c1 = u_c;
            }
            dk += i < len ? xor : xor.substr(0, r);
          }
          return dk;
        }
        var i = 1, j;
        function outer() {
          if (i > len) {
            return callback(null, dk);
          }
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          j = 2;
          inner();
        }
        function inner() {
          if (j <= c) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
            ++j;
            return forge.util.setImmediate(inner);
          }
          dk += i < len ? xor : xor.substr(0, r);
          ++i;
          outer();
        }
        outer();
      };
    }
  });

  // node_modules/node-forge/lib/pem.js
  var require_pem = __commonJS({
    "node_modules/node-forge/lib/pem.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      var pem = module2.exports = forge.pem = forge.pem || {};
      pem.encode = function(msg, options) {
        options = options || {};
        var rval = "-----BEGIN " + msg.type + "-----\r\n";
        var header;
        if (msg.procType) {
          header = {
            name: "Proc-Type",
            values: [String(msg.procType.version), msg.procType.type]
          };
          rval += foldHeader(header);
        }
        if (msg.contentDomain) {
          header = { name: "Content-Domain", values: [msg.contentDomain] };
          rval += foldHeader(header);
        }
        if (msg.dekInfo) {
          header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
          if (msg.dekInfo.parameters) {
            header.values.push(msg.dekInfo.parameters);
          }
          rval += foldHeader(header);
        }
        if (msg.headers) {
          for (var i = 0; i < msg.headers.length; ++i) {
            rval += foldHeader(msg.headers[i]);
          }
        }
        if (msg.procType) {
          rval += "\r\n";
        }
        rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
        rval += "-----END " + msg.type + "-----\r\n";
        return rval;
      };
      pem.decode = function(str) {
        var rval = [];
        var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
        var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
        var rCRLF = /\r?\n/;
        var match;
        while (true) {
          match = rMessage.exec(str);
          if (!match) {
            break;
          }
          var msg = {
            type: match[1],
            procType: null,
            contentDomain: null,
            dekInfo: null,
            headers: [],
            body: forge.util.decode64(match[3])
          };
          rval.push(msg);
          if (!match[2]) {
            continue;
          }
          var lines = match[2].split(rCRLF);
          var li = 0;
          while (match && li < lines.length) {
            var line = lines[li].replace(/\s+$/, "");
            for (var nl = li + 1; nl < lines.length; ++nl) {
              var next = lines[nl];
              if (!/\s/.test(next[0])) {
                break;
              }
              line += next;
              li = nl;
            }
            match = line.match(rHeader);
            if (match) {
              var header = { name: match[1], values: [] };
              var values = match[2].split(",");
              for (var vi = 0; vi < values.length; ++vi) {
                header.values.push(ltrim(values[vi]));
              }
              if (!msg.procType) {
                if (header.name !== "Proc-Type") {
                  throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                } else if (header.values.length !== 2) {
                  throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                }
                msg.procType = { version: values[0], type: values[1] };
              } else if (!msg.contentDomain && header.name === "Content-Domain") {
                msg.contentDomain = values[0] || "";
              } else if (!msg.dekInfo && header.name === "DEK-Info") {
                if (header.values.length === 0) {
                  throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                }
                msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
              } else {
                msg.headers.push(header);
              }
            }
            ++li;
          }
          if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
          }
        }
        if (rval.length === 0) {
          throw new Error("Invalid PEM formatted message.");
        }
        return rval;
      };
      function foldHeader(header) {
        var rval = header.name + ": ";
        var values = [];
        var insertSpace = function(match, $1) {
          return " " + $1;
        };
        for (var i = 0; i < header.values.length; ++i) {
          values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
        }
        rval += values.join(",") + "\r\n";
        var length2 = 0;
        var candidate = -1;
        for (var i = 0; i < rval.length; ++i, ++length2) {
          if (length2 > 65 && candidate !== -1) {
            var insert = rval[candidate];
            if (insert === ",") {
              ++candidate;
              rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
            } else {
              rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
            }
            length2 = i - candidate - 1;
            candidate = -1;
            ++i;
          } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
            candidate = i;
          }
        }
        return rval;
      }
      function ltrim(str) {
        return str.replace(/^\s+/, "");
      }
    }
  });

  // node_modules/node-forge/lib/sha256.js
  var require_sha2562 = __commonJS({
    "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
      var forge = require_forge();
      require_md();
      require_util();
      var sha2562 = module2.exports = forge.sha256 = forge.sha256 || {};
      forge.md.sha256 = forge.md.algorithms.sha256 = sha2562;
      sha2562.create = function() {
        if (!_initialized) {
          _init();
        }
        var _state = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(64);
        var md = {
          algorithm: "sha256",
          blockLength: 64,
          digestLength: 32,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength64 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _state = {
            h0: 1779033703,
            h1: 3144134277,
            h2: 1013904242,
            h3: 2773480762,
            h4: 1359893119,
            h5: 2600822924,
            h6: 528734635,
            h7: 1541459225
          };
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_state, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var s2 = {
            h0: _state.h0,
            h1: _state.h1,
            h2: _state.h2,
            h3: _state.h3,
            h4: _state.h4,
            h5: _state.h5,
            h6: _state.h6,
            h7: _state.h7
          };
          _update(s2, _w, finalBlock);
          var rval = forge.util.createBuffer();
          rval.putInt32(s2.h0);
          rval.putInt32(s2.h1);
          rval.putInt32(s2.h2);
          rval.putInt32(s2.h3);
          rval.putInt32(s2.h4);
          rval.putInt32(s2.h5);
          rval.putInt32(s2.h6);
          rval.putInt32(s2.h7);
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      var _k = null;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 64);
        _k = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
        var len = bytes.length();
        while (len >= 64) {
          for (i = 0; i < 16; ++i) {
            w[i] = bytes.getInt32();
          }
          for (; i < 64; ++i) {
            t1 = w[i - 2];
            t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            t2 = w[i - 15];
            t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
            w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
          }
          a = s.h0;
          b = s.h1;
          c = s.h2;
          d = s.h3;
          e = s.h4;
          f = s.h5;
          g = s.h6;
          h = s.h7;
          for (i = 0; i < 64; ++i) {
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ch = g ^ e & (f ^ g);
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            maj = a & b | c & (a ^ b);
            t1 = h + s1 + ch + _k[i] + w[i];
            t2 = s0 + maj;
            h = g;
            g = f;
            f = e;
            e = d + t1 >>> 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 >>> 0;
          }
          s.h0 = s.h0 + a | 0;
          s.h1 = s.h1 + b | 0;
          s.h2 = s.h2 + c | 0;
          s.h3 = s.h3 + d | 0;
          s.h4 = s.h4 + e | 0;
          s.h5 = s.h5 + f | 0;
          s.h6 = s.h6 + g | 0;
          s.h7 = s.h7 + h | 0;
          len -= 64;
        }
      }
    }
  });

  // node_modules/node-forge/lib/prng.js
  var require_prng = __commonJS({
    "node_modules/node-forge/lib/prng.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      var _crypto = null;
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
        _crypto = require_crypto();
      }
      var prng = module2.exports = forge.prng = forge.prng || {};
      prng.create = function(plugin) {
        var ctx = {
          plugin,
          key: null,
          seed: null,
          time: null,
          reseeds: 0,
          generated: 0,
          keyBytes: ""
        };
        var md = plugin.md;
        var pools = new Array(32);
        for (var i = 0; i < 32; ++i) {
          pools[i] = md.create();
        }
        ctx.pools = pools;
        ctx.pool = 0;
        ctx.generate = function(count, callback) {
          if (!callback) {
            return ctx.generateSync(count);
          }
          var cipher = ctx.plugin.cipher;
          var increment = ctx.plugin.increment;
          var formatKey = ctx.plugin.formatKey;
          var formatSeed = ctx.plugin.formatSeed;
          var b = forge.util.createBuffer();
          ctx.key = null;
          generate();
          function generate(err) {
            if (err) {
              return callback(err);
            }
            if (b.length() >= count) {
              return callback(null, b.getBytes(count));
            }
            if (ctx.generated > 1048575) {
              ctx.key = null;
            }
            if (ctx.key === null) {
              return forge.util.nextTick(function() {
                _reseed(generate);
              });
            }
            var bytes = cipher(ctx.key, ctx.seed);
            ctx.generated += bytes.length;
            b.putBytes(bytes);
            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
            forge.util.setImmediate(generate);
          }
        };
        ctx.generateSync = function(count) {
          var cipher = ctx.plugin.cipher;
          var increment = ctx.plugin.increment;
          var formatKey = ctx.plugin.formatKey;
          var formatSeed = ctx.plugin.formatSeed;
          ctx.key = null;
          var b = forge.util.createBuffer();
          while (b.length() < count) {
            if (ctx.generated > 1048575) {
              ctx.key = null;
            }
            if (ctx.key === null) {
              _reseedSync();
            }
            var bytes = cipher(ctx.key, ctx.seed);
            ctx.generated += bytes.length;
            b.putBytes(bytes);
            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          }
          return b.getBytes(count);
        };
        function _reseed(callback) {
          if (ctx.pools[0].messageLength >= 32) {
            _seed();
            return callback();
          }
          var needed = 32 - ctx.pools[0].messageLength << 5;
          ctx.seedFile(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            ctx.collect(bytes);
            _seed();
            callback();
          });
        }
        function _reseedSync() {
          if (ctx.pools[0].messageLength >= 32) {
            return _seed();
          }
          var needed = 32 - ctx.pools[0].messageLength << 5;
          ctx.collect(ctx.seedFileSync(needed));
          _seed();
        }
        function _seed() {
          ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
          var md2 = ctx.plugin.md.create();
          md2.update(ctx.keyBytes);
          var _2powK = 1;
          for (var k = 0; k < 32; ++k) {
            if (ctx.reseeds % _2powK === 0) {
              md2.update(ctx.pools[k].digest().getBytes());
              ctx.pools[k].start();
            }
            _2powK = _2powK << 1;
          }
          ctx.keyBytes = md2.digest().getBytes();
          md2.start();
          md2.update(ctx.keyBytes);
          var seedBytes = md2.digest().getBytes();
          ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
          ctx.seed = ctx.plugin.formatSeed(seedBytes);
          ctx.generated = 0;
        }
        function defaultSeedFile(needed) {
          var getRandomValues = null;
          var globalScope = forge.util.globalScope;
          var _crypto2 = globalScope.crypto || globalScope.msCrypto;
          if (_crypto2 && _crypto2.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto2.getRandomValues(arr);
            };
          }
          var b = forge.util.createBuffer();
          if (getRandomValues) {
            while (b.length() < needed) {
              var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
              var entropy = new Uint32Array(Math.floor(count));
              try {
                getRandomValues(entropy);
                for (var i2 = 0; i2 < entropy.length; ++i2) {
                  b.putInt32(entropy[i2]);
                }
              } catch (e) {
                if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                  throw e;
                }
              }
            }
          }
          if (b.length() < needed) {
            var hi, lo, next;
            var seed = Math.floor(Math.random() * 65536);
            while (b.length() < needed) {
              lo = 16807 * (seed & 65535);
              hi = 16807 * (seed >> 16);
              lo += (hi & 32767) << 16;
              lo += hi >> 15;
              lo = (lo & 2147483647) + (lo >> 31);
              seed = lo & 4294967295;
              for (var i2 = 0; i2 < 3; ++i2) {
                next = seed >>> (i2 << 3);
                next ^= Math.floor(Math.random() * 256);
                b.putByte(String.fromCharCode(next & 255));
              }
            }
          }
          return b.getBytes(needed);
        }
        if (_crypto) {
          ctx.seedFile = function(needed, callback) {
            _crypto.randomBytes(needed, function(err, bytes) {
              if (err) {
                return callback(err);
              }
              callback(null, bytes.toString());
            });
          };
          ctx.seedFileSync = function(needed) {
            return _crypto.randomBytes(needed).toString();
          };
        } else {
          ctx.seedFile = function(needed, callback) {
            try {
              callback(null, defaultSeedFile(needed));
            } catch (e) {
              callback(e);
            }
          };
          ctx.seedFileSync = defaultSeedFile;
        }
        ctx.collect = function(bytes) {
          var count = bytes.length;
          for (var i2 = 0; i2 < count; ++i2) {
            ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
            ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
          }
        };
        ctx.collectInt = function(i2, n) {
          var bytes = "";
          for (var x = 0; x < n; x += 8) {
            bytes += String.fromCharCode(i2 >> x & 255);
          }
          ctx.collect(bytes);
        };
        ctx.registerWorker = function(worker) {
          if (worker === self) {
            ctx.seedFile = function(needed, callback) {
              function listener2(e) {
                var data = e.data;
                if (data.forge && data.forge.prng) {
                  self.removeEventListener("message", listener2);
                  callback(data.forge.prng.err, data.forge.prng.bytes);
                }
              }
              self.addEventListener("message", listener2);
              self.postMessage({ forge: { prng: { needed } } });
            };
          } else {
            var listener = function(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                  worker.postMessage({ forge: { prng: { err, bytes } } });
                });
              }
            };
            worker.addEventListener("message", listener);
          }
        };
        return ctx;
      };
    }
  });

  // node_modules/node-forge/lib/random.js
  var require_random2 = __commonJS({
    "node_modules/node-forge/lib/random.js"(exports2, module2) {
      var forge = require_forge();
      require_aes();
      require_sha2562();
      require_prng();
      require_util();
      (function() {
        if (forge.random && forge.random.getBytes) {
          module2.exports = forge.random;
          return;
        }
        (function(jQuery2) {
          var prng_aes = {};
          var _prng_aes_output = new Array(4);
          var _prng_aes_buffer = forge.util.createBuffer();
          prng_aes.formatKey = function(key2) {
            var tmp = forge.util.createBuffer(key2);
            key2 = new Array(4);
            key2[0] = tmp.getInt32();
            key2[1] = tmp.getInt32();
            key2[2] = tmp.getInt32();
            key2[3] = tmp.getInt32();
            return forge.aes._expandKey(key2, false);
          };
          prng_aes.formatSeed = function(seed) {
            var tmp = forge.util.createBuffer(seed);
            seed = new Array(4);
            seed[0] = tmp.getInt32();
            seed[1] = tmp.getInt32();
            seed[2] = tmp.getInt32();
            seed[3] = tmp.getInt32();
            return seed;
          };
          prng_aes.cipher = function(key2, seed) {
            forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
            _prng_aes_buffer.putInt32(_prng_aes_output[0]);
            _prng_aes_buffer.putInt32(_prng_aes_output[1]);
            _prng_aes_buffer.putInt32(_prng_aes_output[2]);
            _prng_aes_buffer.putInt32(_prng_aes_output[3]);
            return _prng_aes_buffer.getBytes();
          };
          prng_aes.increment = function(seed) {
            ++seed[3];
            return seed;
          };
          prng_aes.md = forge.md.sha256;
          function spawnPrng() {
            var ctx = forge.prng.create(prng_aes);
            ctx.getBytes = function(count, callback) {
              return ctx.generate(count, callback);
            };
            ctx.getBytesSync = function(count) {
              return ctx.generate(count);
            };
            return ctx;
          }
          var _ctx = spawnPrng();
          var getRandomValues = null;
          var globalScope = forge.util.globalScope;
          var _crypto = globalScope.crypto || globalScope.msCrypto;
          if (_crypto && _crypto.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto.getRandomValues(arr);
            };
          }
          if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
            if (typeof window === "undefined" || window.document === void 0) {
            }
            _ctx.collectInt(+new Date(), 32);
            if (typeof navigator !== "undefined") {
              var _navBytes = "";
              for (var key in navigator) {
                try {
                  if (typeof navigator[key] == "string") {
                    _navBytes += navigator[key];
                  }
                } catch (e) {
                }
              }
              _ctx.collect(_navBytes);
              _navBytes = null;
            }
            if (jQuery2) {
              jQuery2().mousemove(function(e) {
                _ctx.collectInt(e.clientX, 16);
                _ctx.collectInt(e.clientY, 16);
              });
              jQuery2().keypress(function(e) {
                _ctx.collectInt(e.charCode, 8);
              });
            }
          }
          if (!forge.random) {
            forge.random = _ctx;
          } else {
            for (var key in _ctx) {
              forge.random[key] = _ctx[key];
            }
          }
          forge.random.createInstance = spawnPrng;
          module2.exports = forge.random;
        })(typeof jQuery !== "undefined" ? jQuery : null);
      })();
    }
  });

  // node_modules/node-forge/lib/rc2.js
  var require_rc2 = __commonJS({
    "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      var piTable = [
        217,
        120,
        249,
        196,
        25,
        221,
        181,
        237,
        40,
        233,
        253,
        121,
        74,
        160,
        216,
        157,
        198,
        126,
        55,
        131,
        43,
        118,
        83,
        142,
        98,
        76,
        100,
        136,
        68,
        139,
        251,
        162,
        23,
        154,
        89,
        245,
        135,
        179,
        79,
        19,
        97,
        69,
        109,
        141,
        9,
        129,
        125,
        50,
        189,
        143,
        64,
        235,
        134,
        183,
        123,
        11,
        240,
        149,
        33,
        34,
        92,
        107,
        78,
        130,
        84,
        214,
        101,
        147,
        206,
        96,
        178,
        28,
        115,
        86,
        192,
        20,
        167,
        140,
        241,
        220,
        18,
        117,
        202,
        31,
        59,
        190,
        228,
        209,
        66,
        61,
        212,
        48,
        163,
        60,
        182,
        38,
        111,
        191,
        14,
        218,
        70,
        105,
        7,
        87,
        39,
        242,
        29,
        155,
        188,
        148,
        67,
        3,
        248,
        17,
        199,
        246,
        144,
        239,
        62,
        231,
        6,
        195,
        213,
        47,
        200,
        102,
        30,
        215,
        8,
        232,
        234,
        222,
        128,
        82,
        238,
        247,
        132,
        170,
        114,
        172,
        53,
        77,
        106,
        42,
        150,
        26,
        210,
        113,
        90,
        21,
        73,
        116,
        75,
        159,
        208,
        94,
        4,
        24,
        164,
        236,
        194,
        224,
        65,
        110,
        15,
        81,
        203,
        204,
        36,
        145,
        175,
        80,
        161,
        244,
        112,
        57,
        153,
        124,
        58,
        133,
        35,
        184,
        180,
        122,
        252,
        2,
        54,
        91,
        37,
        85,
        151,
        49,
        45,
        93,
        250,
        152,
        227,
        138,
        146,
        174,
        5,
        223,
        41,
        16,
        103,
        108,
        186,
        201,
        211,
        0,
        230,
        207,
        225,
        158,
        168,
        44,
        99,
        22,
        1,
        63,
        88,
        226,
        137,
        169,
        13,
        56,
        52,
        27,
        171,
        51,
        255,
        176,
        187,
        72,
        12,
        95,
        185,
        177,
        205,
        46,
        197,
        243,
        219,
        71,
        229,
        165,
        156,
        119,
        10,
        166,
        32,
        104,
        254,
        127,
        193,
        173
      ];
      var s = [1, 2, 3, 5];
      var rol = function(word, bits) {
        return word << bits & 65535 | (word & 65535) >> 16 - bits;
      };
      var ror = function(word, bits) {
        return (word & 65535) >> bits | word << 16 - bits & 65535;
      };
      module2.exports = forge.rc2 = forge.rc2 || {};
      forge.rc2.expandKey = function(key, effKeyBits) {
        if (typeof key === "string") {
          key = forge.util.createBuffer(key);
        }
        effKeyBits = effKeyBits || 128;
        var L = key;
        var T = key.length();
        var T1 = effKeyBits;
        var T8 = Math.ceil(T1 / 8);
        var TM = 255 >> (T1 & 7);
        var i;
        for (i = T; i < 128; i++) {
          L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
        }
        L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
        for (i = 127 - T8; i >= 0; i--) {
          L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
        }
        return L;
      };
      var createCipher = function(key, bits, encrypt) {
        var _finish = false, _input = null, _output = null, _iv = null;
        var mixRound, mashRound;
        var i, j, K = [];
        key = forge.rc2.expandKey(key, bits);
        for (i = 0; i < 64; i++) {
          K.push(key.getInt16Le());
        }
        if (encrypt) {
          mixRound = function(R) {
            for (i = 0; i < 4; i++) {
              R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
              R[i] = rol(R[i], s[i]);
              j++;
            }
          };
          mashRound = function(R) {
            for (i = 0; i < 4; i++) {
              R[i] += K[R[(i + 3) % 4] & 63];
            }
          };
        } else {
          mixRound = function(R) {
            for (i = 3; i >= 0; i--) {
              R[i] = ror(R[i], s[i]);
              R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
              j--;
            }
          };
          mashRound = function(R) {
            for (i = 3; i >= 0; i--) {
              R[i] -= K[R[(i + 3) % 4] & 63];
            }
          };
        }
        var runPlan = function(plan) {
          var R = [];
          for (i = 0; i < 4; i++) {
            var val = _input.getInt16Le();
            if (_iv !== null) {
              if (encrypt) {
                val ^= _iv.getInt16Le();
              } else {
                _iv.putInt16Le(val);
              }
            }
            R.push(val & 65535);
          }
          j = encrypt ? 0 : 63;
          for (var ptr = 0; ptr < plan.length; ptr++) {
            for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
              plan[ptr][1](R);
            }
          }
          for (i = 0; i < 4; i++) {
            if (_iv !== null) {
              if (encrypt) {
                _iv.putInt16Le(R[i]);
              } else {
                R[i] ^= _iv.getInt16Le();
              }
            }
            _output.putInt16Le(R[i]);
          }
        };
        var cipher = null;
        cipher = {
          start: function(iv, output) {
            if (iv) {
              if (typeof iv === "string") {
                iv = forge.util.createBuffer(iv);
              }
            }
            _finish = false;
            _input = forge.util.createBuffer();
            _output = output || new forge.util.createBuffer();
            _iv = iv;
            cipher.output = _output;
          },
          update: function(input) {
            if (!_finish) {
              _input.putBuffer(input);
            }
            while (_input.length() >= 8) {
              runPlan([
                [5, mixRound],
                [1, mashRound],
                [6, mixRound],
                [1, mashRound],
                [5, mixRound]
              ]);
            }
          },
          finish: function(pad) {
            var rval = true;
            if (encrypt) {
              if (pad) {
                rval = pad(8, _input, !encrypt);
              } else {
                var padding = _input.length() === 8 ? 8 : 8 - _input.length();
                _input.fillWithByte(padding, padding);
              }
            }
            if (rval) {
              _finish = true;
              cipher.update();
            }
            if (!encrypt) {
              rval = _input.length() === 0;
              if (rval) {
                if (pad) {
                  rval = pad(8, _output, !encrypt);
                } else {
                  var len = _output.length();
                  var count = _output.at(len - 1);
                  if (count > len) {
                    rval = false;
                  } else {
                    _output.truncate(count);
                  }
                }
              }
            }
            return rval;
          }
        };
        return cipher;
      };
      forge.rc2.startEncrypting = function(key, iv, output) {
        var cipher = forge.rc2.createEncryptionCipher(key, 128);
        cipher.start(iv, output);
        return cipher;
      };
      forge.rc2.createEncryptionCipher = function(key, bits) {
        return createCipher(key, bits, true);
      };
      forge.rc2.startDecrypting = function(key, iv, output) {
        var cipher = forge.rc2.createDecryptionCipher(key, 128);
        cipher.start(iv, output);
        return cipher;
      };
      forge.rc2.createDecryptionCipher = function(key, bits) {
        return createCipher(key, bits, false);
      };
    }
  });

  // node_modules/node-forge/lib/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
      var forge = require_forge();
      require_md();
      require_util();
      var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
      forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
      sha1.create = function() {
        if (!_initialized) {
          _init();
        }
        var _state = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(80);
        var md = {
          algorithm: "sha1",
          blockLength: 64,
          digestLength: 20,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength64 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _state = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878,
            h4: 3285377520
          };
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_state, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var s2 = {
            h0: _state.h0,
            h1: _state.h1,
            h2: _state.h2,
            h3: _state.h3,
            h4: _state.h4
          };
          _update(s2, _w, finalBlock);
          var rval = forge.util.createBuffer();
          rval.putInt32(s2.h0);
          rval.putInt32(s2.h1);
          rval.putInt32(s2.h2);
          rval.putInt32(s2.h3);
          rval.putInt32(s2.h4);
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 64);
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t, a, b, c, d, e, f, i;
        var len = bytes.length();
        while (len >= 64) {
          a = s.h0;
          b = s.h1;
          c = s.h2;
          d = s.h3;
          e = s.h4;
          for (i = 0; i < 16; ++i) {
            t = bytes.getInt32();
            w[i] = t;
            f = d ^ b & (c ^ d);
            t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 20; ++i) {
            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
            t = t << 1 | t >>> 31;
            w[i] = t;
            f = d ^ b & (c ^ d);
            t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 32; ++i) {
            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
            t = t << 1 | t >>> 31;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 40; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 60; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b & c | d & (b ^ c);
            t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 80; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          s.h0 = s.h0 + a | 0;
          s.h1 = s.h1 + b | 0;
          s.h2 = s.h2 + c | 0;
          s.h3 = s.h3 + d | 0;
          s.h4 = s.h4 + e | 0;
          len -= 64;
        }
      }
    }
  });

  // node_modules/node-forge/lib/pkcs1.js
  var require_pkcs1 = __commonJS({
    "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      require_random2();
      require_sha1();
      var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
      pkcs1.encode_rsa_oaep = function(key, message, options) {
        var label;
        var seed;
        var md;
        var mgf1Md;
        if (typeof options === "string") {
          label = options;
          seed = arguments[3] || void 0;
          md = arguments[4] || void 0;
        } else if (options) {
          label = options.label || void 0;
          seed = options.seed || void 0;
          md = options.md || void 0;
          if (options.mgf1 && options.mgf1.md) {
            mgf1Md = options.mgf1.md;
          }
        }
        if (!md) {
          md = forge.md.sha1.create();
        } else {
          md.start();
        }
        if (!mgf1Md) {
          mgf1Md = md;
        }
        var keyLength = Math.ceil(key.n.bitLength() / 8);
        var maxLength = keyLength - 2 * md.digestLength - 2;
        if (message.length > maxLength) {
          var error = new Error("RSAES-OAEP input message length is too long.");
          error.length = message.length;
          error.maxLength = maxLength;
          throw error;
        }
        if (!label) {
          label = "";
        }
        md.update(label, "raw");
        var lHash = md.digest();
        var PS = "";
        var PS_length = maxLength - message.length;
        for (var i = 0; i < PS_length; i++) {
          PS += "\0";
        }
        var DB = lHash.getBytes() + PS + "" + message;
        if (!seed) {
          seed = forge.random.getBytes(md.digestLength);
        } else if (seed.length !== md.digestLength) {
          var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
          error.seedLength = seed.length;
          error.digestLength = md.digestLength;
          throw error;
        }
        var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
        var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
        var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
        var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
        return "\0" + maskedSeed + maskedDB;
      };
      pkcs1.decode_rsa_oaep = function(key, em, options) {
        var label;
        var md;
        var mgf1Md;
        if (typeof options === "string") {
          label = options;
          md = arguments[3] || void 0;
        } else if (options) {
          label = options.label || void 0;
          md = options.md || void 0;
          if (options.mgf1 && options.mgf1.md) {
            mgf1Md = options.mgf1.md;
          }
        }
        var keyLength = Math.ceil(key.n.bitLength() / 8);
        if (em.length !== keyLength) {
          var error = new Error("RSAES-OAEP encoded message length is invalid.");
          error.length = em.length;
          error.expectedLength = keyLength;
          throw error;
        }
        if (md === void 0) {
          md = forge.md.sha1.create();
        } else {
          md.start();
        }
        if (!mgf1Md) {
          mgf1Md = md;
        }
        if (keyLength < 2 * md.digestLength + 2) {
          throw new Error("RSAES-OAEP key is too short for the hash function.");
        }
        if (!label) {
          label = "";
        }
        md.update(label, "raw");
        var lHash = md.digest().getBytes();
        var y = em.charAt(0);
        var maskedSeed = em.substring(1, md.digestLength + 1);
        var maskedDB = em.substring(1 + md.digestLength);
        var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
        var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
        var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
        var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
        var lHashPrime = db.substring(0, md.digestLength);
        var error = y !== "\0";
        for (var i = 0; i < md.digestLength; ++i) {
          error |= lHash.charAt(i) !== lHashPrime.charAt(i);
        }
        var in_ps = 1;
        var index = md.digestLength;
        for (var j = md.digestLength; j < db.length; j++) {
          var code = db.charCodeAt(j);
          var is_0 = code & 1 ^ 1;
          var error_mask = in_ps ? 65534 : 0;
          error |= code & error_mask;
          in_ps = in_ps & is_0;
          index += in_ps;
        }
        if (error || db.charCodeAt(index) !== 1) {
          throw new Error("Invalid RSAES-OAEP padding.");
        }
        return db.substring(index + 1);
      };
      function rsa_mgf1(seed, maskLength, hash) {
        if (!hash) {
          hash = forge.md.sha1.create();
        }
        var t = "";
        var count = Math.ceil(maskLength / hash.digestLength);
        for (var i = 0; i < count; ++i) {
          var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
          hash.start();
          hash.update(seed + c);
          t += hash.digest().getBytes();
        }
        return t.substring(0, maskLength);
      }
    }
  });

  // node_modules/node-forge/lib/prime.js
  var require_prime = __commonJS({
    "node_modules/node-forge/lib/prime.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      require_jsbn();
      require_random2();
      (function() {
        if (forge.prime) {
          module2.exports = forge.prime;
          return;
        }
        var prime = module2.exports = forge.prime = forge.prime || {};
        var BigInteger = forge.jsbn.BigInteger;
        var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
        var THIRTY = new BigInteger(null);
        THIRTY.fromInt(30);
        var op_or = function(x, y) {
          return x | y;
        };
        prime.generateProbablePrime = function(bits, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          var algorithm = options.algorithm || "PRIMEINC";
          if (typeof algorithm === "string") {
            algorithm = { name: algorithm };
          }
          algorithm.options = algorithm.options || {};
          var prng = options.prng || forge.random;
          var rng = {
            nextBytes: function(x) {
              var b = prng.getBytesSync(x.length);
              for (var i = 0; i < x.length; ++i) {
                x[i] = b.charCodeAt(i);
              }
            }
          };
          if (algorithm.name === "PRIMEINC") {
            return primeincFindPrime(bits, rng, algorithm.options, callback);
          }
          throw new Error("Invalid prime generation algorithm: " + algorithm.name);
        };
        function primeincFindPrime(bits, rng, options, callback) {
          if ("workers" in options) {
            return primeincFindPrimeWithWorkers(bits, rng, options, callback);
          }
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
          var num = generateRandom(bits, rng);
          var deltaIdx = 0;
          var mrTests = getMillerRabinTests(num.bitLength());
          if ("millerRabinTests" in options) {
            mrTests = options.millerRabinTests;
          }
          var maxBlockTime = 10;
          if ("maxBlockTime" in options) {
            maxBlockTime = options.maxBlockTime;
          }
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        }
        function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
          var start = +new Date();
          do {
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            if (num.isProbablePrime(mrTests)) {
              return callback(null, num);
            }
            num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
          } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
          forge.util.setImmediate(function() {
            _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
          });
        }
        function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
          if (typeof Worker === "undefined") {
            return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
          }
          var num = generateRandom(bits, rng);
          var numWorkers = options.workers;
          var workLoad = options.workLoad || 100;
          var range = workLoad * 30 / 8;
          var workerScript = options.workerScript || "forge/prime.worker.js";
          if (numWorkers === -1) {
            return forge.util.estimateCores(function(err, cores) {
              if (err) {
                cores = 2;
              }
              numWorkers = cores - 1;
              generate();
            });
          }
          generate();
          function generate() {
            numWorkers = Math.max(1, numWorkers);
            var workers = [];
            for (var i = 0; i < numWorkers; ++i) {
              workers[i] = new Worker(workerScript);
            }
            var running = numWorkers;
            for (var i = 0; i < numWorkers; ++i) {
              workers[i].addEventListener("message", workerMessage);
            }
            var found = false;
            function workerMessage(e) {
              if (found) {
                return;
              }
              --running;
              var data = e.data;
              if (data.found) {
                for (var i2 = 0; i2 < workers.length; ++i2) {
                  workers[i2].terminate();
                }
                found = true;
                return callback(null, new BigInteger(data.prime, 16));
              }
              if (num.bitLength() > bits) {
                num = generateRandom(bits, rng);
              }
              var hex = num.toString(16);
              e.target.postMessage({
                hex,
                workLoad
              });
              num.dAddOffset(range, 0);
            }
          }
        }
        function generateRandom(bits, rng) {
          var num = new BigInteger(bits, rng);
          var bits1 = bits - 1;
          if (!num.testBit(bits1)) {
            num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
          }
          num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
          return num;
        }
        function getMillerRabinTests(bits) {
          if (bits <= 100)
            return 27;
          if (bits <= 150)
            return 18;
          if (bits <= 200)
            return 15;
          if (bits <= 250)
            return 12;
          if (bits <= 300)
            return 9;
          if (bits <= 350)
            return 8;
          if (bits <= 400)
            return 7;
          if (bits <= 500)
            return 6;
          if (bits <= 600)
            return 5;
          if (bits <= 800)
            return 4;
          if (bits <= 1250)
            return 3;
          return 2;
        }
      })();
    }
  });

  // node_modules/node-forge/lib/rsa.js
  var require_rsa = __commonJS({
    "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
      var forge = require_forge();
      require_asn1();
      require_jsbn();
      require_oids();
      require_pkcs1();
      require_prime();
      require_random2();
      require_util();
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var _crypto = forge.util.isNodejs ? require_crypto() : null;
      var asn1 = forge.asn1;
      var util = forge.util;
      forge.pki = forge.pki || {};
      module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
      var pki = forge.pki;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var privateKeyValidator = {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "privateKey"
        }]
      };
      var rsaPrivateKeyValidator = {
        name: "RSAPrivateKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RSAPrivateKey.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "RSAPrivateKey.modulus",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyModulus"
        }, {
          name: "RSAPrivateKey.publicExponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPublicExponent"
        }, {
          name: "RSAPrivateKey.privateExponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrivateExponent"
        }, {
          name: "RSAPrivateKey.prime1",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime1"
        }, {
          name: "RSAPrivateKey.prime2",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime2"
        }, {
          name: "RSAPrivateKey.exponent1",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent1"
        }, {
          name: "RSAPrivateKey.exponent2",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent2"
        }, {
          name: "RSAPrivateKey.coefficient",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyCoefficient"
        }]
      };
      var rsaPublicKeyValidator = {
        name: "RSAPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RSAPublicKey.modulus",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "publicKeyModulus"
        }, {
          name: "RSAPublicKey.exponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "publicKeyExponent"
        }]
      };
      var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "subjectPublicKeyInfo",
        value: [{
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        }, {
          name: "SubjectPublicKeyInfo.subjectPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: "rsaPublicKey"
          }]
        }]
      };
      var emsaPkcs1v15encode = function(md) {
        var oid;
        if (md.algorithm in pki.oids) {
          oid = pki.oids[md.algorithm];
        } else {
          var error = new Error("Unknown message digest algorithm.");
          error.algorithm = md.algorithm;
          throw error;
        }
        var oidBytes = asn1.oidToDer(oid).getBytes();
        var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
        digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
        var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
        digestInfo.value.push(digestAlgorithm);
        digestInfo.value.push(digest);
        return asn1.toDer(digestInfo).getBytes();
      };
      var _modPow = function(x, key, pub) {
        if (pub) {
          return x.modPow(key.e, key.n);
        }
        if (!key.p || !key.q) {
          return x.modPow(key.d, key.n);
        }
        if (!key.dP) {
          key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
        }
        if (!key.dQ) {
          key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
        }
        if (!key.qInv) {
          key.qInv = key.q.modInverse(key.p);
        }
        var r;
        do {
          r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
        } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
        x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
        var xp = x.mod(key.p).modPow(key.dP, key.p);
        var xq = x.mod(key.q).modPow(key.dQ, key.q);
        while (xp.compareTo(xq) < 0) {
          xp = xp.add(key.p);
        }
        var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
        y = y.multiply(r.modInverse(key.n)).mod(key.n);
        return y;
      };
      pki.rsa.encrypt = function(m, key, bt) {
        var pub = bt;
        var eb;
        var k = Math.ceil(key.n.bitLength() / 8);
        if (bt !== false && bt !== true) {
          pub = bt === 2;
          eb = _encodePkcs1_v1_5(m, key, bt);
        } else {
          eb = forge.util.createBuffer();
          eb.putBytes(m);
        }
        var x = new BigInteger(eb.toHex(), 16);
        var y = _modPow(x, key, pub);
        var yhex = y.toString(16);
        var ed = forge.util.createBuffer();
        var zeros = k - Math.ceil(yhex.length / 2);
        while (zeros > 0) {
          ed.putByte(0);
          --zeros;
        }
        ed.putBytes(forge.util.hexToBytes(yhex));
        return ed.getBytes();
      };
      pki.rsa.decrypt = function(ed, key, pub, ml) {
        var k = Math.ceil(key.n.bitLength() / 8);
        if (ed.length !== k) {
          var error = new Error("Encrypted message length is invalid.");
          error.length = ed.length;
          error.expected = k;
          throw error;
        }
        var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
        if (y.compareTo(key.n) >= 0) {
          throw new Error("Encrypted message is invalid.");
        }
        var x = _modPow(y, key, pub);
        var xhex = x.toString(16);
        var eb = forge.util.createBuffer();
        var zeros = k - Math.ceil(xhex.length / 2);
        while (zeros > 0) {
          eb.putByte(0);
          --zeros;
        }
        eb.putBytes(forge.util.hexToBytes(xhex));
        if (ml !== false) {
          return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
        }
        return eb.getBytes();
      };
      pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
        if (typeof bits === "string") {
          bits = parseInt(bits, 10);
        }
        bits = bits || 2048;
        options = options || {};
        var prng = options.prng || forge.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        var algorithm = options.algorithm || "PRIMEINC";
        var rval;
        if (algorithm === "PRIMEINC") {
          rval = {
            algorithm,
            state: 0,
            bits,
            rng,
            eInt: e || 65537,
            e: new BigInteger(null),
            p: null,
            q: null,
            qBits: bits >> 1,
            pBits: bits - (bits >> 1),
            pqState: 0,
            num: null,
            keys: null
          };
          rval.e.fromInt(rval.eInt);
        } else {
          throw new Error("Invalid key generation algorithm: " + algorithm);
        }
        return rval;
      };
      pki.rsa.stepKeyPairGenerationState = function(state, n) {
        if (!("algorithm" in state)) {
          state.algorithm = "PRIMEINC";
        }
        var THIRTY = new BigInteger(null);
        THIRTY.fromInt(30);
        var deltaIdx = 0;
        var op_or = function(x, y) {
          return x | y;
        };
        var t1 = +new Date();
        var t2;
        var total = 0;
        while (state.keys === null && (n <= 0 || total < n)) {
          if (state.state === 0) {
            var bits = state.p === null ? state.pBits : state.qBits;
            var bits1 = bits - 1;
            if (state.pqState === 0) {
              state.num = new BigInteger(bits, state.rng);
              if (!state.num.testBit(bits1)) {
                state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
              }
              state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
              deltaIdx = 0;
              ++state.pqState;
            } else if (state.pqState === 1) {
              if (state.num.bitLength() > bits) {
                state.pqState = 0;
              } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
                ++state.pqState;
              } else {
                state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
              }
            } else if (state.pqState === 2) {
              state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
            } else if (state.pqState === 3) {
              state.pqState = 0;
              if (state.p === null) {
                state.p = state.num;
              } else {
                state.q = state.num;
              }
              if (state.p !== null && state.q !== null) {
                ++state.state;
              }
              state.num = null;
            }
          } else if (state.state === 1) {
            if (state.p.compareTo(state.q) < 0) {
              state.num = state.p;
              state.p = state.q;
              state.q = state.num;
            }
            ++state.state;
          } else if (state.state === 2) {
            state.p1 = state.p.subtract(BigInteger.ONE);
            state.q1 = state.q.subtract(BigInteger.ONE);
            state.phi = state.p1.multiply(state.q1);
            ++state.state;
          } else if (state.state === 3) {
            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
              ++state.state;
            } else {
              state.p = null;
              state.q = null;
              state.state = 0;
            }
          } else if (state.state === 4) {
            state.n = state.p.multiply(state.q);
            if (state.n.bitLength() === state.bits) {
              ++state.state;
            } else {
              state.q = null;
              state.state = 0;
            }
          } else if (state.state === 5) {
            var d = state.e.modInverse(state.phi);
            state.keys = {
              privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
              publicKey: pki.rsa.setPublicKey(state.n, state.e)
            };
          }
          t2 = +new Date();
          total += t2 - t1;
          t1 = t2;
        }
        return state.keys !== null;
      };
      pki.rsa.generateKeyPair = function(bits, e, options, callback) {
        if (arguments.length === 1) {
          if (typeof bits === "object") {
            options = bits;
            bits = void 0;
          } else if (typeof bits === "function") {
            callback = bits;
            bits = void 0;
          }
        } else if (arguments.length === 2) {
          if (typeof bits === "number") {
            if (typeof e === "function") {
              callback = e;
              e = void 0;
            } else if (typeof e !== "number") {
              options = e;
              e = void 0;
            }
          } else {
            options = bits;
            callback = e;
            bits = void 0;
            e = void 0;
          }
        } else if (arguments.length === 3) {
          if (typeof e === "number") {
            if (typeof options === "function") {
              callback = options;
              options = void 0;
            }
          } else {
            callback = options;
            options = e;
            e = void 0;
          }
        }
        options = options || {};
        if (bits === void 0) {
          bits = options.bits || 2048;
        }
        if (e === void 0) {
          e = options.e || 65537;
        }
        if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
          if (callback) {
            if (_detectNodeCrypto("generateKeyPair")) {
              return _crypto.generateKeyPair("rsa", {
                modulusLength: bits,
                publicExponent: e,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              }, function(err, pub, priv) {
                if (err) {
                  return callback(err);
                }
                callback(null, {
                  privateKey: pki.privateKeyFromPem(priv),
                  publicKey: pki.publicKeyFromPem(pub)
                });
              });
            }
            if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
              return util.globalScope.crypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: bits,
                publicExponent: _intToUint8Array(e),
                hash: { name: "SHA-256" }
              }, true, ["sign", "verify"]).then(function(pair) {
                return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
              }).then(void 0, function(err) {
                callback(err);
              }).then(function(pkcs8) {
                if (pkcs8) {
                  var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                  callback(null, {
                    privateKey,
                    publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                  });
                }
              });
            }
            if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
              var genOp = util.globalScope.msCrypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: bits,
                publicExponent: _intToUint8Array(e),
                hash: { name: "SHA-256" }
              }, true, ["sign", "verify"]);
              genOp.oncomplete = function(e2) {
                var pair = e2.target.result;
                var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
                exportOp.oncomplete = function(e3) {
                  var pkcs8 = e3.target.result;
                  var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                  callback(null, {
                    privateKey,
                    publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                  });
                };
                exportOp.onerror = function(err) {
                  callback(err);
                };
              };
              genOp.onerror = function(err) {
                callback(err);
              };
              return;
            }
          } else {
            if (_detectNodeCrypto("generateKeyPairSync")) {
              var keypair = _crypto.generateKeyPairSync("rsa", {
                modulusLength: bits,
                publicExponent: e,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              });
              return {
                privateKey: pki.privateKeyFromPem(keypair.privateKey),
                publicKey: pki.publicKeyFromPem(keypair.publicKey)
              };
            }
          }
        }
        var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
        if (!callback) {
          pki.rsa.stepKeyPairGenerationState(state, 0);
          return state.keys;
        }
        _generateKeyPair(state, options, callback);
      };
      pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
        var key = {
          n,
          e
        };
        key.encrypt = function(data, scheme, schemeOptions) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSAES-PKCS1-V1_5";
          }
          if (scheme === "RSAES-PKCS1-V1_5") {
            scheme = {
              encode: function(m, key2, pub) {
                return _encodePkcs1_v1_5(m, key2, 2).getBytes();
              }
            };
          } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
            scheme = {
              encode: function(m, key2) {
                return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
              }
            };
          } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
            scheme = { encode: function(e3) {
              return e3;
            } };
          } else if (typeof scheme === "string") {
            throw new Error('Unsupported encryption scheme: "' + scheme + '".');
          }
          var e2 = scheme.encode(data, key, true);
          return pki.rsa.encrypt(e2, key, true);
        };
        key.verify = function(digest, signature, scheme) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSASSA-PKCS1-V1_5";
          }
          if (scheme === "RSASSA-PKCS1-V1_5") {
            scheme = {
              verify: function(digest2, d2) {
                d2 = _decodePkcs1_v1_5(d2, key, true);
                var obj = asn1.fromDer(d2);
                return digest2 === obj.value[1].value;
              }
            };
          } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
            scheme = {
              verify: function(digest2, d2) {
                d2 = _decodePkcs1_v1_5(d2, key, true);
                return digest2 === d2;
              }
            };
          }
          var d = pki.rsa.decrypt(signature, key, true, false);
          return scheme.verify(digest, d, key.n.bitLength());
        };
        return key;
      };
      pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
        var key = {
          n,
          e,
          d,
          p,
          q,
          dP,
          dQ,
          qInv
        };
        key.decrypt = function(data, scheme, schemeOptions) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSAES-PKCS1-V1_5";
          }
          var d2 = pki.rsa.decrypt(data, key, false, false);
          if (scheme === "RSAES-PKCS1-V1_5") {
            scheme = { decode: _decodePkcs1_v1_5 };
          } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
            scheme = {
              decode: function(d3, key2) {
                return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
              }
            };
          } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
            scheme = { decode: function(d3) {
              return d3;
            } };
          } else {
            throw new Error('Unsupported encryption scheme: "' + scheme + '".');
          }
          return scheme.decode(d2, key, false);
        };
        key.sign = function(md, scheme) {
          var bt = false;
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          }
          if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
            scheme = { encode: emsaPkcs1v15encode };
            bt = 1;
          } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
            scheme = { encode: function() {
              return md;
            } };
            bt = 1;
          }
          var d2 = scheme.encode(md, key.n.bitLength());
          return pki.rsa.encrypt(d2, key, bt);
        };
        return key;
      };
      pki.wrapRsaPrivateKey = function(rsaKey) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
        ]);
      };
      pki.privateKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
          obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
        }
        capture = {};
        errors = [];
        if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
          var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
          error.errors = errors;
          throw error;
        }
        var n, e, d, p, q, dP, dQ, qInv;
        n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
        e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
        d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
        p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
        q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
        dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
        dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
        qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
        return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
      };
      pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
        ]);
      };
      pki.publicKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
          var oid = asn1.derToOid(capture.publicKeyOid);
          if (oid !== pki.oids.rsaEncryption) {
            var error = new Error("Cannot read public key. Unknown OID.");
            error.oid = oid;
            throw error;
          }
          obj = capture.rsaPublicKey;
        }
        errors = [];
        if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
          var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
          error.errors = errors;
          throw error;
        }
        var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
        var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
        return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
      };
      pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
            pki.publicKeyToRSAPublicKey(key)
          ])
        ]);
      };
      pki.publicKeyToRSAPublicKey = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
        ]);
      };
      function _encodePkcs1_v1_5(m, key, bt) {
        var eb = forge.util.createBuffer();
        var k = Math.ceil(key.n.bitLength() / 8);
        if (m.length > k - 11) {
          var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
          error.length = m.length;
          error.max = k - 11;
          throw error;
        }
        eb.putByte(0);
        eb.putByte(bt);
        var padNum = k - 3 - m.length;
        var padByte;
        if (bt === 0 || bt === 1) {
          padByte = bt === 0 ? 0 : 255;
          for (var i = 0; i < padNum; ++i) {
            eb.putByte(padByte);
          }
        } else {
          while (padNum > 0) {
            var numZeros = 0;
            var padBytes = forge.random.getBytes(padNum);
            for (var i = 0; i < padNum; ++i) {
              padByte = padBytes.charCodeAt(i);
              if (padByte === 0) {
                ++numZeros;
              } else {
                eb.putByte(padByte);
              }
            }
            padNum = numZeros;
          }
        }
        eb.putByte(0);
        eb.putBytes(m);
        return eb;
      }
      function _decodePkcs1_v1_5(em, key, pub, ml) {
        var k = Math.ceil(key.n.bitLength() / 8);
        var eb = forge.util.createBuffer(em);
        var first = eb.getByte();
        var bt = eb.getByte();
        if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
          throw new Error("Encryption block is invalid.");
        }
        var padNum = 0;
        if (bt === 0) {
          padNum = k - 3 - ml;
          for (var i = 0; i < padNum; ++i) {
            if (eb.getByte() !== 0) {
              throw new Error("Encryption block is invalid.");
            }
          }
        } else if (bt === 1) {
          padNum = 0;
          while (eb.length() > 1) {
            if (eb.getByte() !== 255) {
              --eb.read;
              break;
            }
            ++padNum;
          }
        } else if (bt === 2) {
          padNum = 0;
          while (eb.length() > 1) {
            if (eb.getByte() === 0) {
              --eb.read;
              break;
            }
            ++padNum;
          }
        }
        var zero = eb.getByte();
        if (zero !== 0 || padNum !== k - 3 - eb.length()) {
          throw new Error("Encryption block is invalid.");
        }
        return eb.getBytes();
      }
      function _generateKeyPair(state, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var opts = {
          algorithm: {
            name: options.algorithm || "PRIMEINC",
            options: {
              workers: options.workers || 2,
              workLoad: options.workLoad || 100,
              workerScript: options.workerScript
            }
          }
        };
        if ("prng" in options) {
          opts.prng = options.prng;
        }
        generate();
        function generate() {
          getPrime(state.pBits, function(err, num) {
            if (err) {
              return callback(err);
            }
            state.p = num;
            if (state.q !== null) {
              return finish(err, state.q);
            }
            getPrime(state.qBits, finish);
          });
        }
        function getPrime(bits, callback2) {
          forge.prime.generateProbablePrime(bits, opts, callback2);
        }
        function finish(err, num) {
          if (err) {
            return callback(err);
          }
          state.q = num;
          if (state.p.compareTo(state.q) < 0) {
            var tmp = state.p;
            state.p = state.q;
            state.q = tmp;
          }
          if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.p = null;
            generate();
            return;
          }
          if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.q = null;
            getPrime(state.qBits, finish);
            return;
          }
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.p = state.q = null;
            generate();
            return;
          }
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() !== state.bits) {
            state.q = null;
            getPrime(state.qBits, finish);
            return;
          }
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
          callback(null, state.keys);
        }
      }
      function _bnToBytes(b) {
        var hex = b.toString(16);
        if (hex[0] >= "8") {
          hex = "00" + hex;
        }
        var bytes = forge.util.hexToBytes(hex);
        if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
          return bytes.substr(1);
        }
        return bytes;
      }
      function _getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
      function _detectNodeCrypto(fn) {
        return forge.util.isNodejs && typeof _crypto[fn] === "function";
      }
      function _detectSubtleCrypto(fn) {
        return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
      }
      function _detectSubtleMsCrypto(fn) {
        return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
      }
      function _intToUint8Array(x) {
        var bytes = forge.util.hexToBytes(x.toString(16));
        var buffer = new Uint8Array(bytes.length);
        for (var i = 0; i < bytes.length; ++i) {
          buffer[i] = bytes.charCodeAt(i);
        }
        return buffer;
      }
    }
  });

  // node_modules/node-forge/lib/pbe.js
  var require_pbe = __commonJS({
    "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_md();
      require_oids();
      require_pbkdf2();
      require_pem();
      require_random2();
      require_rc2();
      require_rsa();
      require_util();
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var asn1 = forge.asn1;
      var pki = forge.pki = forge.pki || {};
      module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
      var oids = pki.oids;
      var encryptedPrivateKeyValidator = {
        name: "EncryptedPrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encryptionOid"
          }, {
            name: "AlgorithmIdentifier.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "encryptionParams"
          }]
        }, {
          name: "EncryptedPrivateKeyInfo.encryptedData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encryptedData"
        }]
      };
      var PBES2AlgorithmsValidator = {
        name: "PBES2Algorithms",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc.oid",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "kdfOid"
          }, {
            name: "PBES2Algorithms.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.params.salt",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "kdfSalt"
            }, {
              name: "PBES2Algorithms.params.iterationCount",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "kdfIterationCount"
            }, {
              name: "PBES2Algorithms.params.keyLength",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              optional: true,
              capture: "keyLength"
            }, {
              name: "PBES2Algorithms.params.prf",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "PBES2Algorithms.params.prf.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "prfOid"
              }]
            }]
          }]
        }, {
          name: "PBES2Algorithms.encryptionScheme",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.encryptionScheme.oid",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encOid"
          }, {
            name: "PBES2Algorithms.encryptionScheme.iv",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "encIv"
          }]
        }]
      };
      var pkcs12PbeParamsValidator = {
        name: "pkcs-12PbeParams",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "pkcs-12PbeParams.salt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "salt"
        }, {
          name: "pkcs-12PbeParams.iterations",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "iterations"
        }]
      };
      pki.encryptPrivateKeyInfo = function(obj, password, options) {
        options = options || {};
        options.saltSize = options.saltSize || 8;
        options.count = options.count || 2048;
        options.algorithm = options.algorithm || "aes128";
        options.prfAlgorithm = options.prfAlgorithm || "sha1";
        var salt = forge.random.getBytesSync(options.saltSize);
        var count = options.count;
        var countBytes = asn1.integerToDer(count);
        var dkLen;
        var encryptionAlgorithm;
        var encryptedData;
        if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
          var ivLen, encOid, cipherFn;
          switch (options.algorithm) {
            case "aes128":
              dkLen = 16;
              ivLen = 16;
              encOid = oids["aes128-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes192":
              dkLen = 24;
              ivLen = 16;
              encOid = oids["aes192-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes256":
              dkLen = 32;
              ivLen = 16;
              encOid = oids["aes256-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "des":
              dkLen = 8;
              ivLen = 8;
              encOid = oids["desCBC"];
              cipherFn = forge.des.createEncryptionCipher;
              break;
            default:
              var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
              error.algorithm = options.algorithm;
              throw error;
          }
          var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
          var md = prfAlgorithmToMessageDigest(prfAlgorithm);
          var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
          var iv = forge.random.getBytesSync(ivLen);
          var cipher = cipherFn(dk);
          cipher.start(iv);
          cipher.update(asn1.toDer(obj));
          cipher.finish();
          encryptedData = cipher.output.getBytes();
          var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
          encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
                params
              ]),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
              ])
            ])
          ]);
        } else if (options.algorithm === "3des") {
          dkLen = 24;
          var saltBytes = new forge.util.ByteBuffer(salt);
          var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
          var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
          var cipher = forge.des.createEncryptionCipher(dk);
          cipher.start(iv);
          cipher.update(asn1.toDer(obj));
          cipher.finish();
          encryptedData = cipher.output.getBytes();
          encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
            ])
          ]);
        } else {
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          error.algorithm = options.algorithm;
          throw error;
        }
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          encryptionAlgorithm,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
        ]);
        return rval;
      };
      pki.decryptPrivateKeyInfo = function(obj, password) {
        var rval = null;
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
          var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.encryptionOid);
        var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
        var encrypted = forge.util.createBuffer(capture.encryptedData);
        cipher.update(encrypted);
        if (cipher.finish()) {
          rval = asn1.fromDer(cipher.output);
        }
        return rval;
      };
      pki.encryptedPrivateKeyToPem = function(epki, maxline) {
        var msg = {
          type: "ENCRYPTED PRIVATE KEY",
          body: asn1.toDer(epki).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.encryptedPrivateKeyFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "ENCRYPTED PRIVATE KEY") {
          var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
        }
        return asn1.fromDer(msg.body);
      };
      pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
        options = options || {};
        if (!options.legacy) {
          var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
          rval = pki.encryptPrivateKeyInfo(rval, password, options);
          return pki.encryptedPrivateKeyToPem(rval);
        }
        var algorithm;
        var iv;
        var dkLen;
        var cipherFn;
        switch (options.algorithm) {
          case "aes128":
            algorithm = "AES-128-CBC";
            dkLen = 16;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            algorithm = "AES-192-CBC";
            dkLen = 24;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            algorithm = "AES-256-CBC";
            dkLen = 32;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "3des":
            algorithm = "DES-EDE3-CBC";
            dkLen = 24;
            iv = forge.random.getBytesSync(8);
            cipherFn = forge.des.createEncryptionCipher;
            break;
          case "des":
            algorithm = "DES-CBC";
            dkLen = 8;
            iv = forge.random.getBytesSync(8);
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
            error.algorithm = options.algorithm;
            throw error;
        }
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
        cipher.finish();
        var msg = {
          type: "RSA PRIVATE KEY",
          procType: {
            version: "4",
            type: "ENCRYPTED"
          },
          dekInfo: {
            algorithm,
            parameters: forge.util.bytesToHex(iv).toUpperCase()
          },
          body: cipher.output.getBytes()
        };
        return forge.pem.encode(msg);
      };
      pki.decryptRsaPrivateKey = function(pem, password) {
        var rval = null;
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
          var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
          error.headerType = error;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          var dkLen;
          var cipherFn;
          switch (msg.dekInfo.algorithm) {
            case "DES-CBC":
              dkLen = 8;
              cipherFn = forge.des.createDecryptionCipher;
              break;
            case "DES-EDE3-CBC":
              dkLen = 24;
              cipherFn = forge.des.createDecryptionCipher;
              break;
            case "AES-128-CBC":
              dkLen = 16;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "AES-192-CBC":
              dkLen = 24;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "AES-256-CBC":
              dkLen = 32;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "RC2-40-CBC":
              dkLen = 5;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 40);
              };
              break;
            case "RC2-64-CBC":
              dkLen = 8;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 64);
              };
              break;
            case "RC2-128-CBC":
              dkLen = 16;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 128);
              };
              break;
            default:
              var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
              error.algorithm = msg.dekInfo.algorithm;
              throw error;
          }
          var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
          var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
          var cipher = cipherFn(dk);
          cipher.start(iv);
          cipher.update(forge.util.createBuffer(msg.body));
          if (cipher.finish()) {
            rval = cipher.output.getBytes();
          } else {
            return rval;
          }
        } else {
          rval = msg.body;
        }
        if (msg.type === "ENCRYPTED PRIVATE KEY") {
          rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
        } else {
          rval = asn1.fromDer(rval);
        }
        if (rval !== null) {
          rval = pki.privateKeyFromAsn1(rval);
        }
        return rval;
      };
      pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
        var j, l;
        if (typeof md === "undefined" || md === null) {
          if (!("sha1" in forge.md)) {
            throw new Error('"sha1" hash algorithm unavailable.');
          }
          md = forge.md.sha1.create();
        }
        var u = md.digestLength;
        var v = md.blockLength;
        var result = new forge.util.ByteBuffer();
        var passBuf = new forge.util.ByteBuffer();
        if (password !== null && password !== void 0) {
          for (l = 0; l < password.length; l++) {
            passBuf.putInt16(password.charCodeAt(l));
          }
          passBuf.putInt16(0);
        }
        var p = passBuf.length();
        var s = salt.length();
        var D = new forge.util.ByteBuffer();
        D.fillWithByte(id, v);
        var Slen = v * Math.ceil(s / v);
        var S = new forge.util.ByteBuffer();
        for (l = 0; l < Slen; l++) {
          S.putByte(salt.at(l % s));
        }
        var Plen = v * Math.ceil(p / v);
        var P = new forge.util.ByteBuffer();
        for (l = 0; l < Plen; l++) {
          P.putByte(passBuf.at(l % p));
        }
        var I = S;
        I.putBuffer(P);
        var c = Math.ceil(n / u);
        for (var i = 1; i <= c; i++) {
          var buf = new forge.util.ByteBuffer();
          buf.putBytes(D.bytes());
          buf.putBytes(I.bytes());
          for (var round = 0; round < iter; round++) {
            md.start();
            md.update(buf.getBytes());
            buf = md.digest();
          }
          var B = new forge.util.ByteBuffer();
          for (l = 0; l < v; l++) {
            B.putByte(buf.at(l % u));
          }
          var k = Math.ceil(s / v) + Math.ceil(p / v);
          var Inew = new forge.util.ByteBuffer();
          for (j = 0; j < k; j++) {
            var chunk = new forge.util.ByteBuffer(I.getBytes(v));
            var x = 511;
            for (l = B.length() - 1; l >= 0; l--) {
              x = x >> 8;
              x += B.at(l) + chunk.at(l);
              chunk.setAt(l, x & 255);
            }
            Inew.putBuffer(chunk);
          }
          I = Inew;
          result.putBuffer(buf);
        }
        result.truncate(result.length() - n);
        return result;
      };
      pki.pbe.getCipher = function(oid, params, password) {
        switch (oid) {
          case pki.oids["pkcs5PBES2"]:
            return pki.pbe.getCipherForPBES2(oid, params, password);
          case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
            return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
          default:
            var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
            error.oid = oid;
            error.supportedOids = [
              "pkcs5PBES2",
              "pbeWithSHAAnd3-KeyTripleDES-CBC",
              "pbewithSHAAnd40BitRC2-CBC"
            ];
            throw error;
        }
      };
      pki.pbe.getCipherForPBES2 = function(oid, params, password) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
          var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        oid = asn1.derToOid(capture.kdfOid);
        if (oid !== pki.oids["pkcs5PBKDF2"]) {
          var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
          error.oid = oid;
          error.supportedOids = ["pkcs5PBKDF2"];
          throw error;
        }
        oid = asn1.derToOid(capture.encOid);
        if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
          var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
          error.oid = oid;
          error.supportedOids = [
            "aes128-CBC",
            "aes192-CBC",
            "aes256-CBC",
            "des-EDE3-CBC",
            "desCBC"
          ];
          throw error;
        }
        var salt = capture.kdfSalt;
        var count = forge.util.createBuffer(capture.kdfIterationCount);
        count = count.getInt(count.length() << 3);
        var dkLen;
        var cipherFn;
        switch (pki.oids[oid]) {
          case "aes128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "aes192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "aes256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "des-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "desCBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
        }
        var md = prfOidToMessageDigest(capture.prfOid);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = capture.encIv;
        var cipher = cipherFn(dk);
        cipher.start(iv);
        return cipher;
      };
      pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
          var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        var salt = forge.util.createBuffer(capture.salt);
        var count = forge.util.createBuffer(capture.iterations);
        count = count.getInt(count.length() << 3);
        var dkLen, dIvLen, cipherFn;
        switch (oid) {
          case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            dkLen = 24;
            dIvLen = 8;
            cipherFn = forge.des.startDecrypting;
            break;
          case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
            dkLen = 5;
            dIvLen = 8;
            cipherFn = function(key2, iv2) {
              var cipher = forge.rc2.createDecryptionCipher(key2, 40);
              cipher.start(iv2, null);
              return cipher;
            };
            break;
          default:
            var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
            error.oid = oid;
            throw error;
        }
        var md = prfOidToMessageDigest(capture.prfOid);
        var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
        md.start();
        var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
        return cipherFn(key, iv);
      };
      pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
        if (typeof md === "undefined" || md === null) {
          if (!("md5" in forge.md)) {
            throw new Error('"md5" hash algorithm unavailable.');
          }
          md = forge.md.md5.create();
        }
        if (salt === null) {
          salt = "";
        }
        var digests = [hash(md, password + salt)];
        for (var length2 = 16, i = 1; length2 < dkLen; ++i, length2 += 16) {
          digests.push(hash(md, digests[i - 1] + password + salt));
        }
        return digests.join("").substr(0, dkLen);
      };
      function hash(md, bytes) {
        return md.start().update(bytes).digest().getBytes();
      }
      function prfOidToMessageDigest(prfOid) {
        var prfAlgorithm;
        if (!prfOid) {
          prfAlgorithm = "hmacWithSHA1";
        } else {
          prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
          if (!prfAlgorithm) {
            var error = new Error("Unsupported PRF OID.");
            error.oid = prfOid;
            error.supported = [
              "hmacWithSHA1",
              "hmacWithSHA224",
              "hmacWithSHA256",
              "hmacWithSHA384",
              "hmacWithSHA512"
            ];
            throw error;
          }
        }
        return prfAlgorithmToMessageDigest(prfAlgorithm);
      }
      function prfAlgorithmToMessageDigest(prfAlgorithm) {
        var factory = forge.md;
        switch (prfAlgorithm) {
          case "hmacWithSHA224":
            factory = forge.md.sha512;
          case "hmacWithSHA1":
          case "hmacWithSHA256":
          case "hmacWithSHA384":
          case "hmacWithSHA512":
            prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
            break;
          default:
            var error = new Error("Unsupported PRF algorithm.");
            error.algorithm = prfAlgorithm;
            error.supported = [
              "hmacWithSHA1",
              "hmacWithSHA224",
              "hmacWithSHA256",
              "hmacWithSHA384",
              "hmacWithSHA512"
            ];
            throw error;
        }
        if (!factory || !(prfAlgorithm in factory)) {
          throw new Error("Unknown hash algorithm: " + prfAlgorithm);
        }
        return factory[prfAlgorithm].create();
      }
      function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
        var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
        ]);
        if (prfAlgorithm !== "hmacWithSHA1") {
          params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
        }
        return params;
      }
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/webcrypto.js
  var require_webcrypto = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/webcrypto.js"(exports2) {
      "use strict";
      exports2.get = (win = globalThis) => {
        const nativeCrypto = win.crypto;
        if (!nativeCrypto || !nativeCrypto.subtle) {
          throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
        }
        return nativeCrypto;
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
  var require_aes_gcm_browser = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"(exports2, module2) {
      "use strict";
      var { concat: concat2 } = (init_concat(), concat_exports);
      var { fromString: fromString3 } = (init_from_string(), from_string_exports);
      var webcrypto = require_webcrypto();
      function create3({
        algorithm = "AES-GCM",
        nonceLength = 12,
        keyLength = 16,
        digest = "SHA-256",
        saltLength = 16,
        iterations = 32767
      } = {}) {
        const crypto2 = webcrypto.get();
        keyLength *= 8;
        async function encrypt(data, password) {
          const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
          const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
          const aesGcm = { name: algorithm, iv: nonce };
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
          const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
          const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
          const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
          return concat2([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
        }
        async function decrypt(data, password) {
          const salt = data.slice(0, saltLength);
          const nonce = data.slice(saltLength, saltLength + nonceLength);
          const ciphertext = data.slice(saltLength + nonceLength);
          const aesGcm = { name: algorithm, iv: nonce };
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
          const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
          const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
          const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
          return new Uint8Array(plaintext);
        }
        return {
          encrypt,
          decrypt
        };
      }
      module2.exports = {
        create: create3
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/importer.js
  var require_importer = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/importer.js"(exports2, module2) {
      "use strict";
      var { base64: base642 } = (init_base64(), base64_exports);
      var ciphers = require_aes_gcm_browser();
      module2.exports = {
        import: async function(privateKey, password) {
          const encryptedKey = base642.decode(privateKey);
          const cipher = ciphers.create();
          return await cipher.decrypt(encryptedKey, password);
        }
      };
    }
  });

  // node_modules/node-forge/lib/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
      var forge = require_forge();
      require_md();
      require_util();
      var sha5122 = module2.exports = forge.sha512 = forge.sha512 || {};
      forge.md.sha512 = forge.md.algorithms.sha512 = sha5122;
      var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
      sha384.create = function() {
        return sha5122.create("SHA-384");
      };
      forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
      forge.sha512.sha256 = forge.sha512.sha256 || {
        create: function() {
          return sha5122.create("SHA-512/256");
        }
      };
      forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
      forge.sha512.sha224 = forge.sha512.sha224 || {
        create: function() {
          return sha5122.create("SHA-512/224");
        }
      };
      forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
      sha5122.create = function(algorithm) {
        if (!_initialized) {
          _init();
        }
        if (typeof algorithm === "undefined") {
          algorithm = "SHA-512";
        }
        if (!(algorithm in _states)) {
          throw new Error("Invalid SHA-512 algorithm: " + algorithm);
        }
        var _state = _states[algorithm];
        var _h = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(80);
        for (var wi = 0; wi < 80; ++wi) {
          _w[wi] = new Array(2);
        }
        var digestLength = 64;
        switch (algorithm) {
          case "SHA-384":
            digestLength = 48;
            break;
          case "SHA-512/256":
            digestLength = 32;
            break;
          case "SHA-512/224":
            digestLength = 28;
            break;
        }
        var md = {
          algorithm: algorithm.replace("-", "").toLowerCase(),
          blockLength: 128,
          digestLength,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 16
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength128 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _h = new Array(_state.length);
          for (var i = 0; i < _state.length; ++i) {
            _h[i] = _state[i].slice(0);
          }
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_h, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var h = new Array(_h.length);
          for (var i = 0; i < _h.length; ++i) {
            h[i] = _h[i].slice(0);
          }
          _update(h, _w, finalBlock);
          var rval = forge.util.createBuffer();
          var hlen;
          if (algorithm === "SHA-512") {
            hlen = h.length;
          } else if (algorithm === "SHA-384") {
            hlen = h.length - 2;
          } else {
            hlen = h.length - 4;
          }
          for (var i = 0; i < hlen; ++i) {
            rval.putInt32(h[i][0]);
            if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
              rval.putInt32(h[i][1]);
            }
          }
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      var _k = null;
      var _states = null;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 128);
        _k = [
          [1116352408, 3609767458],
          [1899447441, 602891725],
          [3049323471, 3964484399],
          [3921009573, 2173295548],
          [961987163, 4081628472],
          [1508970993, 3053834265],
          [2453635748, 2937671579],
          [2870763221, 3664609560],
          [3624381080, 2734883394],
          [310598401, 1164996542],
          [607225278, 1323610764],
          [1426881987, 3590304994],
          [1925078388, 4068182383],
          [2162078206, 991336113],
          [2614888103, 633803317],
          [3248222580, 3479774868],
          [3835390401, 2666613458],
          [4022224774, 944711139],
          [264347078, 2341262773],
          [604807628, 2007800933],
          [770255983, 1495990901],
          [1249150122, 1856431235],
          [1555081692, 3175218132],
          [1996064986, 2198950837],
          [2554220882, 3999719339],
          [2821834349, 766784016],
          [2952996808, 2566594879],
          [3210313671, 3203337956],
          [3336571891, 1034457026],
          [3584528711, 2466948901],
          [113926993, 3758326383],
          [338241895, 168717936],
          [666307205, 1188179964],
          [773529912, 1546045734],
          [1294757372, 1522805485],
          [1396182291, 2643833823],
          [1695183700, 2343527390],
          [1986661051, 1014477480],
          [2177026350, 1206759142],
          [2456956037, 344077627],
          [2730485921, 1290863460],
          [2820302411, 3158454273],
          [3259730800, 3505952657],
          [3345764771, 106217008],
          [3516065817, 3606008344],
          [3600352804, 1432725776],
          [4094571909, 1467031594],
          [275423344, 851169720],
          [430227734, 3100823752],
          [506948616, 1363258195],
          [659060556, 3750685593],
          [883997877, 3785050280],
          [958139571, 3318307427],
          [1322822218, 3812723403],
          [1537002063, 2003034995],
          [1747873779, 3602036899],
          [1955562222, 1575990012],
          [2024104815, 1125592928],
          [2227730452, 2716904306],
          [2361852424, 442776044],
          [2428436474, 593698344],
          [2756734187, 3733110249],
          [3204031479, 2999351573],
          [3329325298, 3815920427],
          [3391569614, 3928383900],
          [3515267271, 566280711],
          [3940187606, 3454069534],
          [4118630271, 4000239992],
          [116418474, 1914138554],
          [174292421, 2731055270],
          [289380356, 3203993006],
          [460393269, 320620315],
          [685471733, 587496836],
          [852142971, 1086792851],
          [1017036298, 365543100],
          [1126000580, 2618297676],
          [1288033470, 3409855158],
          [1501505948, 4234509866],
          [1607167915, 987167468],
          [1816402316, 1246189591]
        ];
        _states = {};
        _states["SHA-512"] = [
          [1779033703, 4089235720],
          [3144134277, 2227873595],
          [1013904242, 4271175723],
          [2773480762, 1595750129],
          [1359893119, 2917565137],
          [2600822924, 725511199],
          [528734635, 4215389547],
          [1541459225, 327033209]
        ];
        _states["SHA-384"] = [
          [3418070365, 3238371032],
          [1654270250, 914150663],
          [2438529370, 812702999],
          [355462360, 4144912697],
          [1731405415, 4290775857],
          [2394180231, 1750603025],
          [3675008525, 1694076839],
          [1203062813, 3204075428]
        ];
        _states["SHA-512/256"] = [
          [573645204, 4230739756],
          [2673172387, 3360449730],
          [596883563, 1867755857],
          [2520282905, 1497426621],
          [2519219938, 2827943907],
          [3193839141, 1401305490],
          [721525244, 746961066],
          [246885852, 2177182882]
        ];
        _states["SHA-512/224"] = [
          [2352822216, 424955298],
          [1944164710, 2312950998],
          [502970286, 855612546],
          [1738396948, 1479516111],
          [258812777, 2077511080],
          [2011393907, 79989058],
          [1067287976, 1780299464],
          [286451373, 2446758561]
        ];
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t1_hi, t1_lo;
        var t2_hi, t2_lo;
        var s0_hi, s0_lo;
        var s1_hi, s1_lo;
        var ch_hi, ch_lo;
        var maj_hi, maj_lo;
        var a_hi, a_lo;
        var b_hi, b_lo;
        var c_hi, c_lo;
        var d_hi, d_lo;
        var e_hi, e_lo;
        var f_hi, f_lo;
        var g_hi, g_lo;
        var h_hi, h_lo;
        var i, hi, lo, w2, w7, w15, w16;
        var len = bytes.length();
        while (len >= 128) {
          for (i = 0; i < 16; ++i) {
            w[i][0] = bytes.getInt32() >>> 0;
            w[i][1] = bytes.getInt32() >>> 0;
          }
          for (; i < 80; ++i) {
            w2 = w[i - 2];
            hi = w2[0];
            lo = w2[1];
            t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
            t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
            w15 = w[i - 15];
            hi = w15[0];
            lo = w15[1];
            t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
            t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
            w7 = w[i - 7];
            w16 = w[i - 16];
            lo = t1_lo + w7[1] + t2_lo + w16[1];
            w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
            w[i][1] = lo >>> 0;
          }
          a_hi = s[0][0];
          a_lo = s[0][1];
          b_hi = s[1][0];
          b_lo = s[1][1];
          c_hi = s[2][0];
          c_lo = s[2][1];
          d_hi = s[3][0];
          d_lo = s[3][1];
          e_hi = s[4][0];
          e_lo = s[4][1];
          f_hi = s[5][0];
          f_lo = s[5][1];
          g_hi = s[6][0];
          g_lo = s[6][1];
          h_hi = s[7][0];
          h_lo = s[7][1];
          for (i = 0; i < 80; ++i) {
            s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
            s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
            ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
            ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
            s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
            s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
            maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
            maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
            lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
            t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
            t1_lo = lo >>> 0;
            lo = s0_lo + maj_lo;
            t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
            t2_lo = lo >>> 0;
            h_hi = g_hi;
            h_lo = g_lo;
            g_hi = f_hi;
            g_lo = f_lo;
            f_hi = e_hi;
            f_lo = e_lo;
            lo = d_lo + t1_lo;
            e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
            e_lo = lo >>> 0;
            d_hi = c_hi;
            d_lo = c_lo;
            c_hi = b_hi;
            c_lo = b_lo;
            b_hi = a_hi;
            b_lo = a_lo;
            lo = t1_lo + t2_lo;
            a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
            a_lo = lo >>> 0;
          }
          lo = s[0][1] + a_lo;
          s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[0][1] = lo >>> 0;
          lo = s[1][1] + b_lo;
          s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[1][1] = lo >>> 0;
          lo = s[2][1] + c_lo;
          s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[2][1] = lo >>> 0;
          lo = s[3][1] + d_lo;
          s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[3][1] = lo >>> 0;
          lo = s[4][1] + e_lo;
          s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[4][1] = lo >>> 0;
          lo = s[5][1] + f_lo;
          s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[5][1] = lo >>> 0;
          lo = s[6][1] + g_lo;
          s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[6][1] = lo >>> 0;
          lo = s[7][1] + h_lo;
          s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[7][1] = lo >>> 0;
          len -= 128;
        }
      }
    }
  });

  // node_modules/iso-random-stream/src/random.browser.js
  var require_random_browser = __commonJS({
    "node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
      "use strict";
      var MAX_BYTES = 65536;
      function randomBytes(size) {
        const bytes = new Uint8Array(size);
        let generated = 0;
        if (size > 0) {
          if (size > MAX_BYTES) {
            while (generated < size) {
              if (generated + MAX_BYTES > size) {
                crypto.getRandomValues(bytes.subarray(generated, generated + (size - generated)));
                generated += size - generated;
              } else {
                crypto.getRandomValues(bytes.subarray(generated, generated + MAX_BYTES));
                generated += MAX_BYTES;
              }
            }
          } else {
            crypto.getRandomValues(bytes);
          }
        }
        return bytes;
      }
      module2.exports = randomBytes;
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/random-bytes.js
  var require_random_bytes = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/random-bytes.js"(exports2, module2) {
      "use strict";
      var randomBytes = require_random_browser();
      var errcode = require_err_code();
      module2.exports = function(length2) {
        if (isNaN(length2) || length2 <= 0) {
          throw errcode(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
        }
        return randomBytes(length2);
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/util.js
  var require_util2 = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/util.js"(exports2) {
      "use strict";
      require_util();
      require_jsbn();
      var forge = require_forge();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      exports2.bigIntegerToUintBase64url = (num, len) => {
        let buf = Uint8Array.from(num.abs().toByteArray());
        buf = buf[0] === 0 ? buf.slice(1) : buf;
        if (len != null) {
          if (buf.length > len)
            throw new Error("byte array longer than desired length");
          buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
        }
        return uint8ArrayToString(buf, "base64url");
      };
      exports2.base64urlToBigInteger = (str) => {
        const buf = exports2.base64urlToBuffer(str);
        return new forge.jsbn.BigInteger(uint8ArrayToString(buf, "base16"), 16);
      };
      exports2.base64urlToBuffer = (str, len) => {
        let buf = uint8ArrayFromString(str, "base64urlpad");
        if (len != null) {
          if (buf.length > len)
            throw new Error("byte array longer than desired length");
          buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
        }
        return buf;
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-utils.js
  var require_rsa_utils = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-utils.js"(exports2) {
      "use strict";
      require_asn1();
      require_rsa();
      var forge = require_forge();
      var { bigIntegerToUintBase64url, base64urlToBigInteger } = require_util2();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      exports2.pkcs1ToJwk = function(bytes) {
        const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
        const privateKey = forge.pki.privateKeyFromAsn1(asn1);
        return {
          kty: "RSA",
          n: bigIntegerToUintBase64url(privateKey.n),
          e: bigIntegerToUintBase64url(privateKey.e),
          d: bigIntegerToUintBase64url(privateKey.d),
          p: bigIntegerToUintBase64url(privateKey.p),
          q: bigIntegerToUintBase64url(privateKey.q),
          dp: bigIntegerToUintBase64url(privateKey.dP),
          dq: bigIntegerToUintBase64url(privateKey.dQ),
          qi: bigIntegerToUintBase64url(privateKey.qInv),
          alg: "RS256",
          kid: "2011-04-29"
        };
      };
      exports2.jwkToPkcs1 = function(jwk) {
        const asn1 = forge.pki.privateKeyToAsn1({
          n: base64urlToBigInteger(jwk.n),
          e: base64urlToBigInteger(jwk.e),
          d: base64urlToBigInteger(jwk.d),
          p: base64urlToBigInteger(jwk.p),
          q: base64urlToBigInteger(jwk.q),
          dP: base64urlToBigInteger(jwk.dp),
          dQ: base64urlToBigInteger(jwk.dq),
          qInv: base64urlToBigInteger(jwk.qi)
        });
        return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
      };
      exports2.pkixToJwk = function(bytes) {
        const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
        const publicKey = forge.pki.publicKeyFromAsn1(asn1);
        return {
          kty: "RSA",
          n: bigIntegerToUintBase64url(publicKey.n),
          e: bigIntegerToUintBase64url(publicKey.e),
          alg: "RS256",
          kid: "2011-04-29"
        };
      };
      exports2.jwkToPkix = function(jwk) {
        const asn1 = forge.pki.publicKeyToAsn1({
          n: base64urlToBigInteger(jwk.n),
          e: base64urlToBigInteger(jwk.e)
        });
        return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/jwk2pem.js
  var require_jwk2pem = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/jwk2pem.js"(exports2, module2) {
      "use strict";
      require_rsa();
      var forge = require_forge();
      var { base64urlToBigInteger } = require_util2();
      function convert(key, types) {
        return types.map((t) => base64urlToBigInteger(key[t]));
      }
      function jwk2priv(key) {
        return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
      }
      function jwk2pub(key) {
        return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
      }
      module2.exports = {
        jwk2pub,
        jwk2priv
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-browser.js
  var require_rsa_browser = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-browser.js"(exports2) {
      "use strict";
      var webcrypto = require_webcrypto();
      var randomBytes = require_random_bytes();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      exports2.utils = require_rsa_utils();
      exports2.generateKey = async function(bits) {
        const pair = await webcrypto.get().subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]);
        const keys = await exportKey(pair);
        return {
          privateKey: keys[0],
          publicKey: keys[1]
        };
      };
      exports2.unmarshalPrivateKey = async function(key) {
        const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["sign"]);
        const pair = [
          privateKey,
          await derivePublicFromPrivate(key)
        ];
        const keys = await exportKey({
          privateKey: pair[0],
          publicKey: pair[1]
        });
        return {
          privateKey: keys[0],
          publicKey: keys[1]
        };
      };
      exports2.getRandomValues = randomBytes;
      exports2.hashAndSign = async function(key, msg) {
        const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, false, ["sign"]);
        const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
        return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
      };
      exports2.hashAndVerify = async function(key, sig, msg) {
        const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, false, ["verify"]);
        return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
      };
      function exportKey(pair) {
        return Promise.all([
          webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
          webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
        ]);
      }
      function derivePublicFromPrivate(jwKey) {
        return webcrypto.get().subtle.importKey("jwk", {
          kty: jwKey.kty,
          n: jwKey.n,
          e: jwKey.e
        }, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["verify"]);
      }
      var { jwk2pub, jwk2priv } = require_jwk2pem();
      function convertKey(key, pub, msg, handle) {
        const fkey = pub ? jwk2pub(key) : jwk2priv(key);
        const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
        const fomsg = handle(fmsg, fkey);
        return uint8ArrayFromString(fomsg, "ascii");
      }
      exports2.encrypt = function(key, msg) {
        return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
      };
      exports2.decrypt = function(key, msg) {
        return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/exporter.js
  var require_exporter = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/exporter.js"(exports2, module2) {
      "use strict";
      var { base64: base642 } = (init_base64(), base64_exports);
      var ciphers = require_aes_gcm_browser();
      module2.exports = {
        export: async function(privateKey, password) {
          const cipher = ciphers.create();
          const encryptedKey = await cipher.encrypt(privateKey, password);
          return base642.encode(encryptedKey);
        }
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-class.js
  var require_rsa_class = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/rsa-class.js"(exports2, module2) {
      "use strict";
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      require_sha512();
      var forge = require_forge();
      var crypto2 = require_rsa_browser();
      var pbm = require_keys();
      var exporter = require_exporter();
      var RsaPublicKey = class {
        constructor(key) {
          this._key = key;
        }
        async verify(data, sig) {
          return crypto2.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return crypto2.utils.jwkToPkix(this._key);
        }
        get bytes() {
          return pbm.PublicKey.encode({
            Type: pbm.KeyType.RSA,
            Data: this.marshal()
          }).finish();
        }
        encrypt(bytes) {
          return crypto2.encrypt(this._key, bytes);
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
      };
      var RsaPrivateKey = class {
        constructor(key, publicKey) {
          this._key = key;
          this._publicKey = publicKey;
        }
        genSecret() {
          return crypto2.getRandomValues(16);
        }
        async sign(message) {
          return crypto2.hashAndSign(this._key, message);
        }
        get public() {
          if (!this._publicKey) {
            throw errcode(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
          }
          return new RsaPublicKey(this._publicKey);
        }
        decrypt(bytes) {
          return crypto2.decrypt(this._key, bytes);
        }
        marshal() {
          return crypto2.utils.jwkToPkcs1(this._key);
        }
        get bytes() {
          return pbm.PrivateKey.encode({
            Type: pbm.KeyType.RSA,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
        async id() {
          const hash = await this.public.hash();
          return uint8ArrayToString(hash, "base58btc");
        }
        async export(password, format = "pkcs-8") {
          if (format === "pkcs-8") {
            const buffer = new forge.util.ByteBuffer(this.marshal());
            const asn1 = forge.asn1.fromDer(buffer);
            const privateKey = forge.pki.privateKeyFromAsn1(asn1);
            const options = {
              algorithm: "aes256",
              count: 1e4,
              saltSize: 128 / 8,
              prfAlgorithm: "sha512"
            };
            return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
          } else if (format === "libp2p-key") {
            return exporter.export(this.bytes, password);
          } else {
            throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      };
      async function unmarshalRsaPrivateKey(bytes) {
        const jwk = crypto2.utils.pkcs1ToJwk(bytes);
        const keys = await crypto2.unmarshalPrivateKey(jwk);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      function unmarshalRsaPublicKey(bytes) {
        const jwk = crypto2.utils.pkixToJwk(bytes);
        return new RsaPublicKey(jwk);
      }
      async function fromJwk(jwk) {
        const keys = await crypto2.unmarshalPrivateKey(jwk);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      async function generateKeyPair(bits) {
        const keys = await crypto2.generateKey(bits);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      module2.exports = {
        RsaPublicKey,
        RsaPrivateKey,
        unmarshalRsaPublicKey,
        unmarshalRsaPrivateKey,
        generateKeyPair,
        fromJwk
      };
    }
  });

  // node_modules/@noble/ed25519/index.js
  var require_ed25519 = __commonJS({
    "node_modules/@noble/ed25519/index.js"(exports2, module2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.utils = exports2.verify = exports2.sign = exports2.getPublicKey = exports2.SignResult = exports2.Signature = exports2.Point = exports2.ExtendedPoint = exports2.CURVE = void 0;
      var CURVE = {
        a: -1n,
        d: 37095705934669439343138083508754565189542113879843219016388785533085940283555n,
        P: 2n ** 255n - 19n,
        n: 2n ** 252n + 27742317777372353535851937790883648493n,
        h: 8n,
        Gx: 15112221349535400772501151409588531511454012693041857206046113283949847762202n,
        Gy: 46316835694926478169428394003475163141307993866256225615783033603165251855960n
      };
      exports2.CURVE = CURVE;
      var B32 = 32;
      var SQRT_M1 = 19681161376707505956807079304988542015446066515923890162744021073123829784752n;
      var SQRT_AD_MINUS_ONE = 25063068953384623474111414158702152701244531502492656460079210482610430750235n;
      var INVSQRT_A_MINUS_D = 54469307008909316920995813868745141605393597292927456921205312896311721017578n;
      var ONE_MINUS_D_SQ = 1159843021668779879193775521855586647937357759715417654439879720876111806838n;
      var D_MINUS_ONE_SQ = 40440834346308536858101042469323190826248399146238708352240133220865137265952n;
      var ExtendedPoint = class {
        constructor(x, y, z, t) {
          this.x = x;
          this.y = y;
          this.z = z;
          this.t = t;
        }
        static fromAffine(p) {
          if (!(p instanceof Point)) {
            throw new TypeError("ExtendedPoint#fromAffine: expected Point");
          }
          if (p.equals(Point.ZERO))
            return ExtendedPoint.ZERO;
          return new ExtendedPoint(p.x, p.y, 1n, mod2(p.x * p.y));
        }
        static toAffineBatch(points) {
          const toInv = invertBatch(points.map((p) => p.z));
          return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
          return this.toAffineBatch(points).map(this.fromAffine);
        }
        static fromRistrettoHash(hash) {
          const r1 = bytes255ToNumberLE(hash.slice(0, B32));
          const R1 = this.calcElligatorRistrettoMap(r1);
          const r2 = bytes255ToNumberLE(hash.slice(B32, B32 * 2));
          const R2 = this.calcElligatorRistrettoMap(r2);
          return R1.add(R2);
        }
        static calcElligatorRistrettoMap(r0) {
          const { d } = CURVE;
          const r = mod2(SQRT_M1 * r0 * r0);
          const Ns = mod2((r + 1n) * ONE_MINUS_D_SQ);
          let c = -1n;
          const D = mod2((c - d * r) * mod2(r + d));
          let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
          let s_ = mod2(s * r0);
          if (!edIsNegative(s_))
            s_ = mod2(-s_);
          if (!Ns_D_is_sq)
            s = s_;
          if (!Ns_D_is_sq)
            c = r;
          const Nt = mod2(c * (r - 1n) * D_MINUS_ONE_SQ - D);
          const s2 = s * s;
          const W0 = mod2((s + s) * D);
          const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);
          const W2 = mod2(1n - s2);
          const W3 = mod2(1n + s2);
          return new ExtendedPoint(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));
        }
        static fromRistrettoBytes(bytes) {
          const { a, d } = CURVE;
          const emsg = "ExtendedPoint.fromRistrettoBytes: Cannot convert bytes to Ristretto Point";
          const s = bytes255ToNumberLE(bytes);
          if (!equalBytes(numberToBytesPadded(s, B32), bytes) || edIsNegative(s))
            throw new Error(emsg);
          const s2 = mod2(s * s);
          const u1 = mod2(1n + a * s2);
          const u2 = mod2(1n - a * s2);
          const u1_2 = mod2(u1 * u1);
          const u2_2 = mod2(u2 * u2);
          const v = mod2(a * d * u1_2 - u2_2);
          const { isValid, value: I } = invertSqrt(mod2(v * u2_2));
          const Dx = mod2(I * u2);
          const Dy = mod2(I * Dx * v);
          let x = mod2((s + s) * Dx);
          if (edIsNegative(x))
            x = mod2(-x);
          const y = mod2(u1 * Dy);
          const t = mod2(x * y);
          if (!isValid || edIsNegative(t) || y === 0n)
            throw new Error(emsg);
          return new ExtendedPoint(x, y, 1n, t);
        }
        toRistrettoBytes() {
          let { x, y, z, t } = this;
          const u1 = mod2((z + y) * (z - y));
          const u2 = mod2(x * y);
          const { value: invsqrt } = invertSqrt(mod2(u1 * u2 ** 2n));
          const D1 = mod2(invsqrt * u1);
          const D2 = mod2(invsqrt * u2);
          const zInv = mod2(D1 * D2 * t);
          let D;
          if (edIsNegative(t * zInv)) {
            [x, y] = [mod2(y * SQRT_M1), mod2(x * SQRT_M1)];
            D = mod2(D1 * INVSQRT_A_MINUS_D);
          } else {
            D = D2;
          }
          if (edIsNegative(x * zInv))
            y = mod2(-y);
          let s = mod2((z - y) * D);
          if (edIsNegative(s))
            s = mod2(-s);
          return numberToBytesPadded(s, B32);
        }
        equals(other) {
          const a = this;
          const b = other;
          const [T1, T2, Z1, Z2] = [a.t, b.t, a.z, b.z];
          return mod2(T1 * Z2) === mod2(T2 * Z1);
        }
        negate() {
          return new ExtendedPoint(mod2(-this.x), this.y, this.z, mod2(-this.t));
        }
        double() {
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const { a } = CURVE;
          const A = mod2(X1 ** 2n);
          const B = mod2(Y1 ** 2n);
          const C = mod2(2n * Z1 ** 2n);
          const D = mod2(a * A);
          const E = mod2((X1 + Y1) ** 2n - A - B);
          const G = mod2(D + B);
          const F = mod2(G - C);
          const H = mod2(D - B);
          const X3 = mod2(E * F);
          const Y3 = mod2(G * H);
          const T3 = mod2(E * H);
          const Z3 = mod2(F * G);
          return new ExtendedPoint(X3, Y3, Z3, T3);
        }
        add(other) {
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const T1 = this.t;
          const X2 = other.x;
          const Y2 = other.y;
          const Z2 = other.z;
          const T2 = other.t;
          const A = mod2((Y1 - X1) * (Y2 + X2));
          const B = mod2((Y1 + X1) * (Y2 - X2));
          const F = mod2(B - A);
          if (F === 0n) {
            return this.double();
          }
          const C = mod2(Z1 * 2n * T2);
          const D = mod2(T1 * 2n * Z2);
          const E = mod2(D + C);
          const G = mod2(B + A);
          const H = mod2(D - C);
          const X3 = mod2(E * F);
          const Y3 = mod2(G * H);
          const T3 = mod2(E * H);
          const Z3 = mod2(F * G);
          return new ExtendedPoint(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiplyUnsafe(scalar) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected number or bigint");
          let n = mod2(BigInt(scalar), CURVE.n);
          if (n === 1n)
            return this;
          let p = ExtendedPoint.ZERO;
          let d = this;
          while (n > 0n) {
            if (n & 1n)
              p = p.add(d);
            d = d.double();
            n >>= 1n;
          }
          return p;
        }
        precomputeWindow(W) {
          const windows = 256 / W + 1;
          let points = [];
          let p = this;
          let base3 = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base3 = p;
            points.push(base3);
            for (let i = 1; i < 2 ** (W - 1); i++) {
              base3 = base3.add(p);
              points.push(base3);
            }
            p = base3.double();
          }
          return points;
        }
        wNAF(n, affinePoint) {
          if (!affinePoint && this.equals(ExtendedPoint.BASE))
            affinePoint = Point.BASE;
          const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
          if (256 % W) {
            throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
          }
          let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
          if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
              precomputes = ExtendedPoint.normalizeZ(precomputes);
              pointPrecomputes.set(affinePoint, precomputes);
            }
          }
          let p = ExtendedPoint.ZERO;
          let f = ExtendedPoint.ZERO;
          const windows = 256 / W + 1;
          const windowSize = 2 ** (W - 1);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += 1n;
            }
            if (wbits === 0) {
              f = f.add(window2 % 2 ? precomputes[offset].negate() : precomputes[offset]);
            } else {
              const cached = precomputes[offset + Math.abs(wbits) - 1];
              p = p.add(wbits < 0 ? cached.negate() : cached);
            }
          }
          return [p, f];
        }
        multiply(scalar, affinePoint) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected number or bigint");
          const n = mod2(BigInt(scalar), CURVE.n);
          return ExtendedPoint.normalizeZ(this.wNAF(n, affinePoint))[0];
        }
        toAffine(invZ = invert(this.z)) {
          const x = mod2(this.x * invZ);
          const y = mod2(this.y * invZ);
          return new Point(x, y);
        }
      };
      exports2.ExtendedPoint = ExtendedPoint;
      ExtendedPoint.BASE = new ExtendedPoint(CURVE.Gx, CURVE.Gy, 1n, mod2(CURVE.Gx * CURVE.Gy));
      ExtendedPoint.ZERO = new ExtendedPoint(0n, 1n, 1n, 0n);
      var pointPrecomputes = new WeakMap();
      var Point = class {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        static fromHex(hash) {
          const { d, P } = CURVE;
          const bytes = hash instanceof Uint8Array ? hash : hexToBytes(hash);
          if (bytes.length !== 32)
            throw new Error("Point.fromHex: expected 32 bytes");
          const last = bytes[31];
          const normedLast = last & ~128;
          const isLastByteOdd = (last & 128) !== 0;
          const normed = Uint8Array.from(Array.from(bytes.slice(0, 31)).concat(normedLast));
          const y = bytesToNumberLE(normed);
          if (y >= P)
            throw new Error("Point.fromHex expects hex <= Fp");
          const y2 = mod2(y * y);
          const u = mod2(y2 - 1n);
          const v = mod2(d * y2 + 1n);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid)
            throw new Error("Point.fromHex: invalid y coordinate");
          const isXOdd = (x & 1n) === 1n;
          if (isLastByteOdd !== isXOdd) {
            x = mod2(-x);
          }
          return new Point(x, y);
        }
        static async fromPrivateKey(privateKey) {
          const privBytes = await exports2.utils.sha512(normalizePrivateKey(privateKey));
          return Point.BASE.multiply(encodePrivate(privBytes));
        }
        toRawBytes() {
          const hex = numberToHex(this.y);
          const u8 = new Uint8Array(B32);
          for (let i = hex.length - 2, j = 0; j < B32 && i >= 0; i -= 2, j++) {
            u8[j] = Number.parseInt(hex[i] + hex[i + 1], 16);
          }
          const mask = this.x & 1n ? 128 : 0;
          u8[B32 - 1] |= mask;
          return u8;
        }
        toHex() {
          return bytesToHex(this.toRawBytes());
        }
        toX25519() {
          return mod2((1n + this.y) * invert(1n - this.y));
        }
        equals(other) {
          return this.x === other.x && this.y === other.y;
        }
        negate() {
          return new Point(mod2(-this.x), this.y);
        }
        add(other) {
          return ExtendedPoint.fromAffine(this).add(ExtendedPoint.fromAffine(other)).toAffine();
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiply(scalar) {
          return ExtendedPoint.fromAffine(this).multiply(scalar, this).toAffine();
        }
      };
      exports2.Point = Point;
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
      Point.ZERO = new Point(0n, 1n);
      var Signature = class {
        constructor(r, s) {
          this.r = r;
          this.s = s;
        }
        static fromHex(hex) {
          hex = ensureBytes(hex);
          const r = Point.fromHex(hex.slice(0, 32));
          const s = bytesToNumberLE(hex.slice(32));
          if (!isWithinCurveOrder(s))
            throw new Error("Signature.fromHex expects s <= CURVE.n");
          return new Signature(r, s);
        }
        toRawBytes() {
          const numberBytes = hexToBytes(numberToHex(this.s)).reverse();
          const sBytes = new Uint8Array(B32);
          sBytes.set(numberBytes);
          const res = new Uint8Array(B32 * 2);
          res.set(this.r.toRawBytes());
          res.set(sBytes, 32);
          return res;
        }
        toHex() {
          return bytesToHex(this.toRawBytes());
        }
      };
      exports2.Signature = Signature;
      exports2.SignResult = Signature;
      function concatBytes(...arrays) {
        if (arrays.length === 1)
          return arrays[0];
        const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length2);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      function bytesToHex(uint8a) {
        let hex = "";
        for (let i = 0; i < uint8a.length; i++) {
          hex += uint8a[i].toString(16).padStart(2, "0");
        }
        return hex;
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string") {
          throw new TypeError("hexToBytes: expected string, got " + typeof hex);
        }
        if (hex.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          array[i] = Number.parseInt(hex.slice(j, j + 2), 16);
        }
        return array;
      }
      function numberToHex(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function numberToBytesPadded(num, length2 = B32) {
        const hex = numberToHex(num).padStart(length2 * 2, "0");
        return hexToBytes(hex).reverse();
      }
      function edIsNegative(num) {
        return (mod2(num) & 1n) === 1n;
      }
      function isValidScalar(num) {
        if (typeof num === "bigint" && num > 0n)
          return true;
        if (typeof num === "number" && num > 0 && Number.isSafeInteger(num))
          return true;
        return false;
      }
      function bytesToNumberLE(uint8a) {
        let value = 0n;
        for (let i = 0; i < uint8a.length; i++) {
          value += BigInt(uint8a[i]) << 8n * BigInt(i);
        }
        return value;
      }
      function bytes255ToNumberLE(bytes) {
        return mod2(bytesToNumberLE(bytes) & 2n ** 255n - 1n);
      }
      function mod2(a, b = CURVE.P) {
        const res = a % b;
        return res >= 0n ? res : b + res;
      }
      function invert(number, modulo = CURVE.P) {
        if (number === 0n || modulo <= 0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod2(number, modulo);
        let b = modulo;
        let [x, y, u, v] = [0n, 1n, 1n, 0n];
        while (a !== 0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          [b, a] = [a, r];
          [x, y] = [u, v];
          [u, v] = [m, n];
        }
        const gcd = b;
        if (gcd !== 1n)
          throw new Error("invert: does not exist");
        return mod2(x, modulo);
      }
      function invertBatch(nums, n = CURVE.P) {
        const len = nums.length;
        const scratch = new Array(len);
        let acc = 1n;
        for (let i = 0; i < len; i++) {
          if (nums[i] === 0n)
            continue;
          scratch[i] = acc;
          acc = mod2(acc * nums[i], n);
        }
        acc = invert(acc, n);
        for (let i = len - 1; i >= 0; i--) {
          if (nums[i] === 0n)
            continue;
          let tmp = mod2(acc * nums[i], n);
          nums[i] = mod2(acc * scratch[i], n);
          acc = tmp;
        }
        return nums;
      }
      function pow2(x, power) {
        const { P } = CURVE;
        let res = x;
        while (power-- > 0n) {
          res *= res;
          res %= P;
        }
        return res;
      }
      function pow_2_252_3(x) {
        const { P } = CURVE;
        const x2 = x * x % P;
        const b2 = x2 * x % P;
        const b4 = pow2(b2, 2n) * b2 % P;
        const b5 = pow2(b4, 1n) * x % P;
        const b10 = pow2(b5, 5n) * b5 % P;
        const b20 = pow2(b10, 10n) * b10 % P;
        const b40 = pow2(b20, 20n) * b20 % P;
        const b80 = pow2(b40, 40n) * b40 % P;
        const b160 = pow2(b80, 80n) * b80 % P;
        const b240 = pow2(b160, 80n) * b80 % P;
        const b250 = pow2(b240, 10n) * b10 % P;
        const pow_p_5_8 = pow2(b250, 2n) * x % P;
        return pow_p_5_8;
      }
      function uvRatio(u, v) {
        const v3 = mod2(v * v * v);
        const v7 = mod2(v3 * v3 * v);
        let x = mod2(u * v3 * pow_2_252_3(u * v7));
        const vx2 = mod2(v * x * x);
        const root1 = x;
        const root2 = mod2(x * SQRT_M1);
        const useRoot1 = vx2 === u;
        const useRoot2 = vx2 === mod2(-u);
        const noRoot = vx2 === mod2(-u * SQRT_M1);
        if (useRoot1)
          x = root1;
        if (useRoot2 || noRoot)
          x = root2;
        if (edIsNegative(x))
          x = mod2(-x);
        return { isValid: useRoot1 || useRoot2, value: x };
      }
      function invertSqrt(number) {
        return uvRatio(1n, number);
      }
      async function sha512ToNumberLE(...args) {
        const messageArray = concatBytes(...args);
        const hash = await exports2.utils.sha512(messageArray);
        const value = bytesToNumberLE(hash);
        return mod2(value, CURVE.n);
      }
      function keyPrefix(privateBytes) {
        return privateBytes.slice(B32);
      }
      function encodePrivate(privateBytes) {
        const last = B32 - 1;
        const head = privateBytes.slice(0, B32);
        head[0] &= 248;
        head[last] &= 127;
        head[last] |= 64;
        return mod2(bytesToNumberLE(head), CURVE.n);
      }
      function equalBytes(b1, b2) {
        if (b1.length !== b2.length) {
          return false;
        }
        for (let i = 0; i < b1.length; i++) {
          if (b1[i] !== b2[i]) {
            return false;
          }
        }
        return true;
      }
      function ensureBytes(hash) {
        return hash instanceof Uint8Array ? hash : hexToBytes(hash);
      }
      function isWithinCurveOrder(num) {
        return 0 < num && num < CURVE.n;
      }
      function normalizePrivateKey(key) {
        let num;
        if (typeof key === "bigint" || typeof key === "number" && Number.isSafeInteger(key)) {
          num = BigInt(key);
          if (num < 0n || num > 2n ** 256n)
            throw new Error("Expected 32 bytes of private key");
          key = num.toString(16).padStart(B32 * 2, "0");
        }
        if (typeof key === "string") {
          if (key.length !== 64)
            throw new Error("Expected 32 bytes of private key");
          return hexToBytes(key);
        } else if (key instanceof Uint8Array) {
          if (key.length !== 32)
            throw new Error("Expected 32 bytes of private key");
          return key;
        } else {
          throw new TypeError("Expected valid private key");
        }
      }
      async function getPublicKey(privateKey) {
        const key = await Point.fromPrivateKey(privateKey);
        return typeof privateKey === "string" ? key.toHex() : key.toRawBytes();
      }
      exports2.getPublicKey = getPublicKey;
      async function sign(hash, privateKey) {
        const privBytes = await exports2.utils.sha512(normalizePrivateKey(privateKey));
        const p = encodePrivate(privBytes);
        const P = Point.BASE.multiply(p);
        const msg = ensureBytes(hash);
        const r = await sha512ToNumberLE(keyPrefix(privBytes), msg);
        const R = Point.BASE.multiply(r);
        const h = await sha512ToNumberLE(R.toRawBytes(), P.toRawBytes(), msg);
        const S = mod2(r + h * p, CURVE.n);
        const sig = new Signature(R, S);
        return typeof hash === "string" ? sig.toHex() : sig.toRawBytes();
      }
      exports2.sign = sign;
      async function verify(signature, hash, publicKey) {
        hash = ensureBytes(hash);
        if (!(publicKey instanceof Point))
          publicKey = Point.fromHex(publicKey);
        if (!(signature instanceof Signature))
          signature = Signature.fromHex(signature);
        const hs = await sha512ToNumberLE(signature.r.toRawBytes(), publicKey.toRawBytes(), hash);
        const Ph = ExtendedPoint.fromAffine(publicKey).multiplyUnsafe(hs);
        const Gs = ExtendedPoint.BASE.multiply(signature.s);
        const RPh = ExtendedPoint.fromAffine(signature.r).add(Ph);
        return RPh.subtract(Gs).multiplyUnsafe(8n).equals(ExtendedPoint.ZERO);
      }
      exports2.verify = verify;
      Point.BASE._setWindowSize(8);
      var crypto2 = (() => {
        const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : void 0;
        const nodeRequire = typeof module2 !== "undefined" && typeof __require === "function";
        return {
          node: nodeRequire && !webCrypto ? require_crypto() : void 0,
          web: webCrypto
        };
      })();
      exports2.utils = {
        TORSION_SUBGROUP: [
          "0100000000000000000000000000000000000000000000000000000000000000",
          "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
          "0000000000000000000000000000000000000000000000000000000000000080",
          "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
          "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
          "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
          "0000000000000000000000000000000000000000000000000000000000000000",
          "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
        ],
        randomBytes: (bytesLength = 32) => {
          if (crypto2.web) {
            return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
          } else if (crypto2.node) {
            const { randomBytes } = crypto2.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
          } else {
            throw new Error("The environment doesn't have randomBytes function");
          }
        },
        randomPrivateKey: () => {
          let i = 1024;
          while (i--) {
            const b32 = exports2.utils.randomBytes(32);
            const num = bytesToNumberLE(b32);
            if (num > 1n && num < CURVE.n)
              return b32;
          }
          throw new Error("Valid private key was not found in 1024 iterations. PRNG is broken");
        },
        sha512: async (message) => {
          if (crypto2.web) {
            const buffer = await crypto2.web.subtle.digest("SHA-512", message.buffer);
            return new Uint8Array(buffer);
          } else if (crypto2.node) {
            return Uint8Array.from(crypto2.node.createHash("sha512").update(message).digest());
          } else {
            throw new Error("The environment doesn't have sha512 function");
          }
        },
        precompute(windowSize = 8, point = Point.BASE) {
          const cached = point.equals(Point.BASE) ? point : new Point(point.x, point.y);
          cached._setWindowSize(windowSize);
          cached.multiply(1n);
          return cached;
        }
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ed25519.js
  var require_ed255192 = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ed25519.js"(exports2) {
      "use strict";
      var ed = require_ed25519();
      var PUBLIC_KEY_BYTE_LENGTH = 32;
      var PRIVATE_KEY_BYTE_LENGTH = 64;
      var KEYS_BYTE_LENGTH = 32;
      exports2.publicKeyLength = PUBLIC_KEY_BYTE_LENGTH;
      exports2.privateKeyLength = PRIVATE_KEY_BYTE_LENGTH;
      exports2.generateKey = async function() {
        const privateKeyRaw = ed.utils.randomPrivateKey();
        const publicKey = await ed.getPublicKey(privateKeyRaw);
        const privateKey = concatKeys(privateKeyRaw, publicKey);
        return {
          privateKey,
          publicKey
        };
      };
      exports2.generateKeyFromSeed = async function(seed) {
        if (seed.length !== KEYS_BYTE_LENGTH) {
          throw new TypeError('"seed" must be 32 bytes in length.');
        } else if (!(seed instanceof Uint8Array)) {
          throw new TypeError('"seed" must be a node.js Buffer, or Uint8Array.');
        }
        const privateKeyRaw = seed;
        const publicKey = await ed.getPublicKey(privateKeyRaw);
        const privateKey = concatKeys(privateKeyRaw, publicKey);
        return {
          privateKey,
          publicKey
        };
      };
      exports2.hashAndSign = function(privateKey, msg) {
        const privateKeyRaw = privateKey.slice(0, KEYS_BYTE_LENGTH);
        return ed.sign(msg, privateKeyRaw);
      };
      exports2.hashAndVerify = function(publicKey, sig, msg) {
        return ed.verify(sig, msg, publicKey);
      };
      function concatKeys(privateKeyRaw, publicKey) {
        const privateKey = new Uint8Array(exports2.privateKeyLength);
        for (let i = 0; i < KEYS_BYTE_LENGTH; i++) {
          privateKey[i] = privateKeyRaw[i];
          privateKey[KEYS_BYTE_LENGTH + i] = publicKey[i];
        }
        return privateKey;
      }
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ed25519-class.js
  var require_ed25519_class = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ed25519-class.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var { base58btc: base58btc2 } = (init_base58(), base58_exports);
      var { identity: identity3 } = (init_identity2(), identity_exports2);
      var crypto2 = require_ed255192();
      var pbm = require_keys();
      var exporter = require_exporter();
      var Ed25519PublicKey = class {
        constructor(key) {
          this._key = ensureKey(key, crypto2.publicKeyLength);
        }
        async verify(data, sig) {
          return crypto2.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return pbm.PublicKey.encode({
            Type: pbm.KeyType.Ed25519,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
      };
      var Ed25519PrivateKey = class {
        constructor(key, publicKey) {
          this._key = ensureKey(key, crypto2.privateKeyLength);
          this._publicKey = ensureKey(publicKey, crypto2.publicKeyLength);
        }
        async sign(message) {
          return crypto2.hashAndSign(this._key, message);
        }
        get public() {
          return new Ed25519PublicKey(this._publicKey);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return pbm.PrivateKey.encode({
            Type: pbm.KeyType.Ed25519,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
        async id() {
          const encoding = await identity3.digest(this.public.bytes);
          return base58btc2.encode(encoding.bytes).substring(1);
        }
        async export(password, format = "libp2p-key") {
          if (format === "libp2p-key") {
            return exporter.export(this.bytes, password);
          } else {
            throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      };
      function unmarshalEd25519PrivateKey(bytes) {
        if (bytes.length > crypto2.privateKeyLength) {
          bytes = ensureKey(bytes, crypto2.privateKeyLength + crypto2.publicKeyLength);
          const privateKeyBytes2 = bytes.slice(0, crypto2.privateKeyLength);
          const publicKeyBytes2 = bytes.slice(crypto2.privateKeyLength, bytes.length);
          return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
        }
        bytes = ensureKey(bytes, crypto2.privateKeyLength);
        const privateKeyBytes = bytes.slice(0, crypto2.privateKeyLength);
        const publicKeyBytes = bytes.slice(crypto2.publicKeyLength);
        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
      }
      function unmarshalEd25519PublicKey(bytes) {
        bytes = ensureKey(bytes, crypto2.publicKeyLength);
        return new Ed25519PublicKey(bytes);
      }
      async function generateKeyPair() {
        const { privateKey, publicKey } = await crypto2.generateKey();
        return new Ed25519PrivateKey(privateKey, publicKey);
      }
      async function generateKeyPairFromSeed(seed) {
        const { privateKey, publicKey } = await crypto2.generateKeyFromSeed(seed);
        return new Ed25519PrivateKey(privateKey, publicKey);
      }
      function ensureKey(key, length2) {
        key = Uint8Array.from(key || []);
        if (key.length !== length2) {
          throw errcode(new Error(`Key must be a Uint8Array of length ${length2}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
        }
        return key;
      }
      module2.exports = {
        Ed25519PublicKey,
        Ed25519PrivateKey,
        unmarshalEd25519PrivateKey,
        unmarshalEd25519PublicKey,
        generateKeyPair,
        generateKeyPairFromSeed
      };
    }
  });

  // node_modules/@noble/secp256k1/index.js
  var require_secp256k1 = __commonJS({
    "node_modules/@noble/secp256k1/index.js"(exports2, module2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.utils = exports2.schnorr = exports2.verify = exports2.signSync = exports2.sign = exports2.getSharedSecret = exports2.recoverPublicKey = exports2.getPublicKey = exports2.SignResult = exports2.Signature = exports2.Point = exports2.CURVE = void 0;
      var CURVE = {
        a: 0n,
        b: 7n,
        P: 2n ** 256n - 2n ** 32n - 977n,
        n: 2n ** 256n - 432420386565659656852420866394968145599n,
        h: 1n,
        Gx: 55066263022277343669578718895168534326250603453777594175500187360389116729240n,
        Gy: 32670510020758816978083085130507043184471273380659243275938904335757337482424n,
        beta: 0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501een
      };
      exports2.CURVE = CURVE;
      function weistrass(x) {
        const { a, b } = CURVE;
        return mod2(x ** 3n + a * x + b);
      }
      var USE_ENDOMORPHISM = CURVE.a === 0n;
      var JacobianPoint = class {
        constructor(x, y, z) {
          this.x = x;
          this.y = y;
          this.z = z;
        }
        static fromAffine(p) {
          if (!(p instanceof Point)) {
            throw new TypeError("JacobianPoint#fromAffine: expected Point");
          }
          return new JacobianPoint(p.x, p.y, 1n);
        }
        static toAffineBatch(points) {
          const toInv = invertBatch(points.map((p) => p.z));
          return points.map((p, i) => p.toAffine(toInv[i]));
        }
        static normalizeZ(points) {
          return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
        }
        equals(other) {
          const a = this;
          const b = other;
          const az2 = mod2(a.z * a.z);
          const az3 = mod2(a.z * az2);
          const bz2 = mod2(b.z * b.z);
          const bz3 = mod2(b.z * bz2);
          return mod2(a.x * bz2) === mod2(az2 * b.x) && mod2(a.y * bz3) === mod2(az3 * b.y);
        }
        negate() {
          return new JacobianPoint(this.x, mod2(-this.y), this.z);
        }
        double() {
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const A = mod2(X1 ** 2n);
          const B = mod2(Y1 ** 2n);
          const C = mod2(B ** 2n);
          const D = mod2(2n * (mod2(mod2((X1 + B) ** 2n)) - A - C));
          const E = mod2(3n * A);
          const F = mod2(E ** 2n);
          const X3 = mod2(F - 2n * D);
          const Y3 = mod2(E * (D - X3) - 8n * C);
          const Z3 = mod2(2n * Y1 * Z1);
          return new JacobianPoint(X3, Y3, Z3);
        }
        add(other) {
          if (!(other instanceof JacobianPoint)) {
            throw new TypeError("JacobianPoint#add: expected JacobianPoint");
          }
          const X1 = this.x;
          const Y1 = this.y;
          const Z1 = this.z;
          const X2 = other.x;
          const Y2 = other.y;
          const Z2 = other.z;
          if (X2 === 0n || Y2 === 0n)
            return this;
          if (X1 === 0n || Y1 === 0n)
            return other;
          const Z1Z1 = mod2(Z1 ** 2n);
          const Z2Z2 = mod2(Z2 ** 2n);
          const U1 = mod2(X1 * Z2Z2);
          const U2 = mod2(X2 * Z1Z1);
          const S1 = mod2(Y1 * Z2 * Z2Z2);
          const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
          const H = mod2(U2 - U1);
          const r = mod2(S2 - S1);
          if (H === 0n) {
            if (r === 0n) {
              return this.double();
            } else {
              return JacobianPoint.ZERO;
            }
          }
          const HH = mod2(H ** 2n);
          const HHH = mod2(H * HH);
          const V = mod2(U1 * HH);
          const X3 = mod2(r ** 2n - HHH - 2n * V);
          const Y3 = mod2(r * (V - X3) - S1 * HHH);
          const Z3 = mod2(Z1 * Z2 * H);
          return new JacobianPoint(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiplyUnsafe(scalar) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected valid scalar");
          let n = mod2(BigInt(scalar), CURVE.n);
          if (!USE_ENDOMORPHISM) {
            let p = JacobianPoint.ZERO;
            let d2 = this;
            while (n > 0n) {
              if (n & 1n)
                p = p.add(d2);
              d2 = d2.double();
              n >>= 1n;
            }
            return p;
          }
          let [k1neg, k1, k2neg, k2] = splitScalarEndo(n);
          let k1p = JacobianPoint.ZERO;
          let k2p = JacobianPoint.ZERO;
          let d = this;
          while (k1 > 0n || k2 > 0n) {
            if (k1 & 1n)
              k1p = k1p.add(d);
            if (k2 & 1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= 1n;
            k2 >>= 1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
          return k1p.add(k2p);
        }
        precomputeWindow(W) {
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          let points = [];
          let p = this;
          let base3 = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base3 = p;
            points.push(base3);
            for (let i = 1; i < 2 ** (W - 1); i++) {
              base3 = base3.add(p);
              points.push(base3);
            }
            p = base3.double();
          }
          return points;
        }
        wNAF(n, affinePoint) {
          if (!affinePoint && this.equals(JacobianPoint.BASE))
            affinePoint = Point.BASE;
          const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
          if (256 % W) {
            throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
          }
          let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
          if (!precomputes) {
            precomputes = this.precomputeWindow(W);
            if (affinePoint && W !== 1) {
              precomputes = JacobianPoint.normalizeZ(precomputes);
              pointPrecomputes.set(affinePoint, precomputes);
            }
          }
          let p = JacobianPoint.ZERO;
          let f = JacobianPoint.ZERO;
          const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
          const windowSize = 2 ** (W - 1);
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += 1n;
            }
            if (wbits === 0) {
              f = f.add(window2 % 2 ? precomputes[offset].negate() : precomputes[offset]);
            } else {
              const cached = precomputes[offset + Math.abs(wbits) - 1];
              p = p.add(wbits < 0 ? cached.negate() : cached);
            }
          }
          return [p, f];
        }
        multiply(scalar, affinePoint) {
          if (!isValidScalar(scalar))
            throw new TypeError("Point#multiply: expected valid scalar");
          let n = mod2(BigInt(scalar), CURVE.n);
          let point;
          let fake;
          if (USE_ENDOMORPHISM) {
            const [k1neg, k1, k2neg, k2] = splitScalarEndo(n);
            let k1p, k2p, f1p, f2p;
            [k1p, f1p] = this.wNAF(k1, affinePoint);
            [k2p, f2p] = this.wNAF(k2, affinePoint);
            if (k1neg)
              k1p = k1p.negate();
            if (k2neg)
              k2p = k2p.negate();
            k2p = new JacobianPoint(mod2(k2p.x * CURVE.beta), k2p.y, k2p.z);
            [point, fake] = [k1p.add(k2p), f1p.add(f2p)];
          } else {
            [point, fake] = this.wNAF(n, affinePoint);
          }
          return JacobianPoint.normalizeZ([point, fake])[0];
        }
        toAffine(invZ = invert(this.z)) {
          const invZ2 = invZ ** 2n;
          const x = mod2(this.x * invZ2);
          const y = mod2(this.y * invZ2 * invZ);
          return new Point(x, y);
        }
      };
      JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, 1n);
      JacobianPoint.ZERO = new JacobianPoint(0n, 1n, 0n);
      var pointPrecomputes = new WeakMap();
      var Point = class {
        constructor(x, y) {
          this.x = x;
          this.y = y;
        }
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        static fromCompressedHex(bytes) {
          const isShort = bytes.length === 32;
          const x = bytesToNumber(isShort ? bytes : bytes.slice(1));
          const y2 = weistrass(x);
          let y = sqrtMod(y2);
          const isYOdd = (y & 1n) === 1n;
          if (isShort) {
            if (isYOdd)
              y = mod2(-y);
          } else {
            const isFirstByteOdd = (bytes[0] & 1) === 1;
            if (isFirstByteOdd !== isYOdd)
              y = mod2(-y);
          }
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromUncompressedHex(bytes) {
          const x = bytesToNumber(bytes.slice(1, 33));
          const y = bytesToNumber(bytes.slice(33));
          const point = new Point(x, y);
          point.assertValidity();
          return point;
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          const header = bytes[0];
          if (bytes.length === 32 || bytes.length === 33 && (header === 2 || header === 3)) {
            return this.fromCompressedHex(bytes);
          }
          if (bytes.length === 65 && header === 4)
            return this.fromUncompressedHex(bytes);
          throw new Error(`Point.fromHex: received invalid point. Expected 32-33 compressed bytes or 65 uncompressed bytes, not ${bytes.length}`);
        }
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normalizePrivateKey(privateKey));
        }
        static fromSignature(msgHash, signature, recovery) {
          let h = msgHash instanceof Uint8Array ? bytesToNumber(msgHash) : hexToNumber(msgHash);
          const sig = normalizeSignature(signature);
          const { r, s } = sig;
          if (recovery !== 0 && recovery !== 1) {
            throw new Error("Cannot recover signature: invalid yParity bit");
          }
          const prefix = 2 + (recovery & 1);
          const P_ = Point.fromHex(`0${prefix}${pad64(r)}`);
          const sP = JacobianPoint.fromAffine(P_).multiplyUnsafe(s);
          const hG = JacobianPoint.BASE.multiply(h);
          const rinv = invert(r, CURVE.n);
          const Q = sP.subtract(hG).multiplyUnsafe(rinv);
          const point = Q.toAffine();
          point.assertValidity();
          return point;
        }
        toRawBytes(isCompressed = false) {
          return hexToBytes(this.toHex(isCompressed));
        }
        toHex(isCompressed = false) {
          const x = pad64(this.x);
          if (isCompressed) {
            return `${this.y & 1n ? "03" : "02"}${x}`;
          } else {
            return `04${x}${pad64(this.y)}`;
          }
        }
        toHexX() {
          return this.toHex(true).slice(2);
        }
        toRawX() {
          return this.toRawBytes(true).slice(1);
        }
        assertValidity() {
          const msg = "Point is not on elliptic curve";
          const { P } = CURVE;
          const { x, y } = this;
          if (x === 0n || y === 0n || x >= P || y >= P)
            throw new Error(msg);
          const left = mod2(y * y);
          const right = weistrass(x);
          if ((left - right) % P !== 0n)
            throw new Error(msg);
        }
        equals(other) {
          return this.x === other.x && this.y === other.y;
        }
        negate() {
          return new Point(this.x, mod2(-this.y));
        }
        double() {
          return JacobianPoint.fromAffine(this).double().toAffine();
        }
        add(other) {
          return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
        }
        subtract(other) {
          return this.add(other.negate());
        }
        multiply(scalar) {
          return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
        }
      };
      exports2.Point = Point;
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy);
      Point.ZERO = new Point(0n, 0n);
      function sliceDer(s) {
        return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
      }
      var Signature = class {
        constructor(r, s) {
          this.r = r;
          this.s = s;
        }
        static fromCompact(hex) {
          if (typeof hex !== "string" && !(hex instanceof Uint8Array)) {
            throw new TypeError(`Signature.fromCompact: Expected string or Uint8Array`);
          }
          const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;
          if (str.length !== 128)
            throw new Error("Signature.fromCompact: Expected 64-byte hex");
          const sig = new Signature(hexToNumber(str.slice(0, 64)), hexToNumber(str.slice(64, 128)));
          sig.assertValidity();
          return sig;
        }
        static fromDER(hex) {
          const fn = "Signature.fromDER";
          if (typeof hex !== "string" && !(hex instanceof Uint8Array)) {
            throw new TypeError(`${fn}: Expected string or Uint8Array`);
          }
          const str = hex instanceof Uint8Array ? bytesToHex(hex) : hex;
          const length2 = parseByte(str.slice(2, 4));
          if (str.slice(0, 2) !== "30" || length2 !== str.length - 4 || str.slice(4, 6) !== "02") {
            throw new Error(`${fn}: Invalid signature ${str}`);
          }
          const rLen = parseByte(str.slice(6, 8));
          const rEnd = 8 + rLen;
          const rr = str.slice(8, rEnd);
          if (rr.startsWith("00") && parseByte(rr.slice(2, 4)) <= 127) {
            throw new Error(`${fn}: Invalid r with trailing length`);
          }
          const r = hexToNumber(rr);
          const separator = str.slice(rEnd, rEnd + 2);
          if (separator !== "02") {
            throw new Error(`${fn}: Invalid r-s separator`);
          }
          const sLen = parseByte(str.slice(rEnd + 2, rEnd + 4));
          const diff = length2 - sLen - rLen - 10;
          if (diff > 0 || diff === -4) {
            throw new Error(`${fn}: Invalid total length`);
          }
          if (sLen > length2 - rLen - 4) {
            throw new Error(`${fn}: Invalid s`);
          }
          const sStart = rEnd + 4;
          const ss = str.slice(sStart, sStart + sLen);
          if (ss.startsWith("00") && parseByte(ss.slice(2, 4)) <= 127) {
            throw new Error(`${fn}: Invalid s with trailing length`);
          }
          const s = hexToNumber(ss);
          const sig = new Signature(r, s);
          sig.assertValidity();
          return sig;
        }
        static fromHex(hex) {
          return this.fromDER(hex);
        }
        assertValidity() {
          const { r, s } = this;
          if (!isWithinCurveOrder(r))
            throw new Error("Invalid Signature: r must be 0 < r < n");
          if (!isWithinCurveOrder(s))
            throw new Error("Invalid Signature: s must be 0 < s < n");
        }
        toDERRawBytes(isCompressed = false) {
          return hexToBytes(this.toDERHex(isCompressed));
        }
        toDERHex(isCompressed = false) {
          const sHex = sliceDer(numberToHex(this.s));
          if (isCompressed)
            return sHex;
          const rHex = sliceDer(numberToHex(this.r));
          const rLen = numberToHex(rHex.length / 2);
          const sLen = numberToHex(sHex.length / 2);
          const length2 = numberToHex(rHex.length / 2 + sHex.length / 2 + 4);
          return `30${length2}02${rLen}${rHex}02${sLen}${sHex}`;
        }
        toRawBytes() {
          return this.toDERRawBytes();
        }
        toHex() {
          return this.toDERHex();
        }
        toCompactRawBytes() {
          return hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return pad64(this.r) + pad64(this.s);
        }
      };
      exports2.Signature = Signature;
      exports2.SignResult = Signature;
      function concatBytes(...arrays) {
        if (arrays.length === 1)
          return arrays[0];
        const length2 = arrays.reduce((a, arr) => a + arr.length, 0);
        const result = new Uint8Array(length2);
        for (let i = 0, pad = 0; i < arrays.length; i++) {
          const arr = arrays[i];
          result.set(arr, pad);
          pad += arr.length;
        }
        return result;
      }
      function bytesToHex(uint8a) {
        let hex = "";
        for (let i = 0; i < uint8a.length; i++) {
          hex += uint8a[i].toString(16).padStart(2, "0");
        }
        return hex;
      }
      function pad64(num) {
        return num.toString(16).padStart(64, "0");
      }
      function pad32b(num) {
        return hexToBytes(pad64(num));
      }
      function numberToHex(num) {
        const hex = num.toString(16);
        return hex.length & 1 ? `0${hex}` : hex;
      }
      function hexToNumber(hex) {
        if (typeof hex !== "string") {
          throw new TypeError("hexToNumber: expected string, got " + typeof hex);
        }
        return BigInt(`0x${hex}`);
      }
      function hexToBytes(hex) {
        if (typeof hex !== "string") {
          throw new TypeError("hexToBytes: expected string, got " + typeof hex);
        }
        if (hex.length % 2)
          throw new Error("hexToBytes: received invalid unpadded hex");
        const array = new Uint8Array(hex.length / 2);
        for (let i = 0; i < array.length; i++) {
          const j = i * 2;
          array[i] = Number.parseInt(hex.slice(j, j + 2), 16);
        }
        return array;
      }
      function ensureBytes(hex) {
        return hex instanceof Uint8Array ? hex : hexToBytes(hex);
      }
      function bytesToNumber(bytes) {
        return hexToNumber(bytesToHex(bytes));
      }
      function parseByte(str) {
        return Number.parseInt(str, 16) * 2;
      }
      function isValidScalar(num) {
        if (typeof num === "bigint" && num > 0n)
          return true;
        if (typeof num === "number" && num > 0 && Number.isSafeInteger(num))
          return true;
        return false;
      }
      function mod2(a, b = CURVE.P) {
        const result = a % b;
        return result >= 0 ? result : b + result;
      }
      function pow2(x, power) {
        const { P } = CURVE;
        let res = x;
        while (power-- > 0n) {
          res *= res;
          res %= P;
        }
        return res;
      }
      function sqrtMod(x) {
        const { P } = CURVE;
        const b2 = x * x * x % P;
        const b3 = b2 * b2 * x % P;
        const b6 = pow2(b3, 3n) * b3 % P;
        const b9 = pow2(b6, 3n) * b3 % P;
        const b11 = pow2(b9, 2n) * b2 % P;
        const b22 = pow2(b11, 11n) * b11 % P;
        const b44 = pow2(b22, 22n) * b22 % P;
        const b88 = pow2(b44, 44n) * b44 % P;
        const b176 = pow2(b88, 88n) * b88 % P;
        const b220 = pow2(b176, 44n) * b44 % P;
        const b223 = pow2(b220, 3n) * b3 % P;
        const t1 = pow2(b223, 23n) * b22 % P;
        const t2 = pow2(t1, 6n) * b2 % P;
        return pow2(t2, 2n);
      }
      function invert(number, modulo = CURVE.P) {
        if (number === 0n || modulo <= 0n) {
          throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
        }
        let a = mod2(number, modulo);
        let b = modulo;
        let [x, y, u, v] = [0n, 1n, 1n, 0n];
        while (a !== 0n) {
          const q = b / a;
          const r = b % a;
          const m = x - u * q;
          const n = y - v * q;
          [b, a] = [a, r];
          [x, y] = [u, v];
          [u, v] = [m, n];
        }
        const gcd = b;
        if (gcd !== 1n)
          throw new Error("invert: does not exist");
        return mod2(x, modulo);
      }
      function invertBatch(nums, n = CURVE.P) {
        const len = nums.length;
        const scratch = new Array(len);
        let acc = 1n;
        for (let i = 0; i < len; i++) {
          if (nums[i] === 0n)
            continue;
          scratch[i] = acc;
          acc = mod2(acc * nums[i], n);
        }
        acc = invert(acc, n);
        for (let i = len - 1; i >= 0; i--) {
          if (nums[i] === 0n)
            continue;
          const tmp = mod2(acc * nums[i], n);
          nums[i] = mod2(acc * scratch[i], n);
          acc = tmp;
        }
        return nums;
      }
      var divNearest = (a, b) => (a + b / 2n) / b;
      var POW_2_128 = 2n ** 128n;
      function splitScalarEndo(k) {
        const { n } = CURVE;
        const a1 = 0x3086d221a7d46bcde86c90e49284eb15n;
        const b1 = -0xe4437ed6010e88286f547fa90abfe4c3n;
        const a2 = 0x114ca50f7a8e2f3f657c1108d9d44cfd8n;
        const b2 = a1;
        const c1 = divNearest(b2 * k, n);
        const c2 = divNearest(-b1 * k, n);
        let k1 = mod2(k - c1 * a1 - c2 * a2, n);
        let k2 = mod2(-c1 * b1 - c2 * b2, n);
        const k1neg = k1 > POW_2_128;
        const k2neg = k2 > POW_2_128;
        if (k1neg)
          k1 = n - k1;
        if (k2neg)
          k2 = n - k2;
        if (k1 > POW_2_128 || k2 > POW_2_128)
          throw new Error("splitScalarEndo: Endomorphism failed");
        return [k1neg, k1, k2neg, k2];
      }
      function truncateHash(hash) {
        if (typeof hash !== "string")
          hash = bytesToHex(hash);
        let msg = hexToNumber(hash || "0");
        const byteLength = hash.length / 2;
        const delta = byteLength * 8 - 256;
        if (delta > 0) {
          msg = msg >> BigInt(delta);
        }
        if (msg >= CURVE.n) {
          msg -= CURVE.n;
        }
        return msg;
      }
      function _abc6979(msgHash, privateKey) {
        if (msgHash == null)
          throw new Error(`sign: expected valid msgHash, not "${msgHash}"`);
        const num = typeof msgHash === "string" ? hexToNumber(msgHash) : bytesToNumber(msgHash);
        const h1 = pad32b(num);
        const h1n = bytesToNumber(h1);
        const x = pad32b(privateKey);
        let v = new Uint8Array(32).fill(1);
        let k = new Uint8Array(32).fill(0);
        const b0 = Uint8Array.from([0]);
        const b1 = Uint8Array.from([1]);
        return [h1, h1n, x, v, k, b0, b1];
      }
      async function getQRSrfc6979(msgHash, privateKey) {
        const privKey = normalizePrivateKey(privateKey);
        let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);
        const hmac = exports2.utils.hmacSha256;
        k = await hmac(k, v, b0, x, h1);
        v = await hmac(k, v);
        k = await hmac(k, v, b1, x, h1);
        v = await hmac(k, v);
        for (let i = 0; i < 1e3; i++) {
          v = await hmac(k, v);
          let qrs = calcQRSFromK(v, h1n, privKey);
          if (qrs)
            return qrs;
          k = await hmac(k, v, b0);
          v = await hmac(k, v);
        }
        throw new TypeError("secp256k1: Tried 1,000 k values for sign(), all were invalid");
      }
      function getQRSrfc6979Sync(msgHash, privateKey) {
        const privKey = normalizePrivateKey(privateKey);
        let [h1, h1n, x, v, k, b0, b1] = _abc6979(msgHash, privKey);
        const hmac = exports2.utils.hmacSha256Sync;
        if (!hmac)
          throw new Error("utils.hmacSha256Sync is undefined, you need to set it");
        k = hmac(k, v, b0, x, h1);
        if (k instanceof Promise)
          throw new Error("To use sync sign(), ensure utils.hmacSha256 is sync");
        v = hmac(k, v);
        k = hmac(k, v, b1, x, h1);
        v = hmac(k, v);
        for (let i = 0; i < 1e3; i++) {
          v = hmac(k, v);
          let qrs = calcQRSFromK(v, h1n, privKey);
          if (qrs)
            return qrs;
          k = hmac(k, v, b0);
          v = hmac(k, v);
        }
        throw new TypeError("secp256k1: Tried 1,000 k values for sign(), all were invalid");
      }
      function isWithinCurveOrder(num) {
        return 0 < num && num < CURVE.n;
      }
      function calcQRSFromK(v, msg, priv) {
        const k = bytesToNumber(v);
        if (!isWithinCurveOrder(k))
          return;
        const max = CURVE.n;
        const q = Point.BASE.multiply(k);
        const r = mod2(q.x, max);
        const s = mod2(invert(k, max) * (msg + r * priv), max);
        if (r === 0n || s === 0n)
          return;
        return [q, r, s];
      }
      function normalizePrivateKey(key) {
        let num;
        if (typeof key === "bigint") {
          num = key;
        } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
          num = BigInt(key);
        } else if (typeof key === "string") {
          if (key.length !== 64)
            throw new Error("Expected 32 bytes of private key");
          num = hexToNumber(key);
        } else if (key instanceof Uint8Array) {
          if (key.length !== 32)
            throw new Error("Expected 32 bytes of private key");
          num = bytesToNumber(key);
        } else {
          throw new TypeError("Expected valid private key");
        }
        if (!isWithinCurveOrder(num))
          throw new Error("Expected private key: 0 < key < n");
        return num;
      }
      function normalizePublicKey(publicKey) {
        if (publicKey instanceof Point) {
          publicKey.assertValidity();
          return publicKey;
        } else {
          return Point.fromHex(publicKey);
        }
      }
      function normalizeSignature(signature) {
        if (signature instanceof Signature) {
          signature.assertValidity();
          return signature;
        } else {
          return Signature.fromDER(signature);
        }
      }
      function getPublicKey(privateKey, isCompressed = false) {
        const point = Point.fromPrivateKey(privateKey);
        if (typeof privateKey === "string") {
          return point.toHex(isCompressed);
        }
        return point.toRawBytes(isCompressed);
      }
      exports2.getPublicKey = getPublicKey;
      function recoverPublicKey(msgHash, signature, recovery) {
        const point = Point.fromSignature(msgHash, signature, recovery);
        return typeof msgHash === "string" ? point.toHex() : point.toRawBytes();
      }
      exports2.recoverPublicKey = recoverPublicKey;
      function isPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === 33 || len === 65;
        if (str)
          return len === 66 || len === 130;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = false) {
        if (isPub(privateA))
          throw new TypeError("getSharedSecret: first arg must be private key");
        if (!isPub(publicB))
          throw new TypeError("getSharedSecret: second arg must be public key");
        const b = normalizePublicKey(publicB);
        b.assertValidity();
        const shared = b.multiply(normalizePrivateKey(privateA));
        return typeof privateA === "string" ? shared.toHex(isCompressed) : shared.toRawBytes(isCompressed);
      }
      exports2.getSharedSecret = getSharedSecret;
      function QRSToSig(qrs, opts, str = false) {
        const [q, r, s] = qrs;
        let { canonical, der, recovered } = opts;
        let recovery = (q.x === r ? 0 : 2) | Number(q.y & 1n);
        let adjustedS = s;
        const HIGH_NUMBER = CURVE.n >> 1n;
        if (s > HIGH_NUMBER && canonical) {
          adjustedS = CURVE.n - s;
          recovery ^= 1;
        }
        const sig = new Signature(r, adjustedS);
        sig.assertValidity();
        const hex = der === false ? sig.toCompactHex() : sig.toDERHex();
        const hashed = str ? hex : hexToBytes(hex);
        return recovered ? [hashed, recovery] : hashed;
      }
      async function sign(msgHash, privKey, opts = {}) {
        return QRSToSig(await getQRSrfc6979(msgHash, privKey), opts, typeof msgHash === "string");
      }
      exports2.sign = sign;
      function signSync(msgHash, privKey, opts = {}) {
        return QRSToSig(getQRSrfc6979Sync(msgHash, privKey), opts, typeof msgHash === "string");
      }
      exports2.signSync = signSync;
      function verify(signature, msgHash, publicKey) {
        const { n } = CURVE;
        let sig;
        try {
          sig = normalizeSignature(signature);
        } catch (error) {
          return false;
        }
        const { r, s } = sig;
        const h = truncateHash(msgHash);
        if (h === 0n)
          return false;
        const pubKey = JacobianPoint.fromAffine(normalizePublicKey(publicKey));
        const s1 = invert(s, n);
        const u1 = mod2(h * s1, n);
        const u2 = mod2(r * s1, n);
        const Ghs1 = JacobianPoint.BASE.multiply(u1);
        const Prs1 = pubKey.multiplyUnsafe(u2);
        const R = Ghs1.add(Prs1).toAffine();
        const v = mod2(R.x, n);
        return v === r;
      }
      exports2.verify = verify;
      async function taggedHash(tag, ...messages) {
        const tagB = new Uint8Array(tag.split("").map((c) => c.charCodeAt(0)));
        const tagH = await exports2.utils.sha256(tagB);
        const h = await exports2.utils.sha256(concatBytes(tagH, tagH, ...messages));
        return bytesToNumber(h);
      }
      async function createChallenge(x, P, message) {
        const rx = pad32b(x);
        const t = await taggedHash("BIP0340/challenge", rx, P.toRawX(), message);
        return mod2(t, CURVE.n);
      }
      function hasEvenY(point) {
        return mod2(point.y, 2n) === 0n;
      }
      var SchnorrSignature = class {
        constructor(r, s) {
          this.r = r;
          this.s = s;
          if (r <= 0n || s <= 0n || r >= CURVE.P || s >= CURVE.n)
            throw new Error("Invalid signature");
        }
        static fromHex(hex) {
          const bytes = ensureBytes(hex);
          if (bytes.length !== 64) {
            throw new TypeError(`SchnorrSignature.fromHex: expected 64 bytes, not ${bytes.length}`);
          }
          const r = bytesToNumber(bytes.slice(0, 32));
          const s = bytesToNumber(bytes.slice(32));
          return new SchnorrSignature(r, s);
        }
        toHex() {
          return pad64(this.r) + pad64(this.s);
        }
        toRawBytes() {
          return hexToBytes(this.toHex());
        }
      };
      function schnorrGetPublicKey(privateKey) {
        const P = Point.fromPrivateKey(privateKey);
        return typeof privateKey === "string" ? P.toHexX() : P.toRawX();
      }
      async function schnorrSign(msgHash, privateKey, auxRand = exports2.utils.randomBytes()) {
        if (msgHash == null)
          throw new TypeError(`sign: Expected valid message, not "${msgHash}"`);
        if (!privateKey)
          privateKey = 0n;
        const { n } = CURVE;
        const m = ensureBytes(msgHash);
        const d0 = normalizePrivateKey(privateKey);
        const rand = ensureBytes(auxRand);
        if (rand.length !== 32)
          throw new TypeError("sign: Expected 32 bytes of aux randomness");
        const P = Point.fromPrivateKey(d0);
        const d = hasEvenY(P) ? d0 : n - d0;
        const t0h = await taggedHash("BIP0340/aux", rand);
        const t = d ^ t0h;
        const k0h = await taggedHash("BIP0340/nonce", pad32b(t), P.toRawX(), m);
        const k0 = mod2(k0h, n);
        if (k0 === 0n)
          throw new Error("sign: Creation of signature failed. k is zero");
        const R = Point.fromPrivateKey(k0);
        const k = hasEvenY(R) ? k0 : n - k0;
        const e = await createChallenge(R.x, P, m);
        const sig = new SchnorrSignature(R.x, mod2(k + e * d, n));
        const isValid = await schnorrVerify(sig.toRawBytes(), m, P.toRawX());
        if (!isValid)
          throw new Error("sign: Invalid signature produced");
        return typeof msgHash === "string" ? sig.toHex() : sig.toRawBytes();
      }
      async function schnorrVerify(signature, msgHash, publicKey) {
        const sig = signature instanceof SchnorrSignature ? signature : SchnorrSignature.fromHex(signature);
        const m = typeof msgHash === "string" ? hexToBytes(msgHash) : msgHash;
        const P = normalizePublicKey(publicKey);
        const e = await createChallenge(sig.r, P, m);
        const sG = Point.fromPrivateKey(sig.s);
        const eP = P.multiply(e);
        const R = sG.subtract(eP);
        if (R.equals(Point.BASE) || !hasEvenY(R) || R.x !== sig.r)
          return false;
        return true;
      }
      exports2.schnorr = {
        Signature: SchnorrSignature,
        getPublicKey: schnorrGetPublicKey,
        sign: schnorrSign,
        verify: schnorrVerify
      };
      Point.BASE._setWindowSize(8);
      var crypto2 = (() => {
        const webCrypto = typeof self === "object" && "crypto" in self ? self.crypto : void 0;
        const nodeRequire = typeof module2 !== "undefined" && typeof __require === "function";
        return {
          node: nodeRequire && !webCrypto ? require_crypto() : void 0,
          web: webCrypto
        };
      })();
      exports2.utils = {
        isValidPrivateKey(privateKey) {
          try {
            normalizePrivateKey(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        randomBytes: (bytesLength = 32) => {
          if (crypto2.web) {
            return crypto2.web.getRandomValues(new Uint8Array(bytesLength));
          } else if (crypto2.node) {
            const { randomBytes } = crypto2.node;
            return new Uint8Array(randomBytes(bytesLength).buffer);
          } else {
            throw new Error("The environment doesn't have randomBytes function");
          }
        },
        randomPrivateKey: () => {
          let i = 8;
          while (i--) {
            const b32 = exports2.utils.randomBytes(32);
            const num = bytesToNumber(b32);
            if (isWithinCurveOrder(num) && num !== 1n)
              return b32;
          }
          throw new Error("Valid private key was not found in 8 iterations. PRNG is broken");
        },
        sha256: async (message) => {
          if (crypto2.web) {
            const buffer = await crypto2.web.subtle.digest("SHA-256", message.buffer);
            return new Uint8Array(buffer);
          } else if (crypto2.node) {
            const { createHash } = crypto2.node;
            return Uint8Array.from(createHash("sha256").update(message).digest());
          } else {
            throw new Error("The environment doesn't have sha256 function");
          }
        },
        hmacSha256: async (key, ...messages) => {
          if (crypto2.web) {
            const ckey = await crypto2.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
            const message = concatBytes(...messages);
            const buffer = await crypto2.web.subtle.sign("HMAC", ckey, message);
            return new Uint8Array(buffer);
          } else if (crypto2.node) {
            const { createHmac } = crypto2.node;
            const hash = createHmac("sha256", key);
            for (let message of messages) {
              hash.update(message);
            }
            return Uint8Array.from(hash.digest());
          } else {
            throw new Error("The environment doesn't have hmac-sha256 function");
          }
        },
        sha256Sync: void 0,
        hmacSha256Sync: void 0,
        precompute(windowSize = 8, point = Point.BASE) {
          const cached = point === Point.BASE ? point : new Point(point.x, point.y);
          cached._setWindowSize(windowSize);
          cached.multiply(3n);
          return cached;
        }
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/secp256k1.js
  var require_secp256k12 = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/secp256k1.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var secp = require_secp256k1();
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      module2.exports = () => {
        const privateKeyLength = 32;
        function generateKey() {
          return secp.utils.randomPrivateKey();
        }
        async function hashAndSign(key, msg) {
          const { digest } = await sha2562.digest(msg);
          try {
            return await secp.sign(digest, key);
          } catch (err) {
            throw errcode(err, "ERR_INVALID_INPUT");
          }
        }
        async function hashAndVerify(key, sig, msg) {
          try {
            const { digest } = await sha2562.digest(msg);
            return secp.verify(sig, digest, key);
          } catch (err) {
            throw errcode(err, "ERR_INVALID_INPUT");
          }
        }
        function compressPublicKey(key) {
          const point = secp.Point.fromHex(key).toRawBytes(true);
          return point;
        }
        function decompressPublicKey(key) {
          const point = secp.Point.fromHex(key).toRawBytes(false);
          return point;
        }
        function validatePrivateKey(key) {
          try {
            secp.getPublicKey(key, true);
          } catch (err) {
            throw errcode(err, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        function validatePublicKey(key) {
          try {
            secp.Point.fromHex(key);
          } catch (err) {
            throw errcode(err, "ERR_INVALID_PUBLIC_KEY");
          }
        }
        function computePublicKey(privateKey) {
          try {
            return secp.getPublicKey(privateKey, true);
          } catch (err) {
            throw errcode(err, "ERR_INVALID_PRIVATE_KEY");
          }
        }
        return {
          generateKey,
          privateKeyLength,
          hashAndSign,
          hashAndVerify,
          compressPublicKey,
          decompressPublicKey,
          validatePrivateKey,
          validatePublicKey,
          computePublicKey
        };
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/secp256k1-class.js
  var require_secp256k1_class = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/secp256k1-class.js"(exports2, module2) {
      "use strict";
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var exporter = require_exporter();
      module2.exports = (keysProtobuf, randomBytes, crypto2) => {
        crypto2 = crypto2 || require_secp256k12()();
        class Secp256k1PublicKey {
          constructor(key) {
            crypto2.validatePublicKey(key);
            this._key = key;
          }
          verify(data, sig) {
            return crypto2.hashAndVerify(this._key, sig, data);
          }
          marshal() {
            return crypto2.compressPublicKey(this._key);
          }
          get bytes() {
            return keysProtobuf.PublicKey.encode({
              Type: keysProtobuf.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish();
          }
          equals(key) {
            return uint8ArrayEquals(this.bytes, key.bytes);
          }
          async hash() {
            const { bytes } = await sha2562.digest(this.bytes);
            return bytes;
          }
        }
        class Secp256k1PrivateKey {
          constructor(key, publicKey) {
            this._key = key;
            this._publicKey = publicKey || crypto2.computePublicKey(key);
            crypto2.validatePrivateKey(this._key);
            crypto2.validatePublicKey(this._publicKey);
          }
          sign(message) {
            return crypto2.hashAndSign(this._key, message);
          }
          get public() {
            return new Secp256k1PublicKey(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return keysProtobuf.PrivateKey.encode({
              Type: keysProtobuf.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish();
          }
          equals(key) {
            return uint8ArrayEquals(this.bytes, key.bytes);
          }
          async hash() {
            const { bytes } = await sha2562.digest(this.bytes);
            return bytes;
          }
          async id() {
            const hash = await this.public.hash();
            return uint8ArrayToString(hash, "base58btc");
          }
          async export(password, format = "libp2p-key") {
            if (format === "libp2p-key") {
              return exporter.export(this.bytes, password);
            } else {
              throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
            }
          }
        }
        function unmarshalSecp256k1PrivateKey(bytes) {
          return new Secp256k1PrivateKey(bytes);
        }
        function unmarshalSecp256k1PublicKey(bytes) {
          return new Secp256k1PublicKey(bytes);
        }
        async function generateKeyPair() {
          const privateKeyBytes = await crypto2.generateKey();
          return new Secp256k1PrivateKey(privateKeyBytes);
        }
        return {
          Secp256k1PublicKey,
          Secp256k1PrivateKey,
          unmarshalSecp256k1PrivateKey,
          unmarshalSecp256k1PublicKey,
          generateKeyPair
        };
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/hmac/lengths.js
  var require_lengths = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/hmac/lengths.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        SHA1: 20,
        SHA256: 32,
        SHA512: 64
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/hmac/index-browser.js
  var require_index_browser = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/hmac/index-browser.js"(exports2) {
      "use strict";
      var webcrypto = require_webcrypto();
      var lengths = require_lengths();
      var hashTypes = {
        SHA1: "SHA-1",
        SHA256: "SHA-256",
        SHA512: "SHA-512"
      };
      var sign = async (key, data) => {
        const buf = await webcrypto.get().subtle.sign({ name: "HMAC" }, key, data);
        return new Uint8Array(buf, buf.byteOffset, buf.byteLength);
      };
      exports2.create = async function(hashType, secret) {
        const hash = hashTypes[hashType];
        const key = await webcrypto.get().subtle.importKey("raw", secret, {
          name: "HMAC",
          hash: { name: hash }
        }, false, ["sign"]);
        return {
          async digest(data) {
            return sign(key, data);
          },
          length: lengths[hashType]
        };
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/key-stretcher.js
  var require_key_stretcher = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/key-stretcher.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var hmac = require_index_browser();
      var cipherMap = {
        "AES-128": {
          ivSize: 16,
          keySize: 16
        },
        "AES-256": {
          ivSize: 16,
          keySize: 32
        },
        Blowfish: {
          ivSize: 8,
          cipherKeySize: 32
        }
      };
      module2.exports = async (cipherType, hash, secret) => {
        const cipher = cipherMap[cipherType];
        if (!cipher) {
          const allowed = Object.keys(cipherMap).join(" / ");
          throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
        }
        if (!hash) {
          throw errcode(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
        }
        const cipherKeySize = cipher.keySize;
        const ivSize = cipher.ivSize;
        const hmacKeySize = 20;
        const seed = uint8ArrayFromString("key expansion");
        const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
        const m = await hmac.create(hash, secret);
        let a = await m.digest(seed);
        const result = [];
        let j = 0;
        while (j < resultLength) {
          const b = await m.digest(uint8ArrayConcat([a, seed]));
          let todo = b.length;
          if (j + todo > resultLength) {
            todo = resultLength - j;
          }
          result.push(b);
          j += todo;
          a = await m.digest(a);
        }
        const half = resultLength / 2;
        const resultBuffer = uint8ArrayConcat(result);
        const r1 = resultBuffer.slice(0, half);
        const r2 = resultBuffer.slice(half, resultLength);
        const createKey = (res) => ({
          iv: res.slice(0, ivSize),
          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
          macKey: res.slice(ivSize + cipherKeySize)
        });
        return {
          k1: createKey(r1),
          k2: createKey(r2)
        };
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/validate-curve-type.js
  var require_validate_curve_type = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/validate-curve-type.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      module2.exports = function(curveTypes, type) {
        if (!curveTypes.includes(type)) {
          const names = curveTypes.join(" / ");
          throw errcode(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
        }
      };
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ecdh-browser.js
  var require_ecdh_browser = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ecdh-browser.js"(exports2) {
      "use strict";
      var errcode = require_err_code();
      var webcrypto = require_webcrypto();
      var { base64urlToBuffer } = require_util2();
      var validateCurveType = require_validate_curve_type();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var bits = {
        "P-256": 256,
        "P-384": 384,
        "P-521": 521
      };
      exports2.generateEphmeralKeyPair = async function(curve) {
        validateCurveType(Object.keys(bits), curve);
        const pair = await webcrypto.get().subtle.generateKey({
          name: "ECDH",
          namedCurve: curve
        }, true, ["deriveBits"]);
        const genSharedKey = async (theirPub, forcePrivate) => {
          let privateKey;
          if (forcePrivate) {
            privateKey = await webcrypto.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
              name: "ECDH",
              namedCurve: curve
            }, false, ["deriveBits"]);
          } else {
            privateKey = pair.privateKey;
          }
          const keys = [
            await webcrypto.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
              name: "ECDH",
              namedCurve: curve
            }, false, []),
            privateKey
          ];
          const buffer = await webcrypto.get().subtle.deriveBits({
            name: "ECDH",
            namedCurve: curve,
            public: keys[0]
          }, keys[1], bits[curve]);
          return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);
        };
        const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
        return {
          key: marshalPublicKey(publicKey),
          genSharedKey
        };
      };
      var curveLengths = {
        "P-256": 32,
        "P-384": 48,
        "P-521": 66
      };
      function marshalPublicKey(jwk) {
        const byteLen = curveLengths[jwk.crv];
        return uint8ArrayConcat([
          Uint8Array.from([4]),
          base64urlToBuffer(jwk.x, byteLen),
          base64urlToBuffer(jwk.y, byteLen)
        ], 1 + byteLen * 2);
      }
      function unmarshalPublicKey(curve, key) {
        const byteLen = curveLengths[curve];
        if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
          throw errcode(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
        }
        return {
          kty: "EC",
          crv: curve,
          x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
          y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
          ext: true
        };
      }
      var unmarshalPrivateKey = (curve, key) => ({
        ...unmarshalPublicKey(curve, key.public),
        d: uint8ArrayToString(key.private, "base64url")
      });
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
  var require_ephemeral_keys = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"(exports2, module2) {
      "use strict";
      var ecdh = require_ecdh_browser();
      module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
    }
  });

  // node_modules/peer-id/node_modules/libp2p-crypto/src/keys/index.js
  var require_keys2 = __commonJS({
    "node_modules/peer-id/node_modules/libp2p-crypto/src/keys/index.js"(exports2, module2) {
      "use strict";
      var keysPBM = require_keys();
      require_asn1();
      require_pbe();
      var forge = require_forge();
      var errcode = require_err_code();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var importer = require_importer();
      var supportedKeys = {
        rsa: require_rsa_class(),
        ed25519: require_ed25519_class(),
        secp256k1: require_secp256k1_class()(keysPBM, require_random_bytes())
      };
      var ErrMissingSecp256K1 = {
        message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
        code: "ERR_MISSING_PACKAGE"
      };
      function typeToKey(type) {
        const key = supportedKeys[type.toLowerCase()];
        if (!key) {
          const supported = Object.keys(supportedKeys).join(" / ");
          throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
        }
        return key;
      }
      var generateKeyPair = async (type, bits) => {
        return typeToKey(type).generateKeyPair(bits);
      };
      var generateKeyPairFromSeed = async (type, seed, bits) => {
        const key = typeToKey(type);
        if (type.toLowerCase() !== "ed25519") {
          throw errcode(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
        }
        return key.generateKeyPairFromSeed(seed, bits);
      };
      var unmarshalPublicKey = (buf) => {
        const decoded = keysPBM.PublicKey.decode(buf);
        const data = decoded.Data;
        switch (decoded.Type) {
          case keysPBM.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPublicKey(data);
          case keysPBM.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
          case keysPBM.KeyType.Secp256k1:
            if (supportedKeys.secp256k1) {
              return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
            } else {
              throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
            }
          default:
            typeToKey(decoded.Type);
        }
      };
      var marshalPublicKey = (key, type) => {
        type = (type || "rsa").toLowerCase();
        typeToKey(type);
        return key.bytes;
      };
      var unmarshalPrivateKey = async (buf) => {
        const decoded = keysPBM.PrivateKey.decode(buf);
        const data = decoded.Data;
        switch (decoded.Type) {
          case keysPBM.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
          case keysPBM.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
          case keysPBM.KeyType.Secp256k1:
            if (supportedKeys.secp256k1) {
              return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
            } else {
              throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
            }
          default:
            typeToKey(decoded.Type);
        }
      };
      var marshalPrivateKey = (key, type) => {
        type = (type || "rsa").toLowerCase();
        typeToKey(type);
        return key.bytes;
      };
      var importKey = async (encryptedKey, password) => {
        try {
          const key2 = await importer.import(encryptedKey, password);
          return unmarshalPrivateKey(key2);
        } catch (_) {
        }
        const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
        if (key === null) {
          throw errcode(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
        }
        let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
        der = uint8ArrayFromString(der.getBytes(), "ascii");
        return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
      };
      module2.exports = {
        supportedKeys,
        keysPBM,
        keyStretcher: require_key_stretcher(),
        generateEphemeralKeyPair: require_ephemeral_keys(),
        generateKeyPair,
        generateKeyPairFromSeed,
        unmarshalPublicKey,
        marshalPublicKey,
        unmarshalPrivateKey,
        marshalPrivateKey,
        import: importKey
      };
    }
  });

  // node_modules/peer-id/src/proto.js
  var require_proto = __commonJS({
    "node_modules/peer-id/src/proto.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-peer-id"] || ($protobuf.roots["libp2p-peer-id"] = {});
      $root.PeerIdProto = function() {
        function PeerIdProto(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PeerIdProto.prototype.id = $util.newBuffer([]);
        PeerIdProto.prototype.pubKey = $util.newBuffer([]);
        PeerIdProto.prototype.privKey = $util.newBuffer([]);
        PeerIdProto.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          w.uint32(10).bytes(m.id);
          if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
            w.uint32(18).bytes(m.pubKey);
          if (m.privKey != null && Object.hasOwnProperty.call(m, "privKey"))
            w.uint32(26).bytes(m.privKey);
          return w;
        };
        PeerIdProto.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PeerIdProto();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.id = r.bytes();
                break;
              case 2:
                m.pubKey = r.bytes();
                break;
              case 3:
                m.privKey = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("id"))
            throw $util.ProtocolError("missing required 'id'", { instance: m });
          return m;
        };
        PeerIdProto.fromObject = function fromObject(d) {
          if (d instanceof $root.PeerIdProto)
            return d;
          var m = new $root.PeerIdProto();
          if (d.id != null) {
            if (typeof d.id === "string")
              $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);
            else if (d.id.length)
              m.id = d.id;
          }
          if (d.pubKey != null) {
            if (typeof d.pubKey === "string")
              $util.base64.decode(d.pubKey, m.pubKey = $util.newBuffer($util.base64.length(d.pubKey)), 0);
            else if (d.pubKey.length)
              m.pubKey = d.pubKey;
          }
          if (d.privKey != null) {
            if (typeof d.privKey === "string")
              $util.base64.decode(d.privKey, m.privKey = $util.newBuffer($util.base64.length(d.privKey)), 0);
            else if (d.privKey.length)
              m.privKey = d.privKey;
          }
          return m;
        };
        PeerIdProto.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.id = "";
            else {
              d.id = [];
              if (o.bytes !== Array)
                d.id = $util.newBuffer(d.id);
            }
            if (o.bytes === String)
              d.pubKey = "";
            else {
              d.pubKey = [];
              if (o.bytes !== Array)
                d.pubKey = $util.newBuffer(d.pubKey);
            }
            if (o.bytes === String)
              d.privKey = "";
            else {
              d.privKey = [];
              if (o.bytes !== Array)
                d.privKey = $util.newBuffer(d.privKey);
            }
          }
          if (m.id != null && m.hasOwnProperty("id")) {
            d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
          }
          if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
            d.pubKey = o.bytes === String ? $util.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
          }
          if (m.privKey != null && m.hasOwnProperty("privKey")) {
            d.privKey = o.bytes === String ? $util.base64.encode(m.privKey, 0, m.privKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.privKey) : m.privKey;
          }
          return d;
        };
        PeerIdProto.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PeerIdProto;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/peer-id/src/index.js
  var require_src8 = __commonJS({
    "node_modules/peer-id/src/index.js"(exports2, module2) {
      "use strict";
      var { CID: CID2 } = (init_cid(), cid_exports);
      var b32 = (init_base32(), base32_exports);
      var b36 = (init_base36(), base36_exports);
      var b58 = (init_base58(), base58_exports);
      var b64 = (init_base64(), base64_exports);
      var { base58btc: base58btc2 } = (init_base58(), base58_exports);
      var { base32: base322 } = (init_base32(), base32_exports);
      var { base16: base162 } = (init_base16(), base16_exports);
      var Digest4 = (init_digest(), digest_exports);
      var cryptoKeys = require_keys2();
      var withIs = require_class_is();
      var { PeerIdProto } = require_proto();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { identity: identity3 } = (init_identity2(), identity_exports2);
      var bases2 = {
        ...b32,
        ...b36,
        ...b58,
        ...b64
      };
      var baseDecoder = Object.keys(bases2).reduce((acc, curr) => acc.or(bases2[curr]), base322.decoder);
      var DAG_PB_CODE2 = 112;
      var LIBP2P_KEY_CODE = 114;
      var PeerId2 = class {
        constructor(id, privKey, pubKey) {
          if (!(id instanceof Uint8Array)) {
            throw new Error("invalid id provided");
          }
          if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {
            throw new Error("inconsistent arguments");
          }
          this._id = id;
          this._idB58String = base58btc2.encode(this.id).substring(1);
          this._privKey = privKey;
          this._pubKey = pubKey;
        }
        get id() {
          return this._id;
        }
        set id(val) {
          throw new Error("Id is immutable");
        }
        get privKey() {
          return this._privKey;
        }
        set privKey(privKey) {
          this._privKey = privKey;
        }
        get pubKey() {
          if (this._pubKey) {
            return this._pubKey;
          }
          if (this._privKey) {
            return this._privKey.public;
          }
          try {
            const decoded = Digest4.decode(this.id);
            if (decoded.code === identity3.code) {
              this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);
            }
          } catch (_) {
          }
          return this._pubKey;
        }
        set pubKey(pubKey) {
          this._pubKey = pubKey;
        }
        marshalPubKey() {
          if (this.pubKey) {
            return cryptoKeys.marshalPublicKey(this.pubKey);
          }
        }
        marshalPrivKey() {
          if (this.privKey) {
            return cryptoKeys.marshalPrivateKey(this.privKey);
          }
        }
        marshal(excludePriv) {
          return PeerIdProto.encode({
            id: this.toBytes(),
            pubKey: this.marshalPubKey(),
            privKey: excludePriv ? null : this.marshalPrivKey()
          }).finish();
        }
        toPrint() {
          let pid = this.toB58String();
          if (pid.startsWith("Qm")) {
            pid = pid.slice(2);
          }
          let maxRunes = 6;
          if (pid.length < maxRunes) {
            maxRunes = pid.length;
          }
          return "<peer.ID " + pid.substr(0, maxRunes) + ">";
        }
        toJSON() {
          return {
            id: this.toB58String(),
            privKey: toB64Opt(this.marshalPrivKey()),
            pubKey: toB64Opt(this.marshalPubKey())
          };
        }
        toHexString() {
          return base162.encode(this.id).substring(1);
        }
        toBytes() {
          return this.id;
        }
        toB58String() {
          return this._idB58String;
        }
        toString() {
          if (!this._idCIDString) {
            const cid = CID2.createV1(LIBP2P_KEY_CODE, Digest4.decode(this.id));
            Object.defineProperty(this, "_idCIDString", {
              value: cid.toString(),
              enumerable: false
            });
          }
          return this._idCIDString;
        }
        equals(id) {
          if (id instanceof Uint8Array) {
            return uint8ArrayEquals(this.id, id);
          } else if (id.id) {
            return uint8ArrayEquals(this.id, id.id);
          } else {
            throw new Error("not valid Id");
          }
        }
        isEqual(id) {
          return this.equals(id);
        }
        isValid() {
          return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));
        }
        hasInlinePublicKey() {
          try {
            const decoded = Digest4.decode(this.id);
            if (decoded.code === identity3.code) {
              return true;
            }
          } catch (_) {
          }
          return false;
        }
      };
      var PeerIdWithIs = withIs(PeerId2, {
        className: "PeerId",
        symbolName: "@libp2p/js-peer-id/PeerId"
      });
      exports2 = module2.exports = PeerIdWithIs;
      var computeDigest = (pubKey) => {
        if (pubKey.bytes.length <= 42) {
          return Digest4.create(identity3.code, pubKey.bytes).bytes;
        } else {
          return pubKey.hash();
        }
      };
      var computePeerId = async (privKey, pubKey) => {
        const digest = await computeDigest(pubKey);
        return new PeerIdWithIs(digest, privKey, pubKey);
      };
      exports2.create = async (opts) => {
        opts = opts || {};
        opts.bits = opts.bits || 2048;
        opts.keyType = opts.keyType || "RSA";
        const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);
        return computePeerId(key, key.public);
      };
      exports2.createFromHexString = (str) => {
        return new PeerIdWithIs(base162.decode("f" + str));
      };
      exports2.createFromBytes = (buf) => {
        try {
          const cid = CID2.decode(buf);
          if (!validMulticodec(cid)) {
            throw new Error("Supplied PeerID CID is invalid");
          }
          return exports2.createFromCID(cid);
        } catch {
          const digest = Digest4.decode(buf);
          if (digest.code !== identity3.code) {
            throw new Error("Supplied PeerID CID is invalid");
          }
          return new PeerIdWithIs(buf);
        }
      };
      exports2.createFromB58String = (str) => {
        return exports2.createFromBytes(base58btc2.decode("z" + str));
      };
      var validMulticodec = (cid) => {
        return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE2;
      };
      exports2.createFromCID = (cid) => {
        cid = CID2.asCID(cid);
        if (!cid || !validMulticodec(cid)) {
          throw new Error("Supplied PeerID CID is invalid");
        }
        return new PeerIdWithIs(cid.multihash.bytes);
      };
      exports2.createFromPubKey = async (key) => {
        let buf = key;
        if (typeof buf === "string") {
          buf = uint8ArrayFromString(key, "base64pad");
        }
        if (!(buf instanceof Uint8Array)) {
          throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
        }
        const pubKey = await cryptoKeys.unmarshalPublicKey(buf);
        return computePeerId(void 0, pubKey);
      };
      exports2.createFromPrivKey = async (key) => {
        if (typeof key === "string") {
          key = uint8ArrayFromString(key, "base64pad");
        }
        if (!(key instanceof Uint8Array)) {
          throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
        }
        const privKey = await cryptoKeys.unmarshalPrivateKey(key);
        return computePeerId(privKey, privKey.public);
      };
      exports2.createFromJSON = async (obj) => {
        const id = base58btc2.decode("z" + obj.id);
        const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, "base64pad");
        const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, "base64pad");
        const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey);
        if (!rawPrivKey) {
          return new PeerIdWithIs(id, void 0, pub);
        }
        const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);
        const privDigest = await computeDigest(privKey.public);
        let pubDigest;
        if (pub) {
          pubDigest = await computeDigest(pub);
        }
        if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {
          throw new Error("Public and private key do not match");
        }
        if (id && !uint8ArrayEquals(privDigest, id)) {
          throw new Error("Id and private key do not match");
        }
        return new PeerIdWithIs(id, privKey, pub);
      };
      exports2.createFromProtobuf = async (buf) => {
        if (typeof buf === "string") {
          buf = uint8ArrayFromString(buf, "base16");
        }
        let { id, privKey, pubKey } = PeerIdProto.decode(buf);
        privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;
        pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;
        let pubDigest;
        let privDigest;
        if (privKey) {
          privDigest = await computeDigest(privKey.public);
        }
        if (pubKey) {
          pubDigest = await computeDigest(pubKey);
        }
        if (privKey) {
          if (pubKey) {
            if (!uint8ArrayEquals(privDigest, pubDigest)) {
              throw new Error("Public and private key do not match");
            }
          }
          return new PeerIdWithIs(privDigest, privKey, privKey.public);
        }
        if (pubKey) {
          return new PeerIdWithIs(pubDigest, void 0, pubKey);
        }
        if (id) {
          return new PeerIdWithIs(id);
        }
        throw new Error("Protobuf did not contain any usable key material");
      };
      exports2.parse = (str) => {
        if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
          str = `z${str}`;
        }
        return exports2.createFromBytes(baseDecoder.decode(str));
      };
      exports2.isPeerId = (peerId) => {
        return Boolean(typeof peerId === "object" && peerId._id && peerId._idB58String);
      };
      function toB64Opt(val) {
        if (val) {
          return uint8ArrayToString(val, "base64pad");
        }
      }
    }
  });

  // node_modules/libp2p-crypto/src/webcrypto.js
  var require_webcrypto2 = __commonJS({
    "node_modules/libp2p-crypto/src/webcrypto.js"(exports2) {
      "use strict";
      exports2.get = (win = self) => {
        const nativeCrypto = win.crypto || win.msCrypto;
        if (!nativeCrypto || !nativeCrypto.subtle) {
          throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
        }
        return nativeCrypto;
      };
    }
  });

  // node_modules/libp2p-crypto/src/hmac/lengths.js
  var require_lengths2 = __commonJS({
    "node_modules/libp2p-crypto/src/hmac/lengths.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        SHA1: 20,
        SHA256: 32,
        SHA512: 64
      };
    }
  });

  // node_modules/libp2p-crypto/src/hmac/index-browser.js
  var require_index_browser2 = __commonJS({
    "node_modules/libp2p-crypto/src/hmac/index-browser.js"(exports2) {
      "use strict";
      var webcrypto = require_webcrypto2();
      var lengths = require_lengths2();
      var hashTypes = {
        SHA1: "SHA-1",
        SHA256: "SHA-256",
        SHA512: "SHA-512"
      };
      var sign = async (key, data) => {
        const buf = await webcrypto.get().subtle.sign({ name: "HMAC" }, key, data);
        return new Uint8Array(buf, buf.byteOffset, buf.byteLength);
      };
      exports2.create = async function(hashType, secret) {
        const hash = hashTypes[hashType];
        const key = await webcrypto.get().subtle.importKey("raw", secret, {
          name: "HMAC",
          hash: { name: hash }
        }, false, ["sign"]);
        return {
          async digest(data) {
            return sign(key, data);
          },
          length: lengths[hashType]
        };
      };
    }
  });

  // node_modules/libp2p-crypto/src/aes/ciphers-browser.js
  var require_ciphers_browser = __commonJS({
    "node_modules/libp2p-crypto/src/aes/ciphers-browser.js"(exports2, module2) {
      "use strict";
      require_aes();
      var forge = require_forge();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      module2.exports = {
        createCipheriv: (mode, key, iv) => {
          const cipher2 = forge.cipher.createCipher("AES-CTR", uint8ArrayToString(key, "ascii"));
          cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
          return {
            update: (data) => {
              cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
              return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
            }
          };
        },
        createDecipheriv: (mode, key, iv) => {
          const cipher2 = forge.cipher.createDecipher("AES-CTR", uint8ArrayToString(key, "ascii"));
          cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
          return {
            update: (data) => {
              cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
              return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
            }
          };
        }
      };
    }
  });

  // node_modules/libp2p-crypto/src/aes/cipher-mode.js
  var require_cipher_mode = __commonJS({
    "node_modules/libp2p-crypto/src/aes/cipher-mode.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var CIPHER_MODES = {
        16: "aes-128-ctr",
        32: "aes-256-ctr"
      };
      module2.exports = function(key) {
        const mode = CIPHER_MODES[key.length];
        if (!mode) {
          const modes = Object.entries(CIPHER_MODES).map(([k, v]) => `${k} (${v})`).join(" / ");
          throw errcode(new Error(`Invalid key length ${key.length} bytes. Must be ${modes}`), "ERR_INVALID_KEY_LENGTH");
        }
        return mode;
      };
    }
  });

  // node_modules/libp2p-crypto/src/aes/index.js
  var require_aes2 = __commonJS({
    "node_modules/libp2p-crypto/src/aes/index.js"(exports2) {
      "use strict";
      var ciphers = require_ciphers_browser();
      var cipherMode = require_cipher_mode();
      exports2.create = async function(key, iv) {
        const mode = cipherMode(key);
        const cipher = ciphers.createCipheriv(mode, key, iv);
        const decipher = ciphers.createDecipheriv(mode, key, iv);
        const res = {
          async encrypt(data) {
            return cipher.update(data);
          },
          async decrypt(data) {
            return decipher.update(data);
          }
        };
        return res;
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/keys.js
  var require_keys3 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/keys.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-crypto-keys"] || ($protobuf.roots["libp2p-crypto-keys"] = {});
      $root.KeyType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "RSA"] = 0;
        values[valuesById[1] = "Ed25519"] = 1;
        values[valuesById[2] = "Secp256k1"] = 2;
        return values;
      }();
      $root.PublicKey = function() {
        function PublicKey(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PublicKey.prototype.Type = 0;
        PublicKey.prototype.Data = $util.newBuffer([]);
        PublicKey.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          w.uint32(8).int32(m.Type);
          w.uint32(18).bytes(m.Data);
          return w;
        };
        PublicKey.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PublicKey();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.Type = r.int32();
                break;
              case 2:
                m.Data = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("Type"))
            throw $util.ProtocolError("missing required 'Type'", { instance: m });
          if (!m.hasOwnProperty("Data"))
            throw $util.ProtocolError("missing required 'Data'", { instance: m });
          return m;
        };
        PublicKey.fromObject = function fromObject(d) {
          if (d instanceof $root.PublicKey)
            return d;
          var m = new $root.PublicKey();
          switch (d.Type) {
            case "RSA":
            case 0:
              m.Type = 0;
              break;
            case "Ed25519":
            case 1:
              m.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              m.Type = 2;
              break;
          }
          if (d.Data != null) {
            if (typeof d.Data === "string")
              $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length)
              m.Data = d.Data;
          }
          return m;
        };
        PublicKey.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.Type = o.enums === String ? "RSA" : 0;
            if (o.bytes === String)
              d.Data = "";
            else {
              d.Data = [];
              if (o.bytes !== Array)
                d.Data = $util.newBuffer(d.Data);
            }
          }
          if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
          }
          if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
          }
          return d;
        };
        PublicKey.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PublicKey;
      }();
      $root.PrivateKey = function() {
        function PrivateKey(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PrivateKey.prototype.Type = 0;
        PrivateKey.prototype.Data = $util.newBuffer([]);
        PrivateKey.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          w.uint32(8).int32(m.Type);
          w.uint32(18).bytes(m.Data);
          return w;
        };
        PrivateKey.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PrivateKey();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.Type = r.int32();
                break;
              case 2:
                m.Data = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("Type"))
            throw $util.ProtocolError("missing required 'Type'", { instance: m });
          if (!m.hasOwnProperty("Data"))
            throw $util.ProtocolError("missing required 'Data'", { instance: m });
          return m;
        };
        PrivateKey.fromObject = function fromObject(d) {
          if (d instanceof $root.PrivateKey)
            return d;
          var m = new $root.PrivateKey();
          switch (d.Type) {
            case "RSA":
            case 0:
              m.Type = 0;
              break;
            case "Ed25519":
            case 1:
              m.Type = 1;
              break;
            case "Secp256k1":
            case 2:
              m.Type = 2;
              break;
          }
          if (d.Data != null) {
            if (typeof d.Data === "string")
              $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
            else if (d.Data.length)
              m.Data = d.Data;
          }
          return m;
        };
        PrivateKey.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.Type = o.enums === String ? "RSA" : 0;
            if (o.bytes === String)
              d.Data = "";
            else {
              d.Data = [];
              if (o.bytes !== Array)
                d.Data = $util.newBuffer(d.Data);
            }
          }
          if (m.Type != null && m.hasOwnProperty("Type")) {
            d.Type = o.enums === String ? $root.KeyType[m.Type] : m.Type;
          }
          if (m.Data != null && m.hasOwnProperty("Data")) {
            d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
          }
          return d;
        };
        PrivateKey.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return PrivateKey;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
  var require_aes_gcm_browser2 = __commonJS({
    "node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"(exports2, module2) {
      "use strict";
      var { concat: concat2 } = (init_concat(), concat_exports);
      var { fromString: fromString3 } = (init_from_string(), from_string_exports);
      var webcrypto = require_webcrypto2();
      function create3({
        algorithm = "AES-GCM",
        nonceLength = 12,
        keyLength = 16,
        digest = "SHA-256",
        saltLength = 16,
        iterations = 32767
      } = {}) {
        const crypto2 = webcrypto.get();
        keyLength *= 8;
        async function encrypt(data, password) {
          const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
          const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
          const aesGcm = { name: algorithm, iv: nonce };
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
          const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
          const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
          const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
          return concat2([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
        }
        async function decrypt(data, password) {
          const salt = data.slice(0, saltLength);
          const nonce = data.slice(saltLength, saltLength + nonceLength);
          const ciphertext = data.slice(saltLength + nonceLength);
          const aesGcm = { name: algorithm, iv: nonce };
          const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
          const rawKey = await crypto2.subtle.importKey("raw", fromString3(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
          const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
          const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
          return new Uint8Array(plaintext);
        }
        return {
          encrypt,
          decrypt
        };
      }
      module2.exports = {
        create: create3
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/importer.js
  var require_importer2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/importer.js"(exports2, module2) {
      "use strict";
      var { base64: base642 } = (init_base64(), base64_exports);
      var ciphers = require_aes_gcm_browser2();
      module2.exports = {
        import: async function(privateKey, password) {
          const encryptedKey = base642.decode(privateKey);
          const cipher = ciphers.create();
          return await cipher.decrypt(encryptedKey, password);
        }
      };
    }
  });

  // node_modules/node-forge/lib/asn1-validator.js
  var require_asn1_validator = __commonJS({
    "node_modules/node-forge/lib/asn1-validator.js"(exports2) {
      var forge = require_forge();
      require_asn1();
      var asn1 = forge.asn1;
      exports2.privateKeyValidator = {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "privateKey"
        }]
      };
      exports2.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "subjectPublicKeyInfo",
        value: [
          {
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "publicKeyOid"
            }]
          },
          {
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            composed: true,
            captureBitStringValue: "ed25519PublicKey"
          }
        ]
      };
    }
  });

  // node_modules/node-forge/lib/ed25519.js
  var require_ed255193 = __commonJS({
    "node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
      var forge = require_forge();
      require_jsbn();
      require_random2();
      require_sha512();
      require_util();
      var asn1Validator = require_asn1_validator();
      var publicKeyValidator = asn1Validator.publicKeyValidator;
      var privateKeyValidator = asn1Validator.privateKeyValidator;
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var ByteBuffer = forge.util.ByteBuffer;
      var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
      forge.pki = forge.pki || {};
      module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
      var ed25519 = forge.ed25519;
      ed25519.constants = {};
      ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
      ed25519.constants.SEED_BYTE_LENGTH = 32;
      ed25519.constants.SIGN_BYTE_LENGTH = 64;
      ed25519.constants.HASH_BYTE_LENGTH = 64;
      ed25519.generateKeyPair = function(options) {
        options = options || {};
        var seed = options.seed;
        if (seed === void 0) {
          seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
        } else if (typeof seed === "string") {
          if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
            throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
          }
        } else if (!(seed instanceof Uint8Array)) {
          throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
        }
        seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
        var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        for (var i = 0; i < 32; ++i) {
          sk[i] = seed[i];
        }
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, privateKey: sk };
      };
      ed25519.privateKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
        if (!valid) {
          var error = new Error("Invalid Key.");
          error.errors = errors;
          throw error;
        }
        var oid = forge.asn1.derToOid(capture.privateKeyOid);
        var ed25519Oid = forge.oids.EdDSA25519;
        if (oid !== ed25519Oid) {
          throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
        }
        var privateKey = capture.privateKey;
        var privateKeyBytes = messageToNativeBuffer({
          message: forge.asn1.fromDer(privateKey).value,
          encoding: "binary"
        });
        return { privateKeyBytes };
      };
      ed25519.publicKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
        if (!valid) {
          var error = new Error("Invalid Key.");
          error.errors = errors;
          throw error;
        }
        var oid = forge.asn1.derToOid(capture.publicKeyOid);
        var ed25519Oid = forge.oids.EdDSA25519;
        if (oid !== ed25519Oid) {
          throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
        }
        var publicKeyBytes = capture.ed25519PublicKey;
        if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
          throw new Error("Key length is invalid.");
        }
        return messageToNativeBuffer({
          message: publicKeyBytes,
          encoding: "binary"
        });
      };
      ed25519.publicKeyFromPrivateKey = function(options) {
        options = options || {};
        var privateKey = messageToNativeBuffer({
          message: options.privateKey,
          encoding: "binary"
        });
        if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        }
        var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        for (var i = 0; i < pk.length; ++i) {
          pk[i] = privateKey[32 + i];
        }
        return pk;
      };
      ed25519.sign = function(options) {
        options = options || {};
        var msg = messageToNativeBuffer(options);
        var privateKey = messageToNativeBuffer({
          message: options.privateKey,
          encoding: "binary"
        });
        if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
          var keyPair = ed25519.generateKeyPair({ seed: privateKey });
          privateKey = keyPair.privateKey;
        } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        }
        var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        crypto_sign(signedMsg, msg, msg.length, privateKey);
        var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
        for (var i = 0; i < sig.length; ++i) {
          sig[i] = signedMsg[i];
        }
        return sig;
      };
      ed25519.verify = function(options) {
        options = options || {};
        var msg = messageToNativeBuffer(options);
        if (options.signature === void 0) {
          throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
        }
        var sig = messageToNativeBuffer({
          message: options.signature,
          encoding: "binary"
        });
        if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
          throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
        }
        var publicKey = messageToNativeBuffer({
          message: options.publicKey,
          encoding: "binary"
        });
        if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        }
        var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        var i;
        for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
          sm[i] = sig[i];
        }
        for (i = 0; i < msg.length; ++i) {
          sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
        }
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      function messageToNativeBuffer(options) {
        var message = options.message;
        if (message instanceof Uint8Array || message instanceof NativeBuffer) {
          return message;
        }
        var encoding = options.encoding;
        if (message === void 0) {
          if (options.md) {
            message = options.md.digest().getBytes();
            encoding = "binary";
          } else {
            throw new TypeError('"options.message" or "options.md" not specified.');
          }
        }
        if (typeof message === "string" && !encoding) {
          throw new TypeError('"options.encoding" must be "binary" or "utf8".');
        }
        if (typeof message === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.from(message, encoding);
          }
          message = new ByteBuffer(message, encoding);
        } else if (!(message instanceof ByteBuffer)) {
          throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
        }
        var buffer = new NativeBuffer(message.length());
        for (var i = 0; i < buffer.length; ++i) {
          buffer[i] = message.at(i);
        }
        return buffer;
      }
      var gf0 = gf();
      var gf1 = gf([1]);
      var D = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995
      ]);
      var D2 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222
      ]);
      var X = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553
      ]);
      var Y = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214
      ]);
      var L = new Float64Array([
        237,
        211,
        245,
        92,
        26,
        99,
        18,
        88,
        214,
        156,
        247,
        162,
        222,
        249,
        222,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16
      ]);
      var I = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139
      ]);
      function sha5122(msg, msgLen) {
        var md = forge.md.sha512.create();
        var buffer = new ByteBuffer(msg);
        md.update(buffer.getBytes(msgLen), "binary");
        var hash = md.digest().getBytes();
        if (typeof Buffer !== "undefined") {
          return Buffer.from(hash, "binary");
        }
        var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
        for (var i = 0; i < 64; ++i) {
          out[i] = hash.charCodeAt(i);
        }
        return out;
      }
      function crypto_sign_keypair(pk, sk) {
        var p = [gf(), gf(), gf(), gf()];
        var i;
        var d = sha5122(sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; ++i) {
          sk[i + 32] = pk[i];
        }
        return 0;
      }
      function crypto_sign(sm, m, n, sk) {
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var d = sha5122(sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; ++i) {
          sm[64 + i] = m[i];
        }
        for (i = 0; i < 32; ++i) {
          sm[32 + i] = d[32 + i];
        }
        var r = sha5122(sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; ++i) {
          sm[i] = sk[i];
        }
        var h = sha5122(sm, n + 64);
        reduce(h);
        for (i = 32; i < 64; ++i) {
          x[i] = 0;
        }
        for (i = 0; i < 32; ++i) {
          x[i] = r[i];
        }
        for (i = 0; i < 32; ++i) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new NativeBuffer(32);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64) {
          return -1;
        }
        if (unpackneg(q, pk)) {
          return -1;
        }
        for (i = 0; i < n; ++i) {
          m[i] = sm[i];
        }
        for (i = 0; i < 32; ++i) {
          m[i + 32] = pk[i];
        }
        var h = sha5122(m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; ++i) {
            m[i] = 0;
          }
          return -1;
        }
        for (i = 0; i < n; ++i) {
          m[i] = sm[i + 64];
        }
        mlen = n;
        return mlen;
      }
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; ++j) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; ++j) {
          x[j] -= carry * L[j];
        }
        for (i = 0; i < 32; ++i) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64);
        for (var i = 0; i < 64; ++i) {
          x[i] = r[i];
          r[i] = 0;
        }
        modL(r, x);
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        for (var i = 0; i < 4; ++i) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; ++i) {
          t[i] = n[i];
        }
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; ++j) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; ++i) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) {
          M(r[0], r[0], I);
        }
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) {
          return -1;
        }
        if (par25519(r[0]) === p[31] >> 7) {
          Z(r[0], gf0, r[0]);
        }
        M(r[3], r[0], r[1]);
        return 0;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; ++i) {
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 32767;
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; ++a) {
          c[a] = i[a];
        }
        for (a = 250; a >= 0; --a) {
          S(c, c);
          if (a !== 1) {
            M(c, c, i);
          }
        }
        for (a = 0; a < 16; ++a) {
          o[a] = c[a];
        }
      }
      function neq25519(a, b) {
        var c = new NativeBuffer(32);
        var d = new NativeBuffer(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; ++i) {
          d |= x[xi + i] ^ y[yi + i];
        }
        return (1 & d - 1 >>> 8) - 1;
      }
      function par25519(a) {
        var d = new NativeBuffer(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) {
          r[i] = a[i] | 0;
        }
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; ++a) {
          c[a] = i[a];
        }
        for (a = 253; a >= 0; --a) {
          S(c, c);
          if (a !== 2 && a !== 4) {
            M(c, c, i);
          }
        }
        for (a = 0; a < 16; ++a) {
          o[a] = c[a];
        }
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; ++i) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; ++i) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function gf(init) {
        var i, r = new Float64Array(16);
        if (init) {
          for (i = 0; i < init.length; ++i) {
            r[i] = init[i];
          }
        }
        return r;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; ++i) {
          o[i] = a[i] + b[i];
        }
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; ++i) {
          o[i] = a[i] - b[i];
        }
      }
      function S(o, a) {
        M(o, a, a);
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
    }
  });

  // node_modules/libp2p-crypto/src/random-bytes.js
  var require_random_bytes2 = __commonJS({
    "node_modules/libp2p-crypto/src/random-bytes.js"(exports2, module2) {
      "use strict";
      var randomBytes = require_random_browser();
      var errcode = require_err_code();
      module2.exports = function(length2) {
        if (isNaN(length2) || length2 <= 0) {
          throw errcode(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
        }
        return randomBytes(length2);
      };
    }
  });

  // node_modules/libp2p-crypto/src/util.js
  var require_util3 = __commonJS({
    "node_modules/libp2p-crypto/src/util.js"(exports2) {
      "use strict";
      require_util();
      require_jsbn();
      var forge = require_forge();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      exports2.bigIntegerToUintBase64url = (num, len) => {
        let buf = Uint8Array.from(num.abs().toByteArray());
        buf = buf[0] === 0 ? buf.slice(1) : buf;
        if (len != null) {
          if (buf.length > len)
            throw new Error("byte array longer than desired length");
          buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
        }
        return uint8ArrayToString(buf, "base64url");
      };
      exports2.base64urlToBigInteger = (str) => {
        const buf = exports2.base64urlToBuffer(str);
        return new forge.jsbn.BigInteger(uint8ArrayToString(buf, "base16"), 16);
      };
      exports2.base64urlToBuffer = (str, len) => {
        let buf = uint8ArrayFromString(str, "base64urlpad");
        if (len != null) {
          if (buf.length > len)
            throw new Error("byte array longer than desired length");
          buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
        }
        return buf;
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/rsa-utils.js
  var require_rsa_utils2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/rsa-utils.js"(exports2) {
      "use strict";
      require_asn1();
      require_rsa();
      var forge = require_forge();
      var { bigIntegerToUintBase64url, base64urlToBigInteger } = require_util3();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      exports2.pkcs1ToJwk = function(bytes) {
        const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
        const privateKey = forge.pki.privateKeyFromAsn1(asn1);
        return {
          kty: "RSA",
          n: bigIntegerToUintBase64url(privateKey.n),
          e: bigIntegerToUintBase64url(privateKey.e),
          d: bigIntegerToUintBase64url(privateKey.d),
          p: bigIntegerToUintBase64url(privateKey.p),
          q: bigIntegerToUintBase64url(privateKey.q),
          dp: bigIntegerToUintBase64url(privateKey.dP),
          dq: bigIntegerToUintBase64url(privateKey.dQ),
          qi: bigIntegerToUintBase64url(privateKey.qInv),
          alg: "RS256",
          kid: "2011-04-29"
        };
      };
      exports2.jwkToPkcs1 = function(jwk) {
        const asn1 = forge.pki.privateKeyToAsn1({
          n: base64urlToBigInteger(jwk.n),
          e: base64urlToBigInteger(jwk.e),
          d: base64urlToBigInteger(jwk.d),
          p: base64urlToBigInteger(jwk.p),
          q: base64urlToBigInteger(jwk.q),
          dP: base64urlToBigInteger(jwk.dp),
          dQ: base64urlToBigInteger(jwk.dq),
          qInv: base64urlToBigInteger(jwk.qi)
        });
        return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
      };
      exports2.pkixToJwk = function(bytes) {
        const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
        const publicKey = forge.pki.publicKeyFromAsn1(asn1);
        return {
          kty: "RSA",
          n: bigIntegerToUintBase64url(publicKey.n),
          e: bigIntegerToUintBase64url(publicKey.e),
          alg: "RS256",
          kid: "2011-04-29"
        };
      };
      exports2.jwkToPkix = function(jwk) {
        const asn1 = forge.pki.publicKeyToAsn1({
          n: base64urlToBigInteger(jwk.n),
          e: base64urlToBigInteger(jwk.e)
        });
        return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/jwk2pem.js
  var require_jwk2pem2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/jwk2pem.js"(exports2, module2) {
      "use strict";
      require_rsa();
      var forge = require_forge();
      var { base64urlToBigInteger } = require_util3();
      function convert(key, types) {
        return types.map((t) => base64urlToBigInteger(key[t]));
      }
      function jwk2priv(key) {
        return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
      }
      function jwk2pub(key) {
        return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
      }
      module2.exports = {
        jwk2pub,
        jwk2priv
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/rsa-browser.js
  var require_rsa_browser2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/rsa-browser.js"(exports2) {
      "use strict";
      var webcrypto = require_webcrypto2();
      var randomBytes = require_random_bytes2();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      exports2.utils = require_rsa_utils2();
      exports2.generateKey = async function(bits) {
        const pair = await webcrypto.get().subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: new Uint8Array([1, 0, 1]),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]);
        const keys = await exportKey(pair);
        return {
          privateKey: keys[0],
          publicKey: keys[1]
        };
      };
      exports2.unmarshalPrivateKey = async function(key) {
        const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["sign"]);
        const pair = [
          privateKey,
          await derivePublicFromPrivate(key)
        ];
        const keys = await exportKey({
          privateKey: pair[0],
          publicKey: pair[1]
        });
        return {
          privateKey: keys[0],
          publicKey: keys[1]
        };
      };
      exports2.getRandomValues = randomBytes;
      exports2.hashAndSign = async function(key, msg) {
        const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, false, ["sign"]);
        const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
        return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
      };
      exports2.hashAndVerify = async function(key, sig, msg) {
        const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, false, ["verify"]);
        return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
      };
      function exportKey(pair) {
        return Promise.all([
          webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
          webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
        ]);
      }
      function derivePublicFromPrivate(jwKey) {
        return webcrypto.get().subtle.importKey("jwk", {
          kty: jwKey.kty,
          n: jwKey.n,
          e: jwKey.e
        }, {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        }, true, ["verify"]);
      }
      var { jwk2pub, jwk2priv } = require_jwk2pem2();
      function convertKey(key, pub, msg, handle) {
        const fkey = pub ? jwk2pub(key) : jwk2priv(key);
        const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
        const fomsg = handle(fmsg, fkey);
        return uint8ArrayFromString(fomsg, "ascii");
      }
      exports2.encrypt = function(key, msg) {
        return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
      };
      exports2.decrypt = function(key, msg) {
        return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/exporter.js
  var require_exporter2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/exporter.js"(exports2, module2) {
      "use strict";
      var { base64: base642 } = (init_base64(), base64_exports);
      var ciphers = require_aes_gcm_browser2();
      module2.exports = {
        export: async function(privateKey, password) {
          const cipher = ciphers.create();
          const encryptedKey = await cipher.encrypt(privateKey, password);
          return base642.encode(encryptedKey);
        }
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/rsa-class.js
  var require_rsa_class2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/rsa-class.js"(exports2, module2) {
      "use strict";
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      require_sha512();
      require_ed255193();
      var forge = require_forge();
      var crypto2 = require_rsa_browser2();
      var pbm = require_keys3();
      var exporter = require_exporter2();
      var RsaPublicKey = class {
        constructor(key) {
          this._key = key;
        }
        async verify(data, sig) {
          return crypto2.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return crypto2.utils.jwkToPkix(this._key);
        }
        get bytes() {
          return pbm.PublicKey.encode({
            Type: pbm.KeyType.RSA,
            Data: this.marshal()
          }).finish();
        }
        encrypt(bytes) {
          return crypto2.encrypt(this._key, bytes);
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
      };
      var RsaPrivateKey = class {
        constructor(key, publicKey) {
          this._key = key;
          this._publicKey = publicKey;
        }
        genSecret() {
          return crypto2.getRandomValues(16);
        }
        async sign(message) {
          return crypto2.hashAndSign(this._key, message);
        }
        get public() {
          if (!this._publicKey) {
            throw errcode(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
          }
          return new RsaPublicKey(this._publicKey);
        }
        decrypt(bytes) {
          return crypto2.decrypt(this._key, bytes);
        }
        marshal() {
          return crypto2.utils.jwkToPkcs1(this._key);
        }
        get bytes() {
          return pbm.PrivateKey.encode({
            Type: pbm.KeyType.RSA,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
        async id() {
          const hash = await this.public.hash();
          return uint8ArrayToString(hash, "base58btc");
        }
        async export(password, format = "pkcs-8") {
          if (format === "pkcs-8") {
            const buffer = new forge.util.ByteBuffer(this.marshal());
            const asn1 = forge.asn1.fromDer(buffer);
            const privateKey = forge.pki.privateKeyFromAsn1(asn1);
            const options = {
              algorithm: "aes256",
              count: 1e4,
              saltSize: 128 / 8,
              prfAlgorithm: "sha512"
            };
            return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
          } else if (format === "libp2p-key") {
            return exporter.export(this.bytes, password);
          } else {
            throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      };
      async function unmarshalRsaPrivateKey(bytes) {
        const jwk = crypto2.utils.pkcs1ToJwk(bytes);
        const keys = await crypto2.unmarshalPrivateKey(jwk);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      function unmarshalRsaPublicKey(bytes) {
        const jwk = crypto2.utils.pkixToJwk(bytes);
        return new RsaPublicKey(jwk);
      }
      async function fromJwk(jwk) {
        const keys = await crypto2.unmarshalPrivateKey(jwk);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      async function generateKeyPair(bits) {
        const keys = await crypto2.generateKey(bits);
        return new RsaPrivateKey(keys.privateKey, keys.publicKey);
      }
      module2.exports = {
        RsaPublicKey,
        RsaPrivateKey,
        unmarshalRsaPublicKey,
        unmarshalRsaPrivateKey,
        generateKeyPair,
        fromJwk
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/ed25519.js
  var require_ed255194 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/ed25519.js"(exports2) {
      "use strict";
      require_ed255193();
      var forge = require_forge();
      exports2.publicKeyLength = forge.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
      exports2.privateKeyLength = forge.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
      exports2.generateKey = async function() {
        return forge.pki.ed25519.generateKeyPair();
      };
      exports2.generateKeyFromSeed = async function(seed) {
        return forge.pki.ed25519.generateKeyPair({ seed });
      };
      exports2.hashAndSign = async function(key, msg) {
        return forge.pki.ed25519.sign({ message: msg, privateKey: key });
      };
      exports2.hashAndVerify = async function(key, sig, msg) {
        return forge.pki.ed25519.verify({ signature: sig, message: msg, publicKey: key });
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/ed25519-class.js
  var require_ed25519_class2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/ed25519-class.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var { base58btc: base58btc2 } = (init_base58(), base58_exports);
      var { identity: identity3 } = (init_identity2(), identity_exports2);
      var crypto2 = require_ed255194();
      var pbm = require_keys3();
      var exporter = require_exporter2();
      var Ed25519PublicKey = class {
        constructor(key) {
          this._key = ensureKey(key, crypto2.publicKeyLength);
        }
        async verify(data, sig) {
          return crypto2.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return pbm.PublicKey.encode({
            Type: pbm.KeyType.Ed25519,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
      };
      var Ed25519PrivateKey = class {
        constructor(key, publicKey) {
          this._key = ensureKey(key, crypto2.privateKeyLength);
          this._publicKey = ensureKey(publicKey, crypto2.publicKeyLength);
        }
        async sign(message) {
          return crypto2.hashAndSign(this._key, message);
        }
        get public() {
          return new Ed25519PublicKey(this._publicKey);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return pbm.PrivateKey.encode({
            Type: pbm.KeyType.Ed25519,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes } = await sha2562.digest(this.bytes);
          return bytes;
        }
        async id() {
          const encoding = await identity3.digest(this.public.bytes);
          return base58btc2.encode(encoding.bytes).substring(1);
        }
        async export(password, format = "libp2p-key") {
          if (format === "libp2p-key") {
            return exporter.export(this.bytes, password);
          } else {
            throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      };
      function unmarshalEd25519PrivateKey(bytes) {
        if (bytes.length > crypto2.privateKeyLength) {
          bytes = ensureKey(bytes, crypto2.privateKeyLength + crypto2.publicKeyLength);
          const privateKeyBytes2 = bytes.slice(0, crypto2.privateKeyLength);
          const publicKeyBytes2 = bytes.slice(crypto2.privateKeyLength, bytes.length);
          return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
        }
        bytes = ensureKey(bytes, crypto2.privateKeyLength);
        const privateKeyBytes = bytes.slice(0, crypto2.privateKeyLength);
        const publicKeyBytes = bytes.slice(crypto2.publicKeyLength);
        return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
      }
      function unmarshalEd25519PublicKey(bytes) {
        bytes = ensureKey(bytes, crypto2.publicKeyLength);
        return new Ed25519PublicKey(bytes);
      }
      async function generateKeyPair() {
        const { privateKey, publicKey } = await crypto2.generateKey();
        return new Ed25519PrivateKey(privateKey, publicKey);
      }
      async function generateKeyPairFromSeed(seed) {
        const { privateKey, publicKey } = await crypto2.generateKeyFromSeed(seed);
        return new Ed25519PrivateKey(privateKey, publicKey);
      }
      function ensureKey(key, length2) {
        key = Uint8Array.from(key || []);
        if (key.length !== length2) {
          throw errcode(new Error(`Key must be a Uint8Array of length ${length2}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
        }
        return key;
      }
      module2.exports = {
        Ed25519PublicKey,
        Ed25519PrivateKey,
        unmarshalEd25519PrivateKey,
        unmarshalEd25519PublicKey,
        generateKeyPair,
        generateKeyPairFromSeed
      };
    }
  });

  // node_modules/secp256k1/lib/index.js
  var require_lib = __commonJS({
    "node_modules/secp256k1/lib/index.js"(exports2, module2) {
      var errors = {
        IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
        TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
        TWEAK_MUL: "The tweak was out of range or equal to zero",
        CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
        SECKEY_INVALID: "Private Key is invalid",
        PUBKEY_PARSE: "Public Key could not be parsed",
        PUBKEY_SERIALIZE: "Public Key serialization error",
        PUBKEY_COMBINE: "The sum of the public keys is not valid",
        SIG_PARSE: "Signature could not be parsed",
        SIGN: "The nonce generation function failed, or the private key was invalid",
        RECOVER: "Public key could not be recover",
        ECDH: "Scalar was invalid (zero or overflow)"
      };
      function assert(cond, msg) {
        if (!cond)
          throw new Error(msg);
      }
      function isUint8Array(name, value, length2) {
        assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
        if (length2 !== void 0) {
          if (Array.isArray(length2)) {
            const numbers = length2.join(", ");
            const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
            assert(length2.includes(value.length), msg);
          } else {
            const msg = `Expected ${name} to be an Uint8Array with length ${length2}`;
            assert(value.length === length2, msg);
          }
        }
      }
      function isCompressed(value) {
        assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
      }
      function getAssertedOutput(output = (len) => new Uint8Array(len), length2) {
        if (typeof output === "function")
          output = output(length2);
        isUint8Array("output", output, length2);
        return output;
      }
      function toTypeString(value) {
        return Object.prototype.toString.call(value).slice(8, -1);
      }
      module2.exports = (secp256k1) => {
        return {
          contextRandomize(seed) {
            assert(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
            if (seed !== null)
              isUint8Array("seed", seed, 32);
            switch (secp256k1.contextRandomize(seed)) {
              case 1:
                throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
            }
          },
          privateKeyVerify(seckey) {
            isUint8Array("private key", seckey, 32);
            return secp256k1.privateKeyVerify(seckey) === 0;
          },
          privateKeyNegate(seckey) {
            isUint8Array("private key", seckey, 32);
            switch (secp256k1.privateKeyNegate(seckey)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          privateKeyTweakAdd(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.TWEAK_ADD);
            }
          },
          privateKeyTweakMul(seckey, tweak) {
            isUint8Array("private key", seckey, 32);
            isUint8Array("tweak", tweak, 32);
            switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
              case 0:
                return seckey;
              case 1:
                throw new Error(errors.TWEAK_MUL);
            }
          },
          publicKeyVerify(pubkey) {
            isUint8Array("public key", pubkey, [33, 65]);
            return secp256k1.publicKeyVerify(pubkey) === 0;
          },
          publicKeyCreate(seckey, compressed = true, output) {
            isUint8Array("private key", seckey, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyCreate(output, seckey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.SECKEY_INVALID);
              case 2:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyConvert(pubkey, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyConvert(output, pubkey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyNegate(pubkey, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyNegate(output, pubkey)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
              case 3:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyCombine(pubkeys, compressed = true, output) {
            assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
            assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
            for (const pubkey of pubkeys) {
              isUint8Array("public key", pubkey, [33, 65]);
            }
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyCombine(output, pubkeys)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_COMBINE);
              case 3:
                throw new Error(errors.PUBKEY_SERIALIZE);
            }
          },
          publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.TWEAK_ADD);
            }
          },
          publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("tweak", tweak, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.TWEAK_MUL);
            }
          },
          signatureNormalize(sig) {
            isUint8Array("signature", sig, 64);
            switch (secp256k1.signatureNormalize(sig)) {
              case 0:
                return sig;
              case 1:
                throw new Error(errors.SIG_PARSE);
            }
          },
          signatureExport(sig, output) {
            isUint8Array("signature", sig, 64);
            output = getAssertedOutput(output, 72);
            const obj = { output, outputlen: 72 };
            switch (secp256k1.signatureExport(obj, sig)) {
              case 0:
                return output.slice(0, obj.outputlen);
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          signatureImport(sig, output) {
            isUint8Array("signature", sig);
            output = getAssertedOutput(output, 64);
            switch (secp256k1.signatureImport(output, sig)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdsaSign(msg32, seckey, options = {}, output) {
            isUint8Array("message", msg32, 32);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0)
              isUint8Array("options.data", options.data);
            if (options.noncefn !== void 0)
              assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
            output = getAssertedOutput(output, 64);
            const obj = { signature: output, recid: null };
            switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
              case 0:
                return obj;
              case 1:
                throw new Error(errors.SIGN);
              case 2:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdsaVerify(sig, msg32, pubkey) {
            isUint8Array("signature", sig, 64);
            isUint8Array("message", msg32, 32);
            isUint8Array("public key", pubkey, [33, 65]);
            switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
              case 0:
                return true;
              case 3:
                return false;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.PUBKEY_PARSE);
            }
          },
          ecdsaRecover(sig, recid, msg32, compressed = true, output) {
            isUint8Array("signature", sig, 64);
            assert(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
            isUint8Array("message", msg32, 32);
            isCompressed(compressed);
            output = getAssertedOutput(output, compressed ? 33 : 65);
            switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.SIG_PARSE);
              case 2:
                throw new Error(errors.RECOVER);
              case 3:
                throw new Error(errors.IMPOSSIBLE_CASE);
            }
          },
          ecdh(pubkey, seckey, options = {}, output) {
            isUint8Array("public key", pubkey, [33, 65]);
            isUint8Array("private key", seckey, 32);
            assert(toTypeString(options) === "Object", "Expected options to be an Object");
            if (options.data !== void 0)
              isUint8Array("options.data", options.data);
            if (options.hashfn !== void 0) {
              assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
              if (options.xbuf !== void 0)
                isUint8Array("options.xbuf", options.xbuf, 32);
              if (options.ybuf !== void 0)
                isUint8Array("options.ybuf", options.ybuf, 32);
              isUint8Array("output", output);
            } else {
              output = getAssertedOutput(output, 32);
            }
            switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
              case 0:
                return output;
              case 1:
                throw new Error(errors.PUBKEY_PARSE);
              case 2:
                throw new Error(errors.ECDH);
            }
          }
        };
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/secp256k1.js
  var require_secp256k13 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/secp256k1.js"(exports2, module2) {
      "use strict";
      var secp256k1 = require_lib();
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      module2.exports = (randomBytes) => {
        const privateKeyLength = 32;
        function generateKey() {
          let privateKey;
          do {
            privateKey = randomBytes(32);
          } while (!secp256k1.privateKeyVerify(privateKey));
          return privateKey;
        }
        async function hashAndSign(key, msg) {
          const { digest } = await sha2562.digest(msg);
          const sig = secp256k1.ecdsaSign(digest, key);
          return secp256k1.signatureExport(sig.signature);
        }
        async function hashAndVerify(key, sig, msg) {
          const { digest } = await sha2562.digest(msg);
          sig = secp256k1.signatureImport(sig);
          return secp256k1.ecdsaVerify(sig, digest, key);
        }
        function compressPublicKey(key) {
          if (!secp256k1.publicKeyVerify(key)) {
            throw new Error("Invalid public key");
          }
          return secp256k1.publicKeyConvert(key, true);
        }
        function decompressPublicKey(key) {
          return secp256k1.publicKeyConvert(key, false);
        }
        function validatePrivateKey(key) {
          if (!secp256k1.privateKeyVerify(key)) {
            throw new Error("Invalid private key");
          }
        }
        function validatePublicKey(key) {
          if (!secp256k1.publicKeyVerify(key)) {
            throw new Error("Invalid public key");
          }
        }
        function computePublicKey(privateKey) {
          validatePrivateKey(privateKey);
          return secp256k1.publicKeyCreate(privateKey);
        }
        return {
          generateKey,
          privateKeyLength,
          hashAndSign,
          hashAndVerify,
          compressPublicKey,
          decompressPublicKey,
          validatePrivateKey,
          validatePublicKey,
          computePublicKey
        };
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/secp256k1-class.js
  var require_secp256k1_class2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/secp256k1-class.js"(exports2, module2) {
      "use strict";
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var exporter = require_exporter2();
      module2.exports = (keysProtobuf, randomBytes, crypto2) => {
        crypto2 = crypto2 || require_secp256k13()(randomBytes);
        class Secp256k1PublicKey {
          constructor(key) {
            crypto2.validatePublicKey(key);
            this._key = key;
          }
          verify(data, sig) {
            return crypto2.hashAndVerify(this._key, sig, data);
          }
          marshal() {
            return crypto2.compressPublicKey(this._key);
          }
          get bytes() {
            return keysProtobuf.PublicKey.encode({
              Type: keysProtobuf.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish();
          }
          equals(key) {
            return uint8ArrayEquals(this.bytes, key.bytes);
          }
          async hash() {
            const { bytes } = await sha2562.digest(this.bytes);
            return bytes;
          }
        }
        class Secp256k1PrivateKey {
          constructor(key, publicKey) {
            this._key = key;
            this._publicKey = publicKey || crypto2.computePublicKey(key);
            crypto2.validatePrivateKey(this._key);
            crypto2.validatePublicKey(this._publicKey);
          }
          sign(message) {
            return crypto2.hashAndSign(this._key, message);
          }
          get public() {
            return new Secp256k1PublicKey(this._publicKey);
          }
          marshal() {
            return this._key;
          }
          get bytes() {
            return keysProtobuf.PrivateKey.encode({
              Type: keysProtobuf.KeyType.Secp256k1,
              Data: this.marshal()
            }).finish();
          }
          equals(key) {
            return uint8ArrayEquals(this.bytes, key.bytes);
          }
          async hash() {
            const { bytes } = await sha2562.digest(this.bytes);
            return bytes;
          }
          async id() {
            const hash = await this.public.hash();
            return uint8ArrayToString(hash, "base58btc");
          }
          async export(password, format = "libp2p-key") {
            if (format === "libp2p-key") {
              return exporter.export(this.bytes, password);
            } else {
              throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
            }
          }
        }
        function unmarshalSecp256k1PrivateKey(bytes) {
          return new Secp256k1PrivateKey(bytes);
        }
        function unmarshalSecp256k1PublicKey(bytes) {
          return new Secp256k1PublicKey(bytes);
        }
        async function generateKeyPair() {
          const privateKeyBytes = await crypto2.generateKey();
          return new Secp256k1PrivateKey(privateKeyBytes);
        }
        return {
          Secp256k1PublicKey,
          Secp256k1PrivateKey,
          unmarshalSecp256k1PrivateKey,
          unmarshalSecp256k1PublicKey,
          generateKeyPair
        };
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/key-stretcher.js
  var require_key_stretcher2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/key-stretcher.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var hmac = require_index_browser2();
      var cipherMap = {
        "AES-128": {
          ivSize: 16,
          keySize: 16
        },
        "AES-256": {
          ivSize: 16,
          keySize: 32
        },
        Blowfish: {
          ivSize: 8,
          cipherKeySize: 32
        }
      };
      module2.exports = async (cipherType, hash, secret) => {
        const cipher = cipherMap[cipherType];
        if (!cipher) {
          const allowed = Object.keys(cipherMap).join(" / ");
          throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
        }
        if (!hash) {
          throw errcode(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
        }
        const cipherKeySize = cipher.keySize;
        const ivSize = cipher.ivSize;
        const hmacKeySize = 20;
        const seed = uint8ArrayFromString("key expansion");
        const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
        const m = await hmac.create(hash, secret);
        let a = await m.digest(seed);
        const result = [];
        let j = 0;
        while (j < resultLength) {
          const b = await m.digest(uint8ArrayConcat([a, seed]));
          let todo = b.length;
          if (j + todo > resultLength) {
            todo = resultLength - j;
          }
          result.push(b);
          j += todo;
          a = await m.digest(a);
        }
        const half = resultLength / 2;
        const resultBuffer = uint8ArrayConcat(result);
        const r1 = resultBuffer.slice(0, half);
        const r2 = resultBuffer.slice(half, resultLength);
        const createKey = (res) => ({
          iv: res.slice(0, ivSize),
          cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
          macKey: res.slice(ivSize + cipherKeySize)
        });
        return {
          k1: createKey(r1),
          k2: createKey(r2)
        };
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/validate-curve-type.js
  var require_validate_curve_type2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/validate-curve-type.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      module2.exports = function(curveTypes, type) {
        if (!curveTypes.includes(type)) {
          const names = curveTypes.join(" / ");
          throw errcode(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
        }
      };
    }
  });

  // node_modules/libp2p-crypto/src/keys/ecdh-browser.js
  var require_ecdh_browser2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/ecdh-browser.js"(exports2) {
      "use strict";
      var errcode = require_err_code();
      var webcrypto = require_webcrypto2();
      var { base64urlToBuffer } = require_util3();
      var validateCurveType = require_validate_curve_type2();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var bits = {
        "P-256": 256,
        "P-384": 384,
        "P-521": 521
      };
      exports2.generateEphmeralKeyPair = async function(curve) {
        validateCurveType(Object.keys(bits), curve);
        const pair = await webcrypto.get().subtle.generateKey({
          name: "ECDH",
          namedCurve: curve
        }, true, ["deriveBits"]);
        const genSharedKey = async (theirPub, forcePrivate) => {
          let privateKey;
          if (forcePrivate) {
            privateKey = await webcrypto.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
              name: "ECDH",
              namedCurve: curve
            }, false, ["deriveBits"]);
          } else {
            privateKey = pair.privateKey;
          }
          const keys = [
            await webcrypto.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
              name: "ECDH",
              namedCurve: curve
            }, false, []),
            privateKey
          ];
          const buffer = await webcrypto.get().subtle.deriveBits({
            name: "ECDH",
            namedCurve: curve,
            public: keys[0]
          }, keys[1], bits[curve]);
          return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);
        };
        const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
        return {
          key: marshalPublicKey(publicKey),
          genSharedKey
        };
      };
      var curveLengths = {
        "P-256": 32,
        "P-384": 48,
        "P-521": 66
      };
      function marshalPublicKey(jwk) {
        const byteLen = curveLengths[jwk.crv];
        return uint8ArrayConcat([
          Uint8Array.from([4]),
          base64urlToBuffer(jwk.x, byteLen),
          base64urlToBuffer(jwk.y, byteLen)
        ], 1 + byteLen * 2);
      }
      function unmarshalPublicKey(curve, key) {
        const byteLen = curveLengths[curve];
        if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
          throw errcode(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
        }
        return {
          kty: "EC",
          crv: curve,
          x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
          y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
          ext: true
        };
      }
      var unmarshalPrivateKey = (curve, key) => ({
        ...unmarshalPublicKey(curve, key.public),
        d: uint8ArrayToString(key.private, "base64url")
      });
    }
  });

  // node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
  var require_ephemeral_keys2 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"(exports2, module2) {
      "use strict";
      var ecdh = require_ecdh_browser2();
      module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
    }
  });

  // node_modules/libp2p-crypto/src/keys/index.js
  var require_keys4 = __commonJS({
    "node_modules/libp2p-crypto/src/keys/index.js"(exports2, module2) {
      "use strict";
      var keysPBM = require_keys3();
      require_asn1();
      require_pbe();
      var forge = require_forge();
      var errcode = require_err_code();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var importer = require_importer2();
      var supportedKeys = {
        rsa: require_rsa_class2(),
        ed25519: require_ed25519_class2(),
        secp256k1: require_secp256k1_class2()(keysPBM, require_random_bytes2())
      };
      var ErrMissingSecp256K1 = {
        message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
        code: "ERR_MISSING_PACKAGE"
      };
      function typeToKey(type) {
        const key = supportedKeys[type.toLowerCase()];
        if (!key) {
          const supported = Object.keys(supportedKeys).join(" / ");
          throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
        }
        return key;
      }
      var generateKeyPair = async (type, bits) => {
        return typeToKey(type).generateKeyPair(bits);
      };
      var generateKeyPairFromSeed = async (type, seed, bits) => {
        const key = typeToKey(type);
        if (type.toLowerCase() !== "ed25519") {
          throw errcode(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
        }
        return key.generateKeyPairFromSeed(seed, bits);
      };
      var unmarshalPublicKey = (buf) => {
        const decoded = keysPBM.PublicKey.decode(buf);
        const data = decoded.Data;
        switch (decoded.Type) {
          case keysPBM.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPublicKey(data);
          case keysPBM.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
          case keysPBM.KeyType.Secp256k1:
            if (supportedKeys.secp256k1) {
              return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
            } else {
              throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
            }
          default:
            typeToKey(decoded.Type);
        }
      };
      var marshalPublicKey = (key, type) => {
        type = (type || "rsa").toLowerCase();
        typeToKey(type);
        return key.bytes;
      };
      var unmarshalPrivateKey = async (buf) => {
        const decoded = keysPBM.PrivateKey.decode(buf);
        const data = decoded.Data;
        switch (decoded.Type) {
          case keysPBM.KeyType.RSA:
            return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
          case keysPBM.KeyType.Ed25519:
            return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
          case keysPBM.KeyType.Secp256k1:
            if (supportedKeys.secp256k1) {
              return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
            } else {
              throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
            }
          default:
            typeToKey(decoded.Type);
        }
      };
      var marshalPrivateKey = (key, type) => {
        type = (type || "rsa").toLowerCase();
        typeToKey(type);
        return key.bytes;
      };
      var importKey = async (encryptedKey, password) => {
        try {
          const key2 = await importer.import(encryptedKey, password);
          return unmarshalPrivateKey(key2);
        } catch (_) {
        }
        const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
        if (key === null) {
          throw errcode(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
        }
        let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
        der = uint8ArrayFromString(der.getBytes(), "ascii");
        return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
      };
      module2.exports = {
        supportedKeys,
        keysPBM,
        keyStretcher: require_key_stretcher2(),
        generateEphemeralKeyPair: require_ephemeral_keys2(),
        generateKeyPair,
        generateKeyPairFromSeed,
        unmarshalPublicKey,
        marshalPublicKey,
        unmarshalPrivateKey,
        marshalPrivateKey,
        import: importKey
      };
    }
  });

  // node_modules/libp2p-crypto/src/pbkdf2.js
  var require_pbkdf22 = __commonJS({
    "node_modules/libp2p-crypto/src/pbkdf2.js"(exports2, module2) {
      "use strict";
      var forgePbkdf2 = require_pbkdf2();
      var forgeUtil = require_util();
      var errcode = require_err_code();
      var hashName = {
        sha1: "sha1",
        "sha2-256": "sha256",
        "sha2-512": "sha512"
      };
      function pbkdf2(password, salt, iterations, keySize, hash) {
        const hasher = hashName[hash];
        if (!hasher) {
          const types = Object.keys(hashName).join(" / ");
          throw errcode(new Error(`Hash '${hash}' is unknown or not supported. Must be ${types}`), "ERR_UNSUPPORTED_HASH_TYPE");
        }
        const dek = forgePbkdf2(password, salt, iterations, keySize, hasher);
        return forgeUtil.encode64(dek);
      }
      module2.exports = pbkdf2;
    }
  });

  // node_modules/libp2p-crypto/src/index.js
  var require_src9 = __commonJS({
    "node_modules/libp2p-crypto/src/index.js"(exports2) {
      "use strict";
      var hmac = require_index_browser2();
      var aes = require_aes2();
      var keys = require_keys4();
      exports2.aes = aes;
      exports2.hmac = hmac;
      exports2.keys = keys;
      exports2.randomBytes = require_random_bytes2();
      exports2.pbkdf2 = require_pbkdf22();
    }
  });

  // node_modules/libp2p-noise/dist/src/proto/payload.js
  var require_payload = __commonJS({
    "node_modules/libp2p-noise/dist/src/proto/payload.js"(exports2, module2) {
      "use strict";
      (function(global2, factory) {
        if (typeof define === "function" && define.amd)
          define(["protobufjs/minimal"], factory);
        else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
          module2.exports = factory(require_minimal2());
      })(exports2, function($protobuf) {
        "use strict";
        var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
        var $root = $protobuf.roots["libp2p-noise"] || ($protobuf.roots["libp2p-noise"] = {});
        $root.pb = function() {
          var pb = {};
          pb.NoiseHandshakePayload = function() {
            function NoiseHandshakePayload(properties) {
              if (properties) {
                for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                  if (properties[keys[i]] != null)
                    this[keys[i]] = properties[keys[i]];
              }
            }
            NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);
            NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);
            NoiseHandshakePayload.prototype.data = $util.newBuffer([]);
            NoiseHandshakePayload.create = function create3(properties) {
              return new NoiseHandshakePayload(properties);
            };
            NoiseHandshakePayload.encode = function encode3(message, writer) {
              if (!writer)
                writer = $Writer.create();
              if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
                writer.uint32(10).bytes(message.identityKey);
              if (message.identitySig != null && Object.hasOwnProperty.call(message, "identitySig"))
                writer.uint32(18).bytes(message.identitySig);
              if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                writer.uint32(26).bytes(message.data);
              return writer;
            };
            NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {
              return this.encode(message, writer).ldelim();
            };
            NoiseHandshakePayload.decode = function decode5(reader, length2) {
              if (!(reader instanceof $Reader))
                reader = $Reader.create(reader);
              var end = length2 === void 0 ? reader.len : reader.pos + length2, message = new $root.pb.NoiseHandshakePayload();
              while (reader.pos < end) {
                var tag = reader.uint32();
                switch (tag >>> 3) {
                  case 1:
                    message.identityKey = reader.bytes();
                    break;
                  case 2:
                    message.identitySig = reader.bytes();
                    break;
                  case 3:
                    message.data = reader.bytes();
                    break;
                  default:
                    reader.skipType(tag & 7);
                    break;
                }
              }
              return message;
            };
            NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {
              if (!(reader instanceof $Reader))
                reader = new $Reader(reader);
              return this.decode(reader, reader.uint32());
            };
            NoiseHandshakePayload.verify = function verify(message) {
              if (typeof message !== "object" || message === null)
                return "object expected";
              if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
                if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey)))
                  return "identityKey: buffer expected";
              }
              if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
                if (!(message.identitySig && typeof message.identitySig.length === "number" || $util.isString(message.identitySig)))
                  return "identitySig: buffer expected";
              }
              if (message.data != null && message.hasOwnProperty("data")) {
                if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data)))
                  return "data: buffer expected";
              }
              return null;
            };
            NoiseHandshakePayload.fromObject = function fromObject(object) {
              if (object instanceof $root.pb.NoiseHandshakePayload)
                return object;
              var message = new $root.pb.NoiseHandshakePayload();
              if (object.identityKey != null) {
                if (typeof object.identityKey === "string")
                  $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
                else if (object.identityKey.length)
                  message.identityKey = object.identityKey;
              }
              if (object.identitySig != null) {
                if (typeof object.identitySig === "string")
                  $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);
                else if (object.identitySig.length)
                  message.identitySig = object.identitySig;
              }
              if (object.data != null) {
                if (typeof object.data === "string")
                  $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
                else if (object.data.length)
                  message.data = object.data;
              }
              return message;
            };
            NoiseHandshakePayload.toObject = function toObject(message, options) {
              if (!options)
                options = {};
              var object = {};
              if (options.defaults) {
                if (options.bytes === String)
                  object.identityKey = "";
                else {
                  object.identityKey = [];
                  if (options.bytes !== Array)
                    object.identityKey = $util.newBuffer(object.identityKey);
                }
                if (options.bytes === String)
                  object.identitySig = "";
                else {
                  object.identitySig = [];
                  if (options.bytes !== Array)
                    object.identitySig = $util.newBuffer(object.identitySig);
                }
                if (options.bytes === String)
                  object.data = "";
                else {
                  object.data = [];
                  if (options.bytes !== Array)
                    object.data = $util.newBuffer(object.data);
                }
              }
              if (message.identityKey != null && message.hasOwnProperty("identityKey"))
                object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
              if (message.identitySig != null && message.hasOwnProperty("identitySig"))
                object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;
              if (message.data != null && message.hasOwnProperty("data"))
                object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
              return object;
            };
            NoiseHandshakePayload.prototype.toJSON = function toJSON() {
              return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };
            return NoiseHandshakePayload;
          }();
          return pb;
        }();
        return $root;
      });
    }
  });

  // node_modules/libp2p-noise/node_modules/uint8arrays/esm/src/equals.js
  var equals_exports2 = {};
  __export(equals_exports2, {
    equals: () => equals4
  });
  function equals4(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  var init_equals2 = __esm({
    "node_modules/libp2p-noise/node_modules/uint8arrays/esm/src/equals.js"() {
    }
  });

  // node_modules/libp2p-noise/dist/src/utils.js
  var require_utils = __commonJS({
    "node_modules/libp2p-noise/dist/src/utils.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.isValidPublicKey = exports2.getHkdf = exports2.verifySignedPayload = exports2.getHandshakePayload = exports2.decodePayload = exports2.getPeerIdFromPayload = exports2.signPayload = exports2.createHandshakePayload = exports2.getPayload = exports2.generateKeypair = void 0;
      var hkdf_1 = require_hkdf();
      var sha256_1 = require_sha256();
      var x25519 = __importStar(require_x25519());
      var buffer_1 = require_buffer();
      var peer_id_1 = __importDefault(require_src8());
      var libp2p_crypto_1 = require_src9();
      var payload_1 = require_payload();
      var equals_1 = (init_equals2(), equals_exports2);
      var NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;
      function generateKeypair() {
        const keypair = x25519.generateKeyPair();
        return {
          publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),
          privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)
        };
      }
      exports2.generateKeypair = generateKeypair;
      async function getPayload(localPeer, staticPublicKey, earlyData) {
        const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
        const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
        return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
      }
      exports2.getPayload = getPayload;
      function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
        const payloadInit = NoiseHandshakePayloadProto.create({
          identityKey: buffer_1.Buffer.from(libp2pPublicKey),
          identitySig: signedPayload,
          data: earlyData !== null && earlyData !== void 0 ? earlyData : null
        });
        return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());
      }
      exports2.createHandshakePayload = createHandshakePayload;
      async function signPayload(peerId, payload) {
        return buffer_1.Buffer.from(await peerId.privKey.sign(payload));
      }
      exports2.signPayload = signPayload;
      async function getPeerIdFromPayload(payload) {
        return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));
      }
      exports2.getPeerIdFromPayload = getPeerIdFromPayload;
      function decodePayload(payload) {
        return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));
      }
      exports2.decodePayload = decodePayload;
      function getHandshakePayload(publicKey) {
        return buffer_1.Buffer.concat([buffer_1.Buffer.from("noise-libp2p-static-key:"), publicKey]);
      }
      exports2.getHandshakePayload = getHandshakePayload;
      async function isValidPeerId(peerId, publicKeyProtobuf) {
        const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);
        return equals_1.equals(generatedPeerId.id, peerId);
      }
      async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
        const identityKey = buffer_1.Buffer.from(payload.identityKey);
        if (!await isValidPeerId(remotePeer.id, identityKey)) {
          throw new Error("Peer ID doesn't match libp2p public key.");
        }
        const generatedPayload = getHandshakePayload(noiseStaticKey);
        const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);
        if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {
          throw new Error("Static key doesn't match to peer that signed payload!");
        }
        return await peer_id_1.default.createFromPubKey(identityKey);
      }
      exports2.verifySignedPayload = verifySignedPayload;
      function getHkdf(ck, ikm) {
        const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);
        const okmU8Array = hkdf.expand(96);
        const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);
        const k1 = okm.slice(0, 32);
        const k2 = okm.slice(32, 64);
        const k3 = okm.slice(64, 96);
        return [k1, k2, k3];
      }
      exports2.getHkdf = getHkdf;
      function isValidPublicKey(pk) {
        if (!buffer_1.Buffer.isBuffer(pk)) {
          return false;
        }
        if (pk.length !== 32) {
          return false;
        }
        return true;
      }
      exports2.isValidPublicKey = isValidPublicKey;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/chacha/lib/chacha.js
  var require_chacha = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var binary_1 = require_binary();
      var wipe_1 = require_wipe();
      var ROUNDS = 20;
      function core(out, input, key) {
        var j0 = 1634760805;
        var j1 = 857760878;
        var j2 = 2036477234;
        var j3 = 1797285236;
        var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
        var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
        var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
        var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
        var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
        var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
        var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
        var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
        var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
        var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
        var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
        var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
        var x0 = j0;
        var x1 = j1;
        var x2 = j2;
        var x3 = j3;
        var x4 = j4;
        var x5 = j5;
        var x6 = j6;
        var x7 = j7;
        var x8 = j8;
        var x9 = j9;
        var x10 = j10;
        var x11 = j11;
        var x12 = j12;
        var x13 = j13;
        var x14 = j14;
        var x15 = j15;
        for (var i = 0; i < ROUNDS; i += 2) {
          x0 = x0 + x4 | 0;
          x12 ^= x0;
          x12 = x12 >>> 32 - 16 | x12 << 16;
          x8 = x8 + x12 | 0;
          x4 ^= x8;
          x4 = x4 >>> 32 - 12 | x4 << 12;
          x1 = x1 + x5 | 0;
          x13 ^= x1;
          x13 = x13 >>> 32 - 16 | x13 << 16;
          x9 = x9 + x13 | 0;
          x5 ^= x9;
          x5 = x5 >>> 32 - 12 | x5 << 12;
          x2 = x2 + x6 | 0;
          x14 ^= x2;
          x14 = x14 >>> 32 - 16 | x14 << 16;
          x10 = x10 + x14 | 0;
          x6 ^= x10;
          x6 = x6 >>> 32 - 12 | x6 << 12;
          x3 = x3 + x7 | 0;
          x15 ^= x3;
          x15 = x15 >>> 32 - 16 | x15 << 16;
          x11 = x11 + x15 | 0;
          x7 ^= x11;
          x7 = x7 >>> 32 - 12 | x7 << 12;
          x2 = x2 + x6 | 0;
          x14 ^= x2;
          x14 = x14 >>> 32 - 8 | x14 << 8;
          x10 = x10 + x14 | 0;
          x6 ^= x10;
          x6 = x6 >>> 32 - 7 | x6 << 7;
          x3 = x3 + x7 | 0;
          x15 ^= x3;
          x15 = x15 >>> 32 - 8 | x15 << 8;
          x11 = x11 + x15 | 0;
          x7 ^= x11;
          x7 = x7 >>> 32 - 7 | x7 << 7;
          x1 = x1 + x5 | 0;
          x13 ^= x1;
          x13 = x13 >>> 32 - 8 | x13 << 8;
          x9 = x9 + x13 | 0;
          x5 ^= x9;
          x5 = x5 >>> 32 - 7 | x5 << 7;
          x0 = x0 + x4 | 0;
          x12 ^= x0;
          x12 = x12 >>> 32 - 8 | x12 << 8;
          x8 = x8 + x12 | 0;
          x4 ^= x8;
          x4 = x4 >>> 32 - 7 | x4 << 7;
          x0 = x0 + x5 | 0;
          x15 ^= x0;
          x15 = x15 >>> 32 - 16 | x15 << 16;
          x10 = x10 + x15 | 0;
          x5 ^= x10;
          x5 = x5 >>> 32 - 12 | x5 << 12;
          x1 = x1 + x6 | 0;
          x12 ^= x1;
          x12 = x12 >>> 32 - 16 | x12 << 16;
          x11 = x11 + x12 | 0;
          x6 ^= x11;
          x6 = x6 >>> 32 - 12 | x6 << 12;
          x2 = x2 + x7 | 0;
          x13 ^= x2;
          x13 = x13 >>> 32 - 16 | x13 << 16;
          x8 = x8 + x13 | 0;
          x7 ^= x8;
          x7 = x7 >>> 32 - 12 | x7 << 12;
          x3 = x3 + x4 | 0;
          x14 ^= x3;
          x14 = x14 >>> 32 - 16 | x14 << 16;
          x9 = x9 + x14 | 0;
          x4 ^= x9;
          x4 = x4 >>> 32 - 12 | x4 << 12;
          x2 = x2 + x7 | 0;
          x13 ^= x2;
          x13 = x13 >>> 32 - 8 | x13 << 8;
          x8 = x8 + x13 | 0;
          x7 ^= x8;
          x7 = x7 >>> 32 - 7 | x7 << 7;
          x3 = x3 + x4 | 0;
          x14 ^= x3;
          x14 = x14 >>> 32 - 8 | x14 << 8;
          x9 = x9 + x14 | 0;
          x4 ^= x9;
          x4 = x4 >>> 32 - 7 | x4 << 7;
          x1 = x1 + x6 | 0;
          x12 ^= x1;
          x12 = x12 >>> 32 - 8 | x12 << 8;
          x11 = x11 + x12 | 0;
          x6 ^= x11;
          x6 = x6 >>> 32 - 7 | x6 << 7;
          x0 = x0 + x5 | 0;
          x15 ^= x0;
          x15 = x15 >>> 32 - 8 | x15 << 8;
          x10 = x10 + x15 | 0;
          x5 ^= x10;
          x5 = x5 >>> 32 - 7 | x5 << 7;
        }
        binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
        binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
        binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
        binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
        binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
        binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
        binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
        binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
        binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
        binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
        binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
        binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
        binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
        binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
        binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
        binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
      }
      function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) {
          nonceInplaceCounterLength = 0;
        }
        if (key.length !== 32) {
          throw new Error("ChaCha: key size must be 32 bytes");
        }
        if (dst.length < src2.length) {
          throw new Error("ChaCha: destination is shorter than source");
        }
        var nc;
        var counterLength;
        if (nonceInplaceCounterLength === 0) {
          if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
          }
          nc = new Uint8Array(16);
          counterLength = nc.length - nonce.length;
          nc.set(nonce, counterLength);
        } else {
          if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
          }
          nc = nonce;
          counterLength = nonceInplaceCounterLength;
        }
        var block = new Uint8Array(64);
        for (var i = 0; i < src2.length; i += 64) {
          core(block, nc, key);
          for (var j = i; j < i + 64 && j < src2.length; j++) {
            dst[j] = src2[j] ^ block[j - i];
          }
          incrementCounter(nc, 0, counterLength);
        }
        wipe_1.wipe(block);
        if (nonceInplaceCounterLength === 0) {
          wipe_1.wipe(nc);
        }
        return dst;
      }
      exports2.streamXOR = streamXOR;
      function stream(key, nonce, dst, nonceInplaceCounterLength) {
        if (nonceInplaceCounterLength === void 0) {
          nonceInplaceCounterLength = 0;
        }
        wipe_1.wipe(dst);
        return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
      }
      exports2.stream = stream;
      function incrementCounter(counter, pos, len) {
        var carry = 1;
        while (len--) {
          carry = carry + (counter[pos] & 255) | 0;
          counter[pos] = carry & 255;
          carry >>>= 8;
          pos++;
        }
        if (carry > 0) {
          throw new Error("ChaCha: counter overflow");
        }
      }
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/poly1305/lib/poly1305.js
  var require_poly1305 = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var constant_time_1 = require_constant_time();
      var wipe_1 = require_wipe();
      exports2.DIGEST_LENGTH = 16;
      var Poly1305 = function() {
        function Poly13052(key) {
          this.digestLength = exports2.DIGEST_LENGTH;
          this._buffer = new Uint8Array(16);
          this._r = new Uint16Array(10);
          this._h = new Uint16Array(10);
          this._pad = new Uint16Array(8);
          this._leftover = 0;
          this._fin = 0;
          this._finished = false;
          var t0 = key[0] | key[1] << 8;
          this._r[0] = t0 & 8191;
          var t1 = key[2] | key[3] << 8;
          this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = key[4] | key[5] << 8;
          this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
          var t3 = key[6] | key[7] << 8;
          this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = key[8] | key[9] << 8;
          this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
          this._r[5] = t4 >>> 1 & 8190;
          var t5 = key[10] | key[11] << 8;
          this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = key[12] | key[13] << 8;
          this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
          var t7 = key[14] | key[15] << 8;
          this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
          this._r[9] = t7 >>> 5 & 127;
          this._pad[0] = key[16] | key[17] << 8;
          this._pad[1] = key[18] | key[19] << 8;
          this._pad[2] = key[20] | key[21] << 8;
          this._pad[3] = key[22] | key[23] << 8;
          this._pad[4] = key[24] | key[25] << 8;
          this._pad[5] = key[26] | key[27] << 8;
          this._pad[6] = key[28] | key[29] << 8;
          this._pad[7] = key[30] | key[31] << 8;
        }
        Poly13052.prototype._blocks = function(m, mpos, bytes) {
          var hibit = this._fin ? 0 : 1 << 11;
          var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
          var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
          while (bytes >= 16) {
            var t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += t0 & 8191;
            var t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += (t0 >>> 13 | t1 << 3) & 8191;
            var t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += (t1 >>> 10 | t2 << 6) & 8191;
            var t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += (t2 >>> 7 | t3 << 9) & 8191;
            var t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += (t3 >>> 4 | t4 << 12) & 8191;
            h5 += t4 >>> 1 & 8191;
            var t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += (t4 >>> 14 | t5 << 2) & 8191;
            var t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += (t5 >>> 11 | t6 << 5) & 8191;
            var t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += (t6 >>> 8 | t7 << 8) & 8191;
            h9 += t7 >>> 5 | hibit;
            var c = 0;
            var d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = d0 >>> 13;
            d0 &= 8191;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += d0 >>> 13;
            d0 &= 8191;
            var d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = d1 >>> 13;
            d1 &= 8191;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += d1 >>> 13;
            d1 &= 8191;
            var d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = d2 >>> 13;
            d2 &= 8191;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += d2 >>> 13;
            d2 &= 8191;
            var d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = d3 >>> 13;
            d3 &= 8191;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += d3 >>> 13;
            d3 &= 8191;
            var d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = d4 >>> 13;
            d4 &= 8191;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += d4 >>> 13;
            d4 &= 8191;
            var d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = d5 >>> 13;
            d5 &= 8191;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += d5 >>> 13;
            d5 &= 8191;
            var d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = d6 >>> 13;
            d6 &= 8191;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += d6 >>> 13;
            d6 &= 8191;
            var d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = d7 >>> 13;
            d7 &= 8191;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += d7 >>> 13;
            d7 &= 8191;
            var d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = d8 >>> 13;
            d8 &= 8191;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += d8 >>> 13;
            d8 &= 8191;
            var d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = d9 >>> 13;
            d9 &= 8191;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += d9 >>> 13;
            d9 &= 8191;
            c = (c << 2) + c | 0;
            c = c + d0 | 0;
            d0 = c & 8191;
            c = c >>> 13;
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
          }
          this._h[0] = h0;
          this._h[1] = h1;
          this._h[2] = h2;
          this._h[3] = h3;
          this._h[4] = h4;
          this._h[5] = h5;
          this._h[6] = h6;
          this._h[7] = h7;
          this._h[8] = h8;
          this._h[9] = h9;
        };
        Poly13052.prototype.finish = function(mac, macpos) {
          if (macpos === void 0) {
            macpos = 0;
          }
          var g = new Uint16Array(10);
          var c;
          var mask;
          var f;
          var i;
          if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
              this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
          }
          c = this._h[1] >>> 13;
          this._h[1] &= 8191;
          for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 8191;
          }
          this._h[0] += c * 5;
          c = this._h[0] >>> 13;
          this._h[0] &= 8191;
          this._h[1] += c;
          c = this._h[1] >>> 13;
          this._h[1] &= 8191;
          this._h[2] += c;
          g[0] = this._h[0] + 5;
          c = g[0] >>> 13;
          g[0] &= 8191;
          for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 8191;
          }
          g[9] -= 1 << 13;
          mask = (c ^ 1) - 1;
          for (i = 0; i < 10; i++) {
            g[i] &= mask;
          }
          mask = ~mask;
          for (i = 0; i < 10; i++) {
            this._h[i] = this._h[i] & mask | g[i];
          }
          this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
          this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
          this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
          this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
          this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
          this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
          this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
          this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
          f = this._h[0] + this._pad[0];
          this._h[0] = f & 65535;
          for (i = 1; i < 8; i++) {
            f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
            this._h[i] = f & 65535;
          }
          mac[macpos + 0] = this._h[0] >>> 0;
          mac[macpos + 1] = this._h[0] >>> 8;
          mac[macpos + 2] = this._h[1] >>> 0;
          mac[macpos + 3] = this._h[1] >>> 8;
          mac[macpos + 4] = this._h[2] >>> 0;
          mac[macpos + 5] = this._h[2] >>> 8;
          mac[macpos + 6] = this._h[3] >>> 0;
          mac[macpos + 7] = this._h[3] >>> 8;
          mac[macpos + 8] = this._h[4] >>> 0;
          mac[macpos + 9] = this._h[4] >>> 8;
          mac[macpos + 10] = this._h[5] >>> 0;
          mac[macpos + 11] = this._h[5] >>> 8;
          mac[macpos + 12] = this._h[6] >>> 0;
          mac[macpos + 13] = this._h[6] >>> 8;
          mac[macpos + 14] = this._h[7] >>> 0;
          mac[macpos + 15] = this._h[7] >>> 8;
          this._finished = true;
          return this;
        };
        Poly13052.prototype.update = function(m) {
          var mpos = 0;
          var bytes = m.length;
          var want;
          if (this._leftover) {
            want = 16 - this._leftover;
            if (want > bytes) {
              want = bytes;
            }
            for (var i = 0; i < want; i++) {
              this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
              return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
          }
          if (bytes >= 16) {
            want = bytes - bytes % 16;
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
          }
          if (bytes) {
            for (var i = 0; i < bytes; i++) {
              this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
          }
          return this;
        };
        Poly13052.prototype.digest = function() {
          if (this._finished) {
            throw new Error("Poly1305 was finished");
          }
          var mac = new Uint8Array(16);
          this.finish(mac);
          return mac;
        };
        Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._buffer);
          wipe_1.wipe(this._r);
          wipe_1.wipe(this._h);
          wipe_1.wipe(this._pad);
          this._leftover = 0;
          this._fin = 0;
          this._finished = true;
          return this;
        };
        return Poly13052;
      }();
      exports2.Poly1305 = Poly1305;
      function oneTimeAuth(key, data) {
        var h = new Poly1305(key);
        h.update(data);
        var digest = h.digest();
        h.clean();
        return digest;
      }
      exports2.oneTimeAuth = oneTimeAuth;
      function equal(a, b) {
        if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
          return false;
        }
        return constant_time_1.equal(a, b);
      }
      exports2.equal = equal;
    }
  });

  // node_modules/libp2p-noise/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
  var require_chacha20poly1305 = __commonJS({
    "node_modules/libp2p-noise/node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      var chacha_1 = require_chacha();
      var poly1305_1 = require_poly1305();
      var wipe_1 = require_wipe();
      var binary_1 = require_binary();
      var constant_time_1 = require_constant_time();
      exports2.KEY_LENGTH = 32;
      exports2.NONCE_LENGTH = 12;
      exports2.TAG_LENGTH = 16;
      var ZEROS = new Uint8Array(16);
      var ChaCha20Poly1305 = function() {
        function ChaCha20Poly13052(key) {
          this.nonceLength = exports2.NONCE_LENGTH;
          this.tagLength = exports2.TAG_LENGTH;
          if (key.length !== exports2.KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
          }
          this._key = new Uint8Array(key);
        }
        ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var resultLength = plaintext.length + this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
          this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
          if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
          }
          if (sealed.length < this.tagLength) {
            return null;
          }
          var counter = new Uint8Array(16);
          counter.set(nonce, counter.length - nonce.length);
          var authKey = new Uint8Array(32);
          chacha_1.stream(this._key, counter, authKey, 4);
          var calculatedTag = new Uint8Array(this.tagLength);
          this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
          if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
          }
          var resultLength = sealed.length - this.tagLength;
          var result;
          if (dst) {
            if (dst.length !== resultLength) {
              throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
          } else {
            result = new Uint8Array(resultLength);
          }
          chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
          wipe_1.wipe(counter);
          return result;
        };
        ChaCha20Poly13052.prototype.clean = function() {
          wipe_1.wipe(this._key);
          return this;
        };
        ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
          var h = new poly1305_1.Poly1305(authKey);
          if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
              h.update(ZEROS.subarray(associatedData.length % 16));
            }
          }
          h.update(ciphertext);
          if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
          }
          var length2 = new Uint8Array(8);
          if (associatedData) {
            binary_1.writeUint64LE(associatedData.length, length2);
          }
          h.update(length2);
          binary_1.writeUint64LE(ciphertext.length, length2);
          h.update(length2);
          var tag = h.digest();
          for (var i = 0; i < tag.length; i++) {
            tagOut[i] = tag[i];
          }
          h.clean();
          wipe_1.wipe(tag);
          wipe_1.wipe(length2);
        };
        return ChaCha20Poly13052;
      }();
      exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
    }
  });

  // node_modules/libp2p-noise/dist/src/constants.js
  var require_constants4 = __commonJS({
    "node_modules/libp2p-noise/dist/src/constants.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.DUMP_SESSION_KEYS = exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
      exports2.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
      exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES - 16;
      exports2.DUMP_SESSION_KEYS = false;
    }
  });

  // node_modules/libp2p-noise/dist/src/logger.js
  var require_logger = __commonJS({
    "node_modules/libp2p-noise/dist/src/logger.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.logCipherState = exports2.logRemoteEphemeralKey = exports2.logRemoteStaticKey = exports2.logLocalEphemeralKeys = exports2.logLocalStaticKeys = exports2.logger = void 0;
      var debug_1 = __importDefault(require_browser2());
      var constants_1 = require_constants4();
      exports2.logger = debug_1.default("libp2p:noise");
      var keyLogger;
      if (constants_1.DUMP_SESSION_KEYS) {
        keyLogger = exports2.logger;
      } else {
        keyLogger = () => {
        };
      }
      function logLocalStaticKeys(s) {
        keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString("hex")}`);
        keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString("hex")}`);
      }
      exports2.logLocalStaticKeys = logLocalStaticKeys;
      function logLocalEphemeralKeys(e) {
        if (e) {
          keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString("hex")}`);
          keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString("hex")}`);
        } else {
          keyLogger("Missing local ephemeral keys.");
        }
      }
      exports2.logLocalEphemeralKeys = logLocalEphemeralKeys;
      function logRemoteStaticKey(rs) {
        keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString("hex")}`);
      }
      exports2.logRemoteStaticKey = logRemoteStaticKey;
      function logRemoteEphemeralKey(re) {
        keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString("hex")}`);
      }
      exports2.logRemoteEphemeralKey = logRemoteEphemeralKey;
      function logCipherState(session) {
        if (session.cs1 && session.cs2) {
          keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString("hex")}`);
          keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString("hex")}`);
        } else {
          keyLogger("Missing cipher state.");
        }
      }
      exports2.logCipherState = logCipherState;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js
  var require_abstract_handshake = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.AbstractHandshake = exports2.MIN_NONCE = void 0;
      var buffer_1 = require_buffer();
      var x25519 = __importStar(require_x25519());
      var SHA256 = __importStar(require_sha256());
      var chacha20poly1305_1 = require_chacha20poly1305();
      var utils_1 = require_utils();
      var logger_1 = require_logger();
      exports2.MIN_NONCE = 0;
      var AbstractHandshake = class {
        encryptWithAd(cs, ad, plaintext) {
          const e = this.encrypt(cs.k, cs.n, ad, plaintext);
          this.setNonce(cs, this.incrementNonce(cs.n));
          return e;
        }
        decryptWithAd(cs, ad, ciphertext) {
          const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
          this.setNonce(cs, this.incrementNonce(cs.n));
          return { plaintext, valid };
        }
        hasKey(cs) {
          return !this.isEmptyKey(cs.k);
        }
        setNonce(cs, nonce) {
          cs.n = nonce;
        }
        createEmptyKey() {
          return buffer_1.Buffer.alloc(32);
        }
        isEmptyKey(k) {
          const emptyKey = this.createEmptyKey();
          return emptyKey.equals(k);
        }
        incrementNonce(n) {
          return n + 1;
        }
        nonceToBytes(n) {
          const nonce = buffer_1.Buffer.alloc(12);
          nonce.writeUInt32LE(n, 4);
          return nonce;
        }
        encrypt(k, n, ad, plaintext) {
          const nonce = this.nonceToBytes(n);
          const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
          const encryptedMessage = ctx.seal(nonce, plaintext, ad);
          return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);
        }
        encryptAndHash(ss, plaintext) {
          let ciphertext;
          if (this.hasKey(ss.cs)) {
            ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
          } else {
            ciphertext = plaintext;
          }
          this.mixHash(ss, ciphertext);
          return ciphertext;
        }
        decrypt(k, n, ad, ciphertext) {
          const nonce = this.nonceToBytes(n);
          const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
          const encryptedMessage = ctx.open(nonce, ciphertext, ad);
          if (encryptedMessage) {
            return {
              plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),
              valid: true
            };
          } else {
            return {
              plaintext: buffer_1.Buffer.from(""),
              valid: false
            };
          }
        }
        decryptAndHash(ss, ciphertext) {
          let plaintext;
          let valid = true;
          if (this.hasKey(ss.cs)) {
            ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
          } else {
            plaintext = ciphertext;
          }
          this.mixHash(ss, ciphertext);
          return { plaintext, valid };
        }
        dh(privateKey, publicKey) {
          try {
            const derivedU8 = x25519.sharedKey(privateKey, publicKey);
            const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);
            const result = buffer_1.Buffer.alloc(32);
            derived.copy(result);
            return result;
          } catch (e) {
            logger_1.logger(e.message);
            return buffer_1.Buffer.alloc(32);
          }
        }
        mixHash(ss, data) {
          ss.h = this.getHash(ss.h, data);
        }
        getHash(a, b) {
          const hash = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));
          return buffer_1.Buffer.from(hash.buffer, hash.byteOffset, hash.length);
        }
        mixKey(ss, ikm) {
          const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);
          ss.cs = this.initializeKey(tempK);
          ss.ck = ck;
        }
        initializeKey(k) {
          const n = exports2.MIN_NONCE;
          return { k, n };
        }
        initializeSymmetric(protocolName) {
          const protocolNameBytes = buffer_1.Buffer.from(protocolName, "utf-8");
          const h = this.hashProtocolName(protocolNameBytes);
          const ck = h;
          const key = this.createEmptyKey();
          const cs = this.initializeKey(key);
          return { cs, ck, h };
        }
        hashProtocolName(protocolName) {
          if (protocolName.length <= 32) {
            const h = buffer_1.Buffer.alloc(32);
            protocolName.copy(h);
            return h;
          } else {
            return this.getHash(protocolName, buffer_1.Buffer.alloc(0));
          }
        }
        split(ss) {
          const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));
          const cs1 = this.initializeKey(tempk1);
          const cs2 = this.initializeKey(tempk2);
          return { cs1, cs2 };
        }
        writeMessageRegular(cs, payload) {
          const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);
          const ne = this.createEmptyKey();
          const ns = buffer_1.Buffer.alloc(0);
          return { ne, ns, ciphertext };
        }
        readMessageRegular(cs, message) {
          return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);
        }
      };
      exports2.AbstractHandshake = AbstractHandshake;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshakes/xx.js
  var require_xx = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshakes/xx.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.XX = void 0;
      var buffer_1 = require_buffer();
      var utils_1 = require_utils();
      var abstract_handshake_1 = require_abstract_handshake();
      var XX = class extends abstract_handshake_1.AbstractHandshake {
        initializeInitiator(prologue, s, rs, psk) {
          const name = "Noise_XX_25519_ChaChaPoly_SHA256";
          const ss = this.initializeSymmetric(name);
          this.mixHash(ss, prologue);
          const re = buffer_1.Buffer.alloc(32);
          return { ss, s, rs, psk, re };
        }
        initializeResponder(prologue, s, rs, psk) {
          const name = "Noise_XX_25519_ChaChaPoly_SHA256";
          const ss = this.initializeSymmetric(name);
          this.mixHash(ss, prologue);
          const re = buffer_1.Buffer.alloc(32);
          return { ss, s, rs, psk, re };
        }
        writeMessageA(hs, payload, e) {
          const ns = buffer_1.Buffer.alloc(0);
          if (e !== void 0) {
            hs.e = e;
          } else {
            hs.e = utils_1.generateKeypair();
          }
          const ne = hs.e.publicKey;
          this.mixHash(hs.ss, ne);
          const ciphertext = this.encryptAndHash(hs.ss, payload);
          return { ne, ns, ciphertext };
        }
        writeMessageB(hs, payload) {
          hs.e = utils_1.generateKeypair();
          const ne = hs.e.publicKey;
          this.mixHash(hs.ss, ne);
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
          const spk = buffer_1.Buffer.from(hs.s.publicKey);
          const ns = this.encryptAndHash(hs.ss, spk);
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
          const ciphertext = this.encryptAndHash(hs.ss, payload);
          return { ne, ns, ciphertext };
        }
        writeMessageC(hs, payload) {
          const spk = buffer_1.Buffer.from(hs.s.publicKey);
          const ns = this.encryptAndHash(hs.ss, spk);
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
          const ciphertext = this.encryptAndHash(hs.ss, payload);
          const ne = this.createEmptyKey();
          const messageBuffer = { ne, ns, ciphertext };
          const { cs1, cs2 } = this.split(hs.ss);
          return { h: hs.ss.h, messageBuffer, cs1, cs2 };
        }
        readMessageA(hs, message) {
          if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
          }
          this.mixHash(hs.ss, hs.re);
          return this.decryptAndHash(hs.ss, message.ciphertext);
        }
        readMessageB(hs, message) {
          if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
          }
          this.mixHash(hs.ss, hs.re);
          if (!hs.e) {
            throw new Error("Handshake state `e` param is missing.");
          }
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
          const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
          if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
          }
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
          const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
          return { plaintext, valid: valid1 && valid2 };
        }
        readMessageC(hs, message) {
          const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
          if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
          }
          if (!hs.e) {
            throw new Error("Handshake state `e` param is missing.");
          }
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
          const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
          const { cs1, cs2 } = this.split(hs.ss);
          return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
        }
        initSession(initiator, prologue, s) {
          const psk = this.createEmptyKey();
          const rs = buffer_1.Buffer.alloc(32);
          let hs;
          if (initiator) {
            hs = this.initializeInitiator(prologue, s, rs, psk);
          } else {
            hs = this.initializeResponder(prologue, s, rs, psk);
          }
          return {
            hs,
            i: initiator,
            mc: 0
          };
        }
        sendMessage(session, message, ephemeral) {
          let messageBuffer;
          if (session.mc === 0) {
            messageBuffer = this.writeMessageA(session.hs, message, ephemeral);
          } else if (session.mc === 1) {
            messageBuffer = this.writeMessageB(session.hs, message);
          } else if (session.mc === 2) {
            const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);
            messageBuffer = resultingBuffer;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
          } else if (session.mc > 2) {
            if (session.i) {
              if (!session.cs1) {
                throw new Error("CS1 (cipher state) is not defined");
              }
              messageBuffer = this.writeMessageRegular(session.cs1, message);
            } else {
              if (!session.cs2) {
                throw new Error("CS2 (cipher state) is not defined");
              }
              messageBuffer = this.writeMessageRegular(session.cs2, message);
            }
          } else {
            throw new Error("Session invalid.");
          }
          session.mc++;
          return messageBuffer;
        }
        recvMessage(session, message) {
          let plaintext = buffer_1.Buffer.alloc(0);
          let valid = false;
          if (session.mc === 0) {
            ({ plaintext, valid } = this.readMessageA(session.hs, message));
          } else if (session.mc === 1) {
            ({ plaintext, valid } = this.readMessageB(session.hs, message));
          } else if (session.mc === 2) {
            const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);
            plaintext = resultingPlaintext;
            valid = resultingValid;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
          }
          session.mc++;
          return { plaintext, valid };
        }
      };
      exports2.XX = XX;
    }
  });

  // node_modules/libp2p-noise/dist/src/encoder.js
  var require_encoder = __commonJS({
    "node_modules/libp2p-noise/dist/src/encoder.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decode2 = exports2.decode1 = exports2.decode0 = exports2.encode2 = exports2.encode1 = exports2.encode0 = exports2.uint16BEDecode = exports2.uint16BEEncode = void 0;
      var buffer_1 = require_buffer();
      var uint16BEEncode = (value, target, offset) => {
        target = target || buffer_1.Buffer.allocUnsafe(2);
        target.writeUInt16BE(value, offset);
        return target;
      };
      exports2.uint16BEEncode = uint16BEEncode;
      exports2.uint16BEEncode.bytes = 2;
      var uint16BEDecode = (data) => {
        if (data.length < 2)
          throw RangeError("Could not decode int16BE");
        return data.readUInt16BE(0);
      };
      exports2.uint16BEDecode = uint16BEDecode;
      exports2.uint16BEDecode.bytes = 2;
      function encode0(message) {
        return buffer_1.Buffer.concat([message.ne, message.ciphertext]);
      }
      exports2.encode0 = encode0;
      function encode1(message) {
        return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);
      }
      exports2.encode1 = encode1;
      function encode22(message) {
        return buffer_1.Buffer.concat([message.ns, message.ciphertext]);
      }
      exports2.encode2 = encode22;
      function decode0(input) {
        if (input.length < 32) {
          throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
        }
        return {
          ne: input.slice(0, 32),
          ciphertext: input.slice(32, input.length),
          ns: buffer_1.Buffer.alloc(0)
        };
      }
      exports2.decode0 = decode0;
      function decode1(input) {
        if (input.length < 80) {
          throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
        }
        return {
          ne: input.slice(0, 32),
          ns: input.slice(32, 80),
          ciphertext: input.slice(80, input.length)
        };
      }
      exports2.decode1 = decode1;
      function decode22(input) {
        if (input.length < 48) {
          throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
        }
        return {
          ne: buffer_1.Buffer.alloc(0),
          ns: input.slice(0, 48),
          ciphertext: input.slice(48, input.length)
        };
      }
      exports2.decode2 = decode22;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshake-xx.js
  var require_handshake_xx = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshake-xx.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.XXHandshake = void 0;
      var buffer_1 = require_buffer();
      var xx_1 = require_xx();
      var utils_1 = require_utils();
      var logger_1 = require_logger();
      var encoder_1 = require_encoder();
      var XXHandshake = class {
        constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
          this.isInitiator = isInitiator;
          this.payload = payload;
          this.prologue = prologue;
          this.staticKeypair = staticKeypair;
          this.connection = connection;
          if (remotePeer) {
            this.remotePeer = remotePeer;
          }
          this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();
          this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
          this.remoteEarlyData = buffer_1.Buffer.alloc(0);
        }
        async propose() {
          logger_1.logLocalStaticKeys(this.session.hs.s);
          if (this.isInitiator) {
            logger_1.logger("Stage 0 - Initiator starting to send first message.");
            const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));
            this.connection.writeLP(encoder_1.encode0(messageBuffer));
            logger_1.logger("Stage 0 - Initiator finished sending first message.");
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
          } else {
            logger_1.logger("Stage 0 - Responder waiting to receive first message...");
            const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());
            const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("xx handshake stage 0 validation fail");
            }
            logger_1.logger("Stage 0 - Responder received first message.");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
          }
        }
        async exchange() {
          if (this.isInitiator) {
            logger_1.logger("Stage 1 - Initiator waiting to receive first message from responder...");
            const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("xx handshake stage 1 validation fail");
            }
            logger_1.logger("Stage 1 - Initiator received the message.");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
            logger_1.logRemoteStaticKey(this.session.hs.rs);
            logger_1.logger("Initiator going to check remote's signature...");
            try {
              const decodedPayload = await utils_1.decodePayload(plaintext);
              this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
              this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);
              this.setRemoteEarlyData(decodedPayload.data);
            } catch (e) {
              const err = e;
              throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
            }
            logger_1.logger("All good with the signature!");
          } else {
            logger_1.logger("Stage 1 - Responder sending out first message with signed payload and static key.");
            const messageBuffer = this.xx.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode1(messageBuffer));
            logger_1.logger("Stage 1 - Responder sent the second handshake message with signed payload.");
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
          }
        }
        async finish() {
          if (this.isInitiator) {
            logger_1.logger("Stage 2 - Initiator sending third handshake message.");
            const messageBuffer = this.xx.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode2(messageBuffer));
            logger_1.logger("Stage 2 - Initiator sent message with signed payload.");
          } else {
            logger_1.logger("Stage 2 - Responder waiting for third handshake message...");
            const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("xx handshake stage 2 validation fail");
            }
            logger_1.logger("Stage 2 - Responder received the message, finished handshake.");
            try {
              const decodedPayload = await utils_1.decodePayload(plaintext);
              this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
              await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
              this.setRemoteEarlyData(decodedPayload.data);
            } catch (e) {
              const err = e;
              throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
            }
          }
          logger_1.logCipherState(this.session);
        }
        encrypt(plaintext, session) {
          const cs = this.getCS(session);
          return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
        }
        decrypt(ciphertext, session) {
          const cs = this.getCS(session, false);
          return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
        }
        getRemoteStaticKey() {
          return this.session.hs.rs;
        }
        getCS(session, encryption = true) {
          if (!session.cs1 || !session.cs2) {
            throw new Error("Handshake not completed properly, cipher state does not exist.");
          }
          if (this.isInitiator) {
            return encryption ? session.cs1 : session.cs2;
          } else {
            return encryption ? session.cs2 : session.cs1;
          }
        }
        setRemoteEarlyData(data) {
          if (data) {
            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
          }
        }
      };
      exports2.XXHandshake = XXHandshake;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshakes/ik.js
  var require_ik = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshakes/ik.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IK = void 0;
      var buffer_1 = require_buffer();
      var utils_1 = require_utils();
      var abstract_handshake_1 = require_abstract_handshake();
      var IK = class extends abstract_handshake_1.AbstractHandshake {
        initSession(initiator, prologue, s, rs) {
          const psk = this.createEmptyKey();
          let hs;
          if (initiator) {
            hs = this.initializeInitiator(prologue, s, rs, psk);
          } else {
            hs = this.initializeResponder(prologue, s, rs, psk);
          }
          return {
            hs,
            i: initiator,
            mc: 0
          };
        }
        sendMessage(session, message) {
          let messageBuffer;
          if (session.mc === 0) {
            messageBuffer = this.writeMessageA(session.hs, message);
          } else if (session.mc === 1) {
            const { messageBuffer: mb, h, cs1, cs2 } = this.writeMessageB(session.hs, message);
            messageBuffer = mb;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
          } else if (session.mc > 1) {
            if (session.i) {
              if (!session.cs1) {
                throw new Error("CS1 (cipher state) is not defined");
              }
              messageBuffer = this.writeMessageRegular(session.cs1, message);
            } else {
              if (!session.cs2) {
                throw new Error("CS2 (cipher state) is not defined");
              }
              messageBuffer = this.writeMessageRegular(session.cs2, message);
            }
          } else {
            throw new Error("Session invalid.");
          }
          session.mc++;
          return messageBuffer;
        }
        recvMessage(session, message) {
          let plaintext = buffer_1.Buffer.alloc(0);
          let valid = false;
          if (session.mc === 0) {
            ({ plaintext, valid } = this.readMessageA(session.hs, message));
          }
          if (session.mc === 1) {
            const { plaintext: pt, valid: v, h, cs1, cs2 } = this.readMessageB(session.hs, message);
            plaintext = pt;
            valid = v;
            session.h = h;
            session.cs1 = cs1;
            session.cs2 = cs2;
          }
          session.mc++;
          return { plaintext, valid };
        }
        writeMessageA(hs, payload) {
          hs.e = utils_1.generateKeypair();
          const ne = hs.e.publicKey;
          this.mixHash(hs.ss, ne);
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
          const spk = buffer_1.Buffer.from(hs.s.publicKey);
          const ns = this.encryptAndHash(hs.ss, spk);
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
          const ciphertext = this.encryptAndHash(hs.ss, payload);
          return { ne, ns, ciphertext };
        }
        writeMessageB(hs, payload) {
          hs.e = utils_1.generateKeypair();
          const ne = hs.e.publicKey;
          this.mixHash(hs.ss, ne);
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
          const ciphertext = this.encryptAndHash(hs.ss, payload);
          const ns = this.createEmptyKey();
          const messageBuffer = { ne, ns, ciphertext };
          const { cs1, cs2 } = this.split(hs.ss);
          return { messageBuffer, cs1, cs2, h: hs.ss.h };
        }
        readMessageA(hs, message) {
          if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
          }
          this.mixHash(hs.ss, hs.re);
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
          const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
          if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
            hs.rs = ns;
          }
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
          const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
          return { plaintext, valid: valid1 && valid2 };
        }
        readMessageB(hs, message) {
          if (utils_1.isValidPublicKey(message.ne)) {
            hs.re = message.ne;
          }
          this.mixHash(hs.ss, hs.re);
          if (!hs.e) {
            throw new Error("Handshake state should contain ephemeral key by now.");
          }
          this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
          this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
          const { plaintext, valid } = this.decryptAndHash(hs.ss, message.ciphertext);
          const { cs1, cs2 } = this.split(hs.ss);
          return { h: hs.ss.h, valid, plaintext, cs1, cs2 };
        }
        initializeInitiator(prologue, s, rs, psk) {
          const name = "Noise_IK_25519_ChaChaPoly_SHA256";
          const ss = this.initializeSymmetric(name);
          this.mixHash(ss, prologue);
          this.mixHash(ss, rs);
          const re = buffer_1.Buffer.alloc(32);
          return { ss, s, rs, re, psk };
        }
        initializeResponder(prologue, s, rs, psk) {
          const name = "Noise_IK_25519_ChaChaPoly_SHA256";
          const ss = this.initializeSymmetric(name);
          this.mixHash(ss, prologue);
          this.mixHash(ss, s.publicKey);
          const re = buffer_1.Buffer.alloc(32);
          return { ss, s, rs, re, psk };
        }
      };
      exports2.IK = IK;
    }
  });

  // node_modules/libp2p-noise/dist/src/errors.js
  var require_errors = __commonJS({
    "node_modules/libp2p-noise/dist/src/errors.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.FailedIKError = void 0;
      var FailedIKError = class extends Error {
        constructor(initialMsg, message) {
          super(message);
          this.initialMsg = initialMsg;
          this.name = "FailedIKhandshake";
        }
      };
      exports2.FailedIKError = FailedIKError;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshake-ik.js
  var require_handshake_ik = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshake-ik.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.IKHandshake = void 0;
      var ik_1 = require_ik();
      var buffer_1 = require_buffer();
      var encoder_1 = require_encoder();
      var utils_1 = require_utils();
      var errors_1 = require_errors();
      var logger_1 = require_logger();
      var IKHandshake = class {
        constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
          this.isInitiator = isInitiator;
          this.payload = buffer_1.Buffer.from(payload);
          this.prologue = prologue;
          this.staticKeypair = staticKeypair;
          this.connection = connection;
          if (remotePeer) {
            this.remotePeer = remotePeer;
          }
          this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();
          this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
          this.remoteEarlyData = buffer_1.Buffer.alloc(0);
        }
        async stage0() {
          logger_1.logLocalStaticKeys(this.session.hs.s);
          logger_1.logRemoteStaticKey(this.session.hs.rs);
          if (this.isInitiator) {
            logger_1.logger("IK Stage 0 - Initiator sending message...");
            const messageBuffer = this.ik.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode1(messageBuffer));
            logger_1.logger("IK Stage 0 - Initiator sent message.");
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
          } else {
            logger_1.logger("IK Stage 0 - Responder receiving message...");
            const receivedMsg = await this.connection.readLP();
            try {
              const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());
              const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
              if (!valid) {
                throw new Error("ik handshake stage 0 decryption validation fail");
              }
              logger_1.logger("IK Stage 0 - Responder got message, going to verify payload.");
              const decodedPayload = await utils_1.decodePayload(plaintext);
              this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
              await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
              this.setRemoteEarlyData(decodedPayload.data);
              logger_1.logger("IK Stage 0 - Responder successfully verified payload!");
              logger_1.logRemoteEphemeralKey(this.session.hs.re);
            } catch (e) {
              const err = e;
              logger_1.logger("Responder breaking up with IK handshake in stage 0.");
              throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);
            }
          }
        }
        async stage1() {
          if (this.isInitiator) {
            logger_1.logger("IK Stage 1 - Initiator receiving message...");
            const receivedMsg = (await this.connection.readLP()).slice();
            const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));
            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
            logger_1.logger("IK Stage 1 - Initiator got message, going to verify payload.");
            try {
              if (!valid) {
                throw new Error("ik stage 1 decryption validation fail");
              }
              const decodedPayload = await utils_1.decodePayload(plaintext);
              this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
              await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
              this.setRemoteEarlyData(decodedPayload.data);
              logger_1.logger("IK Stage 1 - Initiator successfully verified payload!");
              logger_1.logRemoteEphemeralKey(this.session.hs.re);
            } catch (e) {
              const err = e;
              logger_1.logger("Initiator breaking up with IK handshake in stage 1.");
              throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);
            }
          } else {
            logger_1.logger("IK Stage 1 - Responder sending message...");
            const messageBuffer = this.ik.sendMessage(this.session, this.payload);
            this.connection.writeLP(encoder_1.encode0(messageBuffer));
            logger_1.logger("IK Stage 1 - Responder sent message...");
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
          }
          logger_1.logCipherState(this.session);
        }
        decrypt(ciphertext, session) {
          const cs = this.getCS(session, false);
          return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
        }
        encrypt(plaintext, session) {
          const cs = this.getCS(session);
          return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
        }
        getLocalEphemeralKeys() {
          if (!this.session.hs.e) {
            throw new Error("Ephemeral keys do not exist.");
          }
          return this.session.hs.e;
        }
        getCS(session, encryption = true) {
          if (!session.cs1 || !session.cs2) {
            throw new Error("Handshake not completed properly, cipher state does not exist.");
          }
          if (this.isInitiator) {
            return encryption ? session.cs1 : session.cs2;
          } else {
            return encryption ? session.cs2 : session.cs1;
          }
        }
        setRemoteEarlyData(data) {
          if (data) {
            this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
          }
        }
      };
      exports2.IKHandshake = IKHandshake;
    }
  });

  // node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js
  var require_handshake_xx_fallback = __commonJS({
    "node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.XXFallbackHandshake = void 0;
      var buffer_1 = require_buffer();
      var handshake_xx_1 = require_handshake_xx();
      var utils_1 = require_utils();
      var logger_1 = require_logger();
      var encoder_1 = require_encoder();
      var XXFallbackHandshake = class extends handshake_xx_1.XXHandshake {
        constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
          super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);
          if (ephemeralKeys) {
            this.ephemeralKeys = ephemeralKeys;
          }
          this.initialMsg = initialMsg;
        }
        async propose() {
          if (this.isInitiator) {
            this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);
            logger_1.logger("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.");
            logger_1.logLocalEphemeralKeys(this.session.hs.e);
          } else {
            logger_1.logger("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
            const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);
            const { valid } = this.xx.recvMessage(this.session, {
              ne: receivedMessageBuffer.ne,
              ns: buffer_1.Buffer.alloc(0),
              ciphertext: buffer_1.Buffer.alloc(0)
            });
            if (!valid) {
              throw new Error("xx fallback stage 0 decryption validation fail");
            }
            logger_1.logger("XX Fallback Stage 0 - Responder used received message from IK.");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
          }
        }
        async exchange() {
          if (this.isInitiator) {
            const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);
            const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("xx fallback stage 1 decryption validation fail");
            }
            logger_1.logger("XX Fallback Stage 1 - Initiator used received message from IK.");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
            logger_1.logRemoteStaticKey(this.session.hs.rs);
            logger_1.logger("Initiator going to check remote's signature...");
            try {
              const decodedPayload = await utils_1.decodePayload(plaintext);
              this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
              await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
              this.setRemoteEarlyData(decodedPayload.data);
            } catch (e) {
              const err = e;
              throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);
            }
            logger_1.logger("All good with the signature!");
          } else {
            logger_1.logger("XX Fallback Stage 1 - Responder start");
            await super.exchange();
            logger_1.logger("XX Fallback Stage 1 - Responder end");
          }
        }
      };
      exports2.XXFallbackHandshake = XXFallbackHandshake;
    }
  });

  // node_modules/libp2p-noise/dist/src/crypto.js
  var require_crypto2 = __commonJS({
    "node_modules/libp2p-noise/dist/src/crypto.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.decryptStream = exports2.encryptStream = void 0;
      var buffer_1 = require_buffer();
      var constants_1 = require_constants4();
      function encryptStream(handshake) {
        return async function* (source) {
          for await (const chunk of source) {
            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
              let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
              if (end > chunkBuffer.length) {
                end = chunkBuffer.length;
              }
              const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);
              yield data;
            }
          }
        };
      }
      exports2.encryptStream = encryptStream;
      function decryptStream(handshake) {
        return async function* (source) {
          for await (const chunk of source) {
            const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
            for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
              let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
              if (end > chunkBuffer.length) {
                end = chunkBuffer.length;
              }
              const chunk2 = chunkBuffer.slice(i, end);
              const { plaintext: decrypted, valid } = await handshake.decrypt(chunk2, handshake.session);
              if (!valid) {
                throw new Error("Failed to validate decrypted chunk");
              }
              yield decrypted;
            }
          }
        };
      }
      exports2.decryptStream = decryptStream;
    }
  });

  // node_modules/libp2p-noise/dist/src/keycache.js
  var require_keycache = __commonJS({
    "node_modules/libp2p-noise/dist/src/keycache.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.KeyCache = void 0;
      var Keycache = class {
        constructor() {
          this.storage = /* @__PURE__ */ new Map();
        }
        store(peerId, key) {
          this.storage.set(peerId.id, key);
        }
        load(peerId) {
          var _a;
          if (!peerId) {
            return null;
          }
          return (_a = this.storage.get(peerId.id)) !== null && _a !== void 0 ? _a : null;
        }
        resetStorage() {
          this.storage.clear();
        }
      };
      var KeyCache = new Keycache();
      exports2.KeyCache = KeyCache;
    }
  });

  // node_modules/libp2p-noise/dist/src/noise.js
  var require_noise = __commonJS({
    "node_modules/libp2p-noise/dist/src/noise.js"(exports2) {
      "use strict";
      var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function() {
          return m[k];
        } });
      } : function(o, m, k, k2) {
        if (k2 === void 0)
          k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports2 && exports2.__importStar || function(mod2) {
        if (mod2 && mod2.__esModule)
          return mod2;
        var result = {};
        if (mod2 != null) {
          for (var k in mod2)
            if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
              __createBinding(result, mod2, k);
        }
        __setModuleDefault(result, mod2);
        return result;
      };
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      exports2.Noise = void 0;
      var x25519 = __importStar(require_x25519());
      var buffer_1 = require_buffer();
      var it_pb_rpc_1 = __importDefault(require_src6());
      var duplex_1 = __importDefault(require_duplex2());
      var it_buffer_1 = __importDefault(require_it_buffer());
      var it_pipe_1 = __importDefault(require_it_pipe());
      var it_length_prefixed_1 = require_src7();
      var handshake_xx_1 = require_handshake_xx();
      var handshake_ik_1 = require_handshake_ik();
      var handshake_xx_fallback_1 = require_handshake_xx_fallback();
      var utils_1 = require_utils();
      var encoder_1 = require_encoder();
      var crypto_1 = require_crypto2();
      var keycache_1 = require_keycache();
      var logger_1 = require_logger();
      var constants_1 = require_constants4();
      var Noise2 = class {
        constructor(staticNoiseKey, earlyData) {
          this.protocol = "/noise";
          this.prologue = buffer_1.Buffer.alloc(0);
          this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
          this.useNoisePipes = false;
          if (staticNoiseKey) {
            const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);
            this.staticKeys = {
              privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),
              publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)
            };
          } else {
            this.staticKeys = utils_1.generateKeypair();
          }
        }
        async secureOutbound(localPeer, connection, remotePeer) {
          const wrappedConnection = it_pb_rpc_1.default(connection, {
            lengthEncoder: encoder_1.uint16BEEncode,
            lengthDecoder: encoder_1.uint16BEDecode,
            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
          });
          const handshake = await this.performHandshake({
            connection: wrappedConnection,
            isInitiator: true,
            localPeer,
            remotePeer
          });
          const conn = await this.createSecureConnection(wrappedConnection, handshake);
          return {
            conn,
            remoteEarlyData: handshake.remoteEarlyData,
            remotePeer: handshake.remotePeer
          };
        }
        async secureInbound(localPeer, connection, remotePeer) {
          const wrappedConnection = it_pb_rpc_1.default(connection, {
            lengthEncoder: encoder_1.uint16BEEncode,
            lengthDecoder: encoder_1.uint16BEDecode,
            maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
          });
          const handshake = await this.performHandshake({
            connection: wrappedConnection,
            isInitiator: false,
            localPeer,
            remotePeer
          });
          const conn = await this.createSecureConnection(wrappedConnection, handshake);
          return {
            conn,
            remoteEarlyData: handshake.remoteEarlyData,
            remotePeer: handshake.remotePeer
          };
        }
        async performHandshake(params) {
          var _a;
          const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
          let tryIK = this.useNoisePipes;
          if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {
            tryIK = false;
          }
          if (tryIK) {
            const { remotePeer, connection, isInitiator } = params;
            const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);
            try {
              return await this.performIKHandshake(ikHandshake);
            } catch (e) {
              let ephemeralKeys;
              if (params.isInitiator) {
                ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
              }
              return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
            }
          } else {
            return await this.performXXHandshake(params, payload);
          }
        }
        async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
          const { isInitiator, remotePeer, connection } = params;
          const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);
          try {
            await handshake.propose();
            await handshake.exchange();
            await handshake.finish();
          } catch (e) {
            logger_1.logger(e);
            const err = e;
            throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);
          }
          return handshake;
        }
        async performXXHandshake(params, payload) {
          const { isInitiator, remotePeer, connection } = params;
          const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);
          try {
            await handshake.propose();
            await handshake.exchange();
            await handshake.finish();
            if (this.useNoisePipes && handshake.remotePeer) {
              keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
            }
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred during XX handshake: ${err.message}`);
          }
          return handshake;
        }
        async performIKHandshake(handshake) {
          await handshake.stage0();
          await handshake.stage1();
          return handshake;
        }
        async createSecureConnection(connection, handshake) {
          const [secure, user] = duplex_1.default();
          const network = connection.unwrap();
          await it_pipe_1.default(secure, it_buffer_1.default, crypto_1.encryptStream(handshake), it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), network, it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), it_buffer_1.default, crypto_1.decryptStream(handshake), secure);
          return user;
        }
      };
      exports2.Noise = Noise2;
    }
  });

  // node_modules/it-pipe/index.js
  var require_it_pipe2 = __commonJS({
    "node_modules/it-pipe/index.js"(exports2, module2) {
      var rawPipe = (...fns) => {
        let res;
        while (fns.length) {
          res = fns.shift()(res);
        }
        return res;
      };
      var isIterable = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
      var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable(obj.source);
      var duplexPipelineFn = (duplex) => (source) => {
        duplex.sink(source);
        return duplex.source;
      };
      var pipe = (...fns) => {
        if (isDuplex(fns[0])) {
          const duplex = fns[0];
          fns[0] = () => duplex.source;
        } else if (isIterable(fns[0])) {
          const source = fns[0];
          fns[0] = () => source;
        }
        if (fns.length > 1) {
          if (isDuplex(fns[fns.length - 1])) {
            fns[fns.length - 1] = fns[fns.length - 1].sink;
          }
        }
        if (fns.length > 2) {
          for (let i = 1; i < fns.length - 1; i++) {
            if (isDuplex(fns[i])) {
              fns[i] = duplexPipelineFn(fns[i]);
            }
          }
        }
        return rawPipe(...fns);
      };
      module2.exports = pipe;
      module2.exports.pipe = pipe;
      module2.exports.rawPipe = rawPipe;
      module2.exports.isIterable = isIterable;
      module2.exports.isDuplex = isDuplex;
    }
  });

  // node_modules/fast-fifo/fixed-size.js
  var require_fixed_size2 = __commonJS({
    "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
      module2.exports = class FixedFIFO {
        constructor(hwm) {
          if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
            throw new Error("Max size for a FixedFIFO should be a power of two");
          this.buffer = new Array(hwm);
          this.mask = hwm - 1;
          this.top = 0;
          this.btm = 0;
          this.next = null;
        }
        push(data) {
          if (this.buffer[this.top] !== void 0)
            return false;
          this.buffer[this.top] = data;
          this.top = this.top + 1 & this.mask;
          return true;
        }
        shift() {
          const last = this.buffer[this.btm];
          if (last === void 0)
            return void 0;
          this.buffer[this.btm] = void 0;
          this.btm = this.btm + 1 & this.mask;
          return last;
        }
        isEmpty() {
          return this.buffer[this.btm] === void 0;
        }
      };
    }
  });

  // node_modules/fast-fifo/index.js
  var require_fast_fifo2 = __commonJS({
    "node_modules/fast-fifo/index.js"(exports2, module2) {
      var FixedFIFO = require_fixed_size2();
      module2.exports = class FastFIFO {
        constructor(hwm) {
          this.hwm = hwm || 16;
          this.head = new FixedFIFO(this.hwm);
          this.tail = this.head;
        }
        push(val) {
          if (!this.head.push(val)) {
            const prev = this.head;
            this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
            this.head.push(val);
          }
        }
        shift() {
          const val = this.tail.shift();
          if (val === void 0 && this.tail.next) {
            const next = this.tail.next;
            this.tail.next = null;
            this.tail = next;
            return this.tail.shift();
          }
          return val;
        }
        isEmpty() {
          return this.head.isEmpty();
        }
      };
    }
  });

  // node_modules/it-pushable/index.js
  var require_it_pushable2 = __commonJS({
    "node_modules/it-pushable/index.js"(exports2, module2) {
      var FIFO = require_fast_fifo2();
      module2.exports = (options) => {
        options = options || {};
        let onEnd;
        if (typeof options === "function") {
          onEnd = options;
          options = {};
        } else {
          onEnd = options.onEnd;
        }
        let buffer = new FIFO();
        let pushable, onNext, ended;
        const waitNext = () => {
          if (!buffer.isEmpty()) {
            if (options.writev) {
              let next2;
              const values = [];
              while (!buffer.isEmpty()) {
                next2 = buffer.shift();
                if (next2.error)
                  throw next2.error;
                values.push(next2.value);
              }
              return { done: next2.done, value: values };
            }
            const next = buffer.shift();
            if (next.error)
              throw next.error;
            return next;
          }
          if (ended)
            return { done: true };
          return new Promise((resolve, reject) => {
            onNext = (next) => {
              onNext = null;
              if (next.error) {
                reject(next.error);
              } else {
                if (options.writev && !next.done) {
                  resolve({ done: next.done, value: [next.value] });
                } else {
                  resolve(next);
                }
              }
              return pushable;
            };
          });
        };
        const bufferNext = (next) => {
          if (onNext)
            return onNext(next);
          buffer.push(next);
          return pushable;
        };
        const bufferError = (err) => {
          buffer = new FIFO();
          if (onNext)
            return onNext({ error: err });
          buffer.push({ error: err });
          return pushable;
        };
        const push = (value) => {
          if (ended)
            return pushable;
          return bufferNext({ done: false, value });
        };
        const end = (err) => {
          if (ended)
            return pushable;
          ended = true;
          return err ? bufferError(err) : bufferNext({ done: true });
        };
        const _return = () => {
          buffer = new FIFO();
          end();
          return { done: true };
        };
        const _throw = (err) => {
          end(err);
          return { done: true };
        };
        pushable = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: waitNext,
          return: _return,
          throw: _throw,
          push,
          end
        };
        if (!onEnd)
          return pushable;
        const _pushable = pushable;
        pushable = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next() {
            return _pushable.next();
          },
          throw(err) {
            _pushable.throw(err);
            if (onEnd) {
              onEnd(err);
              onEnd = null;
            }
            return { done: true };
          },
          return() {
            _pushable.return();
            if (onEnd) {
              onEnd();
              onEnd = null;
            }
            return { done: true };
          },
          push,
          end(err) {
            _pushable.end(err);
            if (onEnd) {
              onEnd(err);
              onEnd = null;
            }
            return pushable;
          }
        };
        return pushable;
      };
    }
  });

  // node_modules/libp2p-mplex/src/coder/encode.browser.js
  var require_encode_browser = __commonJS({
    "node_modules/libp2p-mplex/src/coder/encode.browser.js"(exports2, module2) {
      "use strict";
      var varint4 = require_varint();
      var BufferList = require_BufferList();
      var POOL_SIZE = 10 * 1024;
      var Encoder2 = class {
        constructor() {
          this._pool = new Uint8Array(POOL_SIZE);
          this._poolOffset = 0;
        }
        write(msg) {
          const pool = this._pool;
          let offset = this._poolOffset;
          varint4.encode(msg.id << 3 | msg.type, pool, offset);
          offset += varint4.encode.bytes;
          varint4.encode(msg.data ? msg.data.length : 0, pool, offset);
          offset += varint4.encode.bytes;
          const header = pool.subarray(this._poolOffset, offset);
          if (POOL_SIZE - offset < 100) {
            this._pool = new Uint8Array(POOL_SIZE);
            this._poolOffset = 0;
          } else {
            this._poolOffset = offset;
          }
          if (!msg.data)
            return header;
          return [header, msg.data];
        }
      };
      var encoder = new Encoder2();
      module2.exports = (source) => async function* encode3() {
        for await (const msg of source) {
          if (Array.isArray(msg)) {
            yield new BufferList(msg.map((m) => encoder.write(m)));
          } else {
            yield new BufferList(encoder.write(msg));
          }
        }
      }();
    }
  });

  // node_modules/libp2p-mplex/src/coder/decode.js
  var require_decode5 = __commonJS({
    "node_modules/libp2p-mplex/src/coder/decode.js"(exports2, module2) {
      "use strict";
      var varint4 = require_varint();
      var BufferList = require_BufferList();
      module2.exports = (source) => async function* decode5() {
        const decoder = new Decoder2();
        for await (const chunk of source) {
          const msgs = decoder.write(chunk);
          if (msgs.length)
            yield msgs;
        }
      }();
      var Decoder2 = class {
        constructor() {
          this._buffer = new BufferList();
          this._bufferProxy = new Proxy({}, {
            get: (_, prop) => prop[0] === "l" ? this._buffer[prop] : this._buffer.get(parseInt(prop))
          });
          this._headerInfo = null;
        }
        write(chunk) {
          if (!chunk || !chunk.length)
            return [];
          this._buffer.append(chunk);
          const msgs = [];
          while (true) {
            if (!this._headerInfo) {
              try {
                this._headerInfo = this._decodeHeader(this._bufferProxy);
              } catch (_) {
                break;
              }
            }
            const { id, type, length: length2, offset } = this._headerInfo;
            const bufferedDataLength = this._buffer.length - offset;
            if (bufferedDataLength < length2)
              break;
            msgs.push({ id, type, data: this._buffer.shallowSlice(offset, offset + length2) });
            this._buffer.consume(offset + length2);
            this._headerInfo = null;
          }
          return msgs;
        }
        _decodeHeader(data) {
          const h = varint4.decode(data);
          let offset = varint4.decode.bytes;
          const length2 = varint4.decode(data, offset);
          offset += varint4.decode.bytes;
          return { id: h >> 3, type: h & 7, offset, length: length2 };
        }
      };
    }
  });

  // node_modules/libp2p-mplex/src/coder/index.js
  var require_coder = __commonJS({
    "node_modules/libp2p-mplex/src/coder/index.js"(exports2) {
      "use strict";
      exports2.encode = require_encode_browser();
      exports2.decode = require_decode5();
    }
  });

  // node_modules/libp2p-mplex/src/restrict-size.js
  var require_restrict_size = __commonJS({
    "node_modules/libp2p-mplex/src/restrict-size.js"(exports2, module2) {
      "use strict";
      var MAX_MSG_SIZE = 1 << 20;
      module2.exports = (max) => {
        max = max || MAX_MSG_SIZE;
        const checkSize = (msg) => {
          if (msg.data && msg.data.length > max) {
            throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
          }
        };
        return (source) => {
          return async function* restrictSize() {
            for await (const msg of source) {
              if (Array.isArray(msg)) {
                msg.forEach(checkSize);
              } else {
                checkSize(msg);
              }
              yield msg;
            }
          }();
        };
      };
      module2.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
    }
  });

  // node_modules/libp2p-mplex/src/message-types.js
  var require_message_types = __commonJS({
    "node_modules/libp2p-mplex/src/message-types.js"(exports2) {
      "use strict";
      var MessageTypes = Object.freeze({
        NEW_STREAM: 0,
        MESSAGE_RECEIVER: 1,
        MESSAGE_INITIATOR: 2,
        CLOSE_RECEIVER: 3,
        CLOSE_INITIATOR: 4,
        RESET_RECEIVER: 5,
        RESET_INITIATOR: 6
      });
      exports2.MessageTypes = MessageTypes;
      exports2.InitiatorMessageTypes = Object.freeze({
        NEW_STREAM: MessageTypes.NEW_STREAM,
        MESSAGE: MessageTypes.MESSAGE_INITIATOR,
        CLOSE: MessageTypes.CLOSE_INITIATOR,
        RESET: MessageTypes.RESET_INITIATOR
      });
      exports2.ReceiverMessageTypes = Object.freeze({
        MESSAGE: MessageTypes.MESSAGE_RECEIVER,
        CLOSE: MessageTypes.CLOSE_RECEIVER,
        RESET: MessageTypes.RESET_RECEIVER
      });
      exports2.MessageTypeNames = Object.freeze(Object.entries(MessageTypes).reduce((obj, e) => {
        obj[e[1]] = e[0];
        return obj;
      }, {}));
    }
  });

  // node_modules/abort-controller/browser.js
  var require_browser4 = __commonJS({
    "node_modules/abort-controller/browser.js"(exports2, module2) {
      "use strict";
      var { AbortController, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
      module2.exports = AbortController;
      module2.exports.AbortSignal = AbortSignal;
      module2.exports.default = AbortController;
    }
  });

  // node_modules/libp2p-mplex/src/stream.js
  var require_stream = __commonJS({
    "node_modules/libp2p-mplex/src/stream.js"(exports2, module2) {
      "use strict";
      var abortable = require_abortable_iterator();
      var AbortController = require_browser4();
      var log = require_browser2()("libp2p:mplex:stream");
      var pushable = require_it_pushable2();
      var BufferList = require_BufferList();
      var errCode = require_err_code();
      var { MAX_MSG_SIZE } = require_restrict_size();
      var { InitiatorMessageTypes, ReceiverMessageTypes } = require_message_types();
      var ERR_MPLEX_STREAM_RESET = "ERR_MPLEX_STREAM_RESET";
      var ERR_MPLEX_STREAM_ABORT = "ERR_MPLEX_STREAM_ABORT";
      module2.exports = ({ id, name, send, onEnd = () => {
      }, type = "initiator", maxMsgSize = MAX_MSG_SIZE }) => {
        const abortController = new AbortController();
        const resetController = new AbortController();
        const Types = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
        const externalId = type === "initiator" ? `i${id}` : `r${id}`;
        name = String(name == null ? id : name);
        let sourceEnded = false;
        let sinkEnded = false;
        let endErr;
        const onSourceEnd = (err) => {
          if (sourceEnded)
            return;
          sourceEnded = true;
          log("%s stream %s source end", type, name, err);
          if (err && !endErr)
            endErr = err;
          if (sinkEnded) {
            stream.timeline.close = Date.now();
            onEnd(endErr);
          }
        };
        const onSinkEnd = (err) => {
          if (sinkEnded)
            return;
          sinkEnded = true;
          log("%s stream %s sink end", type, name, err);
          if (err && !endErr)
            endErr = err;
          if (sourceEnded) {
            stream.timeline.close = Date.now();
            onEnd(endErr);
          }
        };
        const stream = {
          close: () => stream.source.end(),
          abort: (err) => {
            log("%s stream %s abort", type, name, err);
            stream.source.end(err);
            abortController.abort();
            onSinkEnd(err);
          },
          reset: () => {
            const err = errCode(new Error("stream reset"), ERR_MPLEX_STREAM_RESET);
            resetController.abort();
            stream.source.end(err);
            onSinkEnd(err);
          },
          sink: async (source) => {
            source = abortable(source, [
              { signal: abortController.signal, options: { abortMessage: "stream aborted", abortCode: ERR_MPLEX_STREAM_ABORT } },
              { signal: resetController.signal, options: { abortMessage: "stream reset", abortCode: ERR_MPLEX_STREAM_RESET } }
            ]);
            if (type === "initiator") {
              send({ id, type: Types.NEW_STREAM, data: name });
            }
            try {
              for await (let data of source) {
                while (data.length) {
                  if (data.length <= maxMsgSize) {
                    send({ id, type: Types.MESSAGE, data });
                    break;
                  }
                  data = BufferList.isBufferList(data) ? data : new BufferList(data);
                  send({ id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize) });
                  data.consume(maxMsgSize);
                }
              }
            } catch (err) {
              if (err.code === ERR_MPLEX_STREAM_RESET) {
                log("%s stream %s reset", type, name);
              } else {
                log("%s stream %s error", type, name, err);
                send({ id, type: Types.RESET });
              }
              stream.source.end(err);
              return onSinkEnd(err);
            }
            send({ id, type: Types.CLOSE });
            onSinkEnd();
          },
          source: pushable(onSourceEnd),
          timeline: {
            open: Date.now(),
            close: null
          },
          id: externalId
        };
        return stream;
      };
    }
  });

  // node_modules/libp2p-mplex/src/mplex.js
  var require_mplex = __commonJS({
    "node_modules/libp2p-mplex/src/mplex.js"(exports2, module2) {
      "use strict";
      var pipe = require_it_pipe2();
      var pushable = require_it_pushable2();
      var log = require_browser2()("libp2p:mplex");
      var abortable = require_abortable_iterator();
      var Coder = require_coder();
      var restrictSize = require_restrict_size();
      var { MessageTypes, MessageTypeNames } = require_message_types();
      var createStream = require_stream();
      var Mplex2 = class {
        constructor(options) {
          options = options || {};
          options = typeof options === "function" ? { onStream: options } : options;
          this._streamId = 0;
          this._streams = {
            initiators: /* @__PURE__ */ new Map(),
            receivers: /* @__PURE__ */ new Map()
          };
          this._options = options;
          this.sink = this._createSink();
          this.source = this._createSource();
          this.onStream = options.onStream;
          this.onStreamEnd = options.onStreamEnd;
        }
        get streams() {
          const streams = [];
          this._streams.initiators.forEach((stream) => {
            streams.push(stream);
          });
          this._streams.receivers.forEach((stream) => {
            streams.push(stream);
          });
          return streams;
        }
        newStream(name) {
          const id = this._streamId++;
          name = name == null ? id.toString() : String(name);
          const registry = this._streams.initiators;
          return this._newStream({ id, name, type: "initiator", registry });
        }
        _newReceiverStream({ id, name }) {
          const registry = this._streams.receivers;
          return this._newStream({ id, name, type: "receiver", registry });
        }
        _newStream({ id, name, type, registry }) {
          if (registry.has(id)) {
            throw new Error(`${type} stream ${id} already exists!`);
          }
          log("new %s stream %s %s", type, id, name);
          const send = (msg) => {
            if (log.enabled) {
              log("%s stream %s %s send", type, id, name, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() });
            }
            return this.source.push(msg);
          };
          const onEnd = () => {
            log("%s stream %s %s ended", type, id, name);
            registry.delete(id);
            this.onStreamEnd && this.onStreamEnd(stream);
          };
          const stream = createStream({ id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize });
          registry.set(id, stream);
          return stream;
        }
        _createSink() {
          return async (source) => {
            if (this._options.signal) {
              source = abortable(source, this._options.signal);
            }
            try {
              await pipe(source, Coder.decode, restrictSize(this._options.maxMsgSize), async (source2) => {
                for await (const msgs of source2) {
                  for (const msg of msgs) {
                    this._handleIncoming(msg);
                  }
                }
              });
            } catch (err) {
              log("error in sink", err);
              return this.source.end(err);
            }
            this.source.end();
          };
        }
        _createSource() {
          const onEnd = (err) => {
            const { initiators, receivers } = this._streams;
            for (const s of initiators.values())
              s.abort(err);
            for (const s of receivers.values())
              s.abort(err);
          };
          const source = pushable({ onEnd, writev: true });
          return Object.assign(Coder.encode(source), {
            push: source.push,
            end: source.end,
            return: source.return
          });
        }
        _handleIncoming({ id, type, data }) {
          if (log.enabled) {
            log("incoming message", { id, type: MessageTypeNames[type], data: data.slice() });
          }
          if (type === MessageTypes.NEW_STREAM && this.onStream) {
            const stream2 = this._newReceiverStream({ id, name: data.toString() });
            return this.onStream(stream2);
          }
          const list = type & 1 ? this._streams.initiators : this._streams.receivers;
          const stream = list.get(id);
          if (!stream)
            return log("missing stream %s", id);
          switch (type) {
            case MessageTypes.MESSAGE_INITIATOR:
            case MessageTypes.MESSAGE_RECEIVER:
              stream.source.push(data);
              break;
            case MessageTypes.CLOSE_INITIATOR:
            case MessageTypes.CLOSE_RECEIVER:
              stream.close();
              break;
            case MessageTypes.RESET_INITIATOR:
            case MessageTypes.RESET_RECEIVER:
              stream.reset();
              break;
            default:
              log("unknown message type %s", type);
          }
        }
      };
      Mplex2.multicodec = "/mplex/6.7.0";
      module2.exports = Mplex2;
    }
  });

  // node_modules/libp2p-mplex/src/index.js
  var require_src10 = __commonJS({
    "node_modules/libp2p-mplex/src/index.js"(exports2, module2) {
      "use strict";
      module2.exports = require_mplex();
    }
  });

  // node_modules/events/events.js
  var require_events = __commonJS({
    "node_modules/events/events.js"(exports2, module2) {
      "use strict";
      var R = typeof Reflect === "object" ? Reflect : null;
      var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
        return Function.prototype.apply.call(target, receiver, args);
      };
      var ReflectOwnKeys;
      if (R && typeof R.ownKeys === "function") {
        ReflectOwnKeys = R.ownKeys;
      } else if (Object.getOwnPropertySymbols) {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
        };
      } else {
        ReflectOwnKeys = function ReflectOwnKeys2(target) {
          return Object.getOwnPropertyNames(target);
        };
      }
      function ProcessEmitWarning(warning) {
        if (console && console.warn)
          console.warn(warning);
      }
      var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
        return value !== value;
      };
      function EventEmitter() {
        EventEmitter.init.call(this);
      }
      module2.exports = EventEmitter;
      module2.exports.once = once;
      EventEmitter.EventEmitter = EventEmitter;
      EventEmitter.prototype._events = void 0;
      EventEmitter.prototype._eventsCount = 0;
      EventEmitter.prototype._maxListeners = void 0;
      var defaultMaxListeners = 10;
      function checkListener(listener) {
        if (typeof listener !== "function") {
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
        }
      }
      Object.defineProperty(EventEmitter, "defaultMaxListeners", {
        enumerable: true,
        get: function() {
          return defaultMaxListeners;
        },
        set: function(arg) {
          if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
          }
          defaultMaxListeners = arg;
        }
      });
      EventEmitter.init = function() {
        if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        }
        this._maxListeners = this._maxListeners || void 0;
      };
      EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
        if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
        }
        this._maxListeners = n;
        return this;
      };
      function _getMaxListeners(that) {
        if (that._maxListeners === void 0)
          return EventEmitter.defaultMaxListeners;
        return that._maxListeners;
      }
      EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
        return _getMaxListeners(this);
      };
      EventEmitter.prototype.emit = function emit(type) {
        var args = [];
        for (var i = 1; i < arguments.length; i++)
          args.push(arguments[i]);
        var doError = type === "error";
        var events = this._events;
        if (events !== void 0)
          doError = doError && events.error === void 0;
        else if (!doError)
          return false;
        if (doError) {
          var er;
          if (args.length > 0)
            er = args[0];
          if (er instanceof Error) {
            throw er;
          }
          var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
          err.context = er;
          throw err;
        }
        var handler = events[type];
        if (handler === void 0)
          return false;
        if (typeof handler === "function") {
          ReflectApply(handler, this, args);
        } else {
          var len = handler.length;
          var listeners = arrayClone(handler, len);
          for (var i = 0; i < len; ++i)
            ReflectApply(listeners[i], this, args);
        }
        return true;
      };
      function _addListener(target, type, listener, prepend) {
        var m;
        var events;
        var existing;
        checkListener(listener);
        events = target._events;
        if (events === void 0) {
          events = target._events = Object.create(null);
          target._eventsCount = 0;
        } else {
          if (events.newListener !== void 0) {
            target.emit("newListener", type, listener.listener ? listener.listener : listener);
            events = target._events;
          }
          existing = events[type];
        }
        if (existing === void 0) {
          existing = events[type] = listener;
          ++target._eventsCount;
        } else {
          if (typeof existing === "function") {
            existing = events[type] = prepend ? [listener, existing] : [existing, listener];
          } else if (prepend) {
            existing.unshift(listener);
          } else {
            existing.push(listener);
          }
          m = _getMaxListeners(target);
          if (m > 0 && existing.length > m && !existing.warned) {
            existing.warned = true;
            var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
            w.name = "MaxListenersExceededWarning";
            w.emitter = target;
            w.type = type;
            w.count = existing.length;
            ProcessEmitWarning(w);
          }
        }
        return target;
      }
      EventEmitter.prototype.addListener = function addListener(type, listener) {
        return _addListener(this, type, listener, false);
      };
      EventEmitter.prototype.on = EventEmitter.prototype.addListener;
      EventEmitter.prototype.prependListener = function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
      function onceWrapper() {
        if (!this.fired) {
          this.target.removeListener(this.type, this.wrapFn);
          this.fired = true;
          if (arguments.length === 0)
            return this.listener.call(this.target);
          return this.listener.apply(this.target, arguments);
        }
      }
      function _onceWrap(target, type, listener) {
        var state = { fired: false, wrapFn: void 0, target, type, listener };
        var wrapped = onceWrapper.bind(state);
        wrapped.listener = listener;
        state.wrapFn = wrapped;
        return wrapped;
      }
      EventEmitter.prototype.once = function once2(type, listener) {
        checkListener(listener);
        this.on(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
        checkListener(listener);
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
      EventEmitter.prototype.removeListener = function removeListener(type, listener) {
        var list, events, position, i, originalListener;
        checkListener(listener);
        events = this._events;
        if (events === void 0)
          return this;
        list = events[type];
        if (list === void 0)
          return this;
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit("removeListener", type, list.listener || listener);
          }
        } else if (typeof list !== "function") {
          position = -1;
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
          if (position < 0)
            return this;
          if (position === 0)
            list.shift();
          else {
            spliceOne(list, position);
          }
          if (list.length === 1)
            events[type] = list[0];
          if (events.removeListener !== void 0)
            this.emit("removeListener", type, originalListener || listener);
        }
        return this;
      };
      EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
      EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
        var listeners, events, i;
        events = this._events;
        if (events === void 0)
          return this;
        if (events.removeListener === void 0) {
          if (arguments.length === 0) {
            this._events = Object.create(null);
            this._eventsCount = 0;
          } else if (events[type] !== void 0) {
            if (--this._eventsCount === 0)
              this._events = Object.create(null);
            else
              delete events[type];
          }
          return this;
        }
        if (arguments.length === 0) {
          var keys = Object.keys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === "removeListener")
              continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners("removeListener");
          this._events = Object.create(null);
          this._eventsCount = 0;
          return this;
        }
        listeners = events[type];
        if (typeof listeners === "function") {
          this.removeListener(type, listeners);
        } else if (listeners !== void 0) {
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
        return this;
      };
      function _listeners(target, type, unwrap) {
        var events = target._events;
        if (events === void 0)
          return [];
        var evlistener = events[type];
        if (evlistener === void 0)
          return [];
        if (typeof evlistener === "function")
          return unwrap ? [evlistener.listener || evlistener] : [evlistener];
        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
      }
      EventEmitter.prototype.listeners = function listeners(type) {
        return _listeners(this, type, true);
      };
      EventEmitter.prototype.rawListeners = function rawListeners(type) {
        return _listeners(this, type, false);
      };
      EventEmitter.listenerCount = function(emitter, type) {
        if (typeof emitter.listenerCount === "function") {
          return emitter.listenerCount(type);
        } else {
          return listenerCount.call(emitter, type);
        }
      };
      EventEmitter.prototype.listenerCount = listenerCount;
      function listenerCount(type) {
        var events = this._events;
        if (events !== void 0) {
          var evlistener = events[type];
          if (typeof evlistener === "function") {
            return 1;
          } else if (evlistener !== void 0) {
            return evlistener.length;
          }
        }
        return 0;
      }
      EventEmitter.prototype.eventNames = function eventNames() {
        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
      };
      function arrayClone(arr, n) {
        var copy = new Array(n);
        for (var i = 0; i < n; ++i)
          copy[i] = arr[i];
        return copy;
      }
      function spliceOne(list, index) {
        for (; index + 1 < list.length; index++)
          list[index] = list[index + 1];
        list.pop();
      }
      function unwrapListeners(arr) {
        var ret = new Array(arr.length);
        for (var i = 0; i < ret.length; ++i) {
          ret[i] = arr[i].listener || arr[i];
        }
        return ret;
      }
      function once(emitter, name) {
        return new Promise(function(resolve, reject) {
          function errorListener(err) {
            emitter.removeListener(name, resolver);
            reject(err);
          }
          function resolver() {
            if (typeof emitter.removeListener === "function") {
              emitter.removeListener("error", errorListener);
            }
            resolve([].slice.call(arguments));
          }
          ;
          eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
          if (name !== "error") {
            addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
          }
        });
      }
      function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
        if (typeof emitter.on === "function") {
          eventTargetAgnosticAddListener(emitter, "error", handler, flags);
        }
      }
      function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
        if (typeof emitter.on === "function") {
          if (flags.once) {
            emitter.once(name, listener);
          } else {
            emitter.on(name, listener);
          }
        } else if (typeof emitter.addEventListener === "function") {
          emitter.addEventListener(name, function wrapListener(arg) {
            if (flags.once) {
              emitter.removeEventListener(name, wrapListener);
            }
            listener(arg);
          });
        } else {
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
        }
      }
    }
  });

  // node_modules/it-filter/index.js
  var require_it_filter = __commonJS({
    "node_modules/it-filter/index.js"(exports2, module2) {
      "use strict";
      var filter = async function* (source, fn) {
        for await (const entry of source) {
          if (await fn(entry)) {
            yield entry;
          }
        }
      };
      module2.exports = filter;
    }
  });

  // node_modules/it-map/index.js
  var require_it_map = __commonJS({
    "node_modules/it-map/index.js"(exports2, module2) {
      "use strict";
      var map = async function* (source, func) {
        for await (const val of source) {
          yield func(val);
        }
      };
      module2.exports = map;
    }
  });

  // node_modules/it-take/index.js
  var require_it_take = __commonJS({
    "node_modules/it-take/index.js"(exports2, module2) {
      "use strict";
      var take = async function* (source, limit) {
        let items = 0;
        if (limit < 1) {
          return;
        }
        for await (const entry of source) {
          yield entry;
          items++;
          if (items === limit) {
            return;
          }
        }
      };
      module2.exports = take;
    }
  });

  // node_modules/libp2p/src/content-routing/utils.js
  var require_utils2 = __commonJS({
    "node_modules/libp2p/src/content-routing/utils.js"(exports2, module2) {
      "use strict";
      var errCode = require_err_code();
      var filter = require_it_filter();
      var map = require_it_map();
      var take = require_it_take();
      function storeAddresses(source, peerStore) {
        return map(source, (peer) => {
          peerStore.addressBook.add(peer.id, peer.multiaddrs);
          return peer;
        });
      }
      function uniquePeers(source) {
        const seen = /* @__PURE__ */ new Set();
        return filter(source, (peer) => {
          if (seen.has(peer.id.toString())) {
            return false;
          }
          seen.add(peer.id.toString());
          return true;
        });
      }
      async function* requirePeers(source, min = 1) {
        let seen = 0;
        for await (const peer of source) {
          seen++;
          yield peer;
        }
        if (seen < min) {
          throw errCode(new Error("not found"), "NOT_FOUND");
        }
      }
      function maybeLimitSource(source, max) {
        if (max) {
          return take(source, max);
        }
        return source;
      }
      module2.exports = {
        storeAddresses,
        uniquePeers,
        requirePeers,
        maybeLimitSource
      };
    }
  });

  // node_modules/it-merge/index.js
  var require_it_merge = __commonJS({
    "node_modules/it-merge/index.js"(exports2, module2) {
      "use strict";
      var pushable = require_it_pushable2();
      var merge = async function* (...sources) {
        const output = pushable();
        setTimeout(async () => {
          try {
            await Promise.all(sources.map(async (source) => {
              for await (const item of source) {
                output.push(item);
              }
            }));
            output.end();
          } catch (err) {
            output.end(err);
          }
        }, 0);
        yield* output;
      };
      module2.exports = merge;
    }
  });

  // node_modules/it-first/index.js
  var require_it_first = __commonJS({
    "node_modules/it-first/index.js"(exports2, module2) {
      "use strict";
      var first = async (source) => {
        for await (const entry of source) {
          return entry;
        }
        return void 0;
      };
      module2.exports = first;
    }
  });

  // node_modules/it-drain/index.js
  var require_it_drain = __commonJS({
    "node_modules/it-drain/index.js"(exports2, module2) {
      "use strict";
      var drain = async (source) => {
        for await (const _ of source) {
        }
      };
      module2.exports = drain;
    }
  });

  // node_modules/set-delayed-interval/src/index.js
  var require_src11 = __commonJS({
    "node_modules/set-delayed-interval/src/index.js"(exports2, module2) {
      "use strict";
      var intervals = /* @__PURE__ */ new Map();
      var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
      async function _runPeriodically(task, interval, id) {
        while (intervals.get(id)) {
          try {
            await task();
          } catch (err) {
            setTimeout(() => {
              throw err;
            }, 1);
            break;
          }
          if (!intervals.get(id)) {
            break;
          }
          await new Promise((resolve) => {
            const _timeout = setTimeout(resolve, interval);
            intervals.set(id, _timeout);
          });
        }
      }
      function setDelayedInterval(task, interval, delay) {
        delay = delay || interval;
        const id = _generateId();
        const _timeout = setTimeout(() => {
          _runPeriodically(task, interval, id);
        }, delay);
        intervals.set(id, _timeout);
        return id;
      }
      function clearDelayedInterval(id) {
        const _timeout = intervals.get(id);
        if (_timeout) {
          clearTimeout(_timeout);
          intervals.delete(id);
        }
      }
      module2.exports = {
        setDelayedInterval,
        clearDelayedInterval
      };
    }
  });

  // node_modules/libp2p/src/errors.js
  var require_errors2 = __commonJS({
    "node_modules/libp2p/src/errors.js"(exports2) {
      "use strict";
      exports2.messages = {
        NOT_STARTED_YET: "The libp2p node is not started yet",
        DHT_DISABLED: "DHT is not available",
        CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required",
        NOT_FOUND: "Not found"
      };
      exports2.codes = {
        DHT_DISABLED: "ERR_DHT_DISABLED",
        PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED",
        DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED",
        CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED",
        ERR_INVALID_PROTOCOLS_FOR_STREAM: "ERR_INVALID_PROTOCOLS_FOR_STREAM",
        ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED",
        ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED",
        ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED",
        ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED",
        ERR_TOO_MANY_ADDRESSES: "ERR_TOO_MANY_ADDRESSES",
        ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES",
        ERR_RELAYED_DIAL: "ERR_RELAYED_DIAL",
        ERR_DIALED_SELF: "ERR_DIALED_SELF",
        ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF",
        ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT",
        ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED",
        ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED",
        ERR_INVALID_KEY: "ERR_INVALID_KEY",
        ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE",
        ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
        ERR_INVALID_PEER: "ERR_INVALID_PEER",
        ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE",
        ERR_NOT_FOUND: "ERR_NOT_FOUND",
        ERR_TIMEOUT: "ERR_TIMEOUT",
        ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE",
        ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED",
        ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL",
        ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR",
        ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
      };
    }
  });

  // node_modules/libp2p/src/dht/dht-peer-routing.js
  var require_dht_peer_routing = __commonJS({
    "node_modules/libp2p/src/dht/dht-peer-routing.js"(exports2, module2) {
      "use strict";
      var errCode = require_err_code();
      var { messages, codes } = require_errors2();
      var DHTPeerRouting = class {
        constructor(dht) {
          this._dht = dht;
        }
        async findPeer(peerId, options = {}) {
          for await (const event of this._dht.findPeer(peerId, options)) {
            if (event.name === "FINAL_PEER") {
              return event.peer;
            }
          }
          throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
        }
        async *getClosestPeers(key, options = {}) {
          for await (const event of this._dht.getClosestPeers(key, options)) {
            if (event.name === "PEER_RESPONSE") {
              yield* event.closer;
            }
          }
        }
      };
      module2.exports = { DHTPeerRouting };
    }
  });

  // node_modules/libp2p/src/peer-routing.js
  var require_peer_routing = __commonJS({
    "node_modules/libp2p/src/peer-routing.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:peer-routing"), {
        error: debug("libp2p:peer-routing:err")
      });
      var errCode = require_err_code();
      var {
        storeAddresses,
        uniquePeers,
        requirePeers
      } = require_utils2();
      var merge = require_it_merge();
      var { pipe } = require_it_pipe2();
      var first = require_it_first();
      var drain = require_it_drain();
      var filter = require_it_filter();
      var {
        setDelayedInterval,
        clearDelayedInterval
      } = require_src11();
      var { DHTPeerRouting } = require_dht_peer_routing();
      var PeerRouting = class {
        constructor(libp2p) {
          this._peerId = libp2p.peerId;
          this._peerStore = libp2p.peerStore;
          this._routers = libp2p._modules.peerRouting || [];
          if (libp2p._dht && libp2p._config.dht.enabled) {
            this._routers.push(new DHTPeerRouting(libp2p._dht));
          }
          this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;
          this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
        }
        start() {
          if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {
            return;
          }
          this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);
        }
        async _findClosestPeersTask() {
          try {
            await drain(this.getClosestPeers(this._peerId.id));
          } catch (err) {
            log.error(err);
          }
        }
        stop() {
          clearDelayedInterval(this._timeoutId);
        }
        async findPeer(id, options) {
          if (!this._routers.length) {
            throw errCode(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
          }
          if (id.toB58String() === this._peerId.toB58String()) {
            throw errCode(new Error("Should not try to find self"), "ERR_FIND_SELF");
          }
          const output = await pipe(merge(...this._routers.map((router) => [router.findPeer(id, options)])), (source) => filter(source, Boolean), (source) => storeAddresses(source, this._peerStore), (source) => first(source));
          if (output) {
            return output;
          }
          throw errCode(new Error("not found"), "NOT_FOUND");
        }
        async *getClosestPeers(key, options = { timeout: 3e4 }) {
          if (!this._routers.length) {
            throw errCode(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
          }
          yield* pipe(merge(...this._routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this._peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
        }
      };
      module2.exports = PeerRouting;
    }
  });

  // node_modules/libp2p/src/dht/dht-content-routing.js
  var require_dht_content_routing = __commonJS({
    "node_modules/libp2p/src/dht/dht-content-routing.js"(exports2, module2) {
      "use strict";
      var drain = require_it_drain();
      var DHTContentRouting = class {
        constructor(dht) {
          this._dht = dht;
        }
        async provide(cid) {
          await drain(this._dht.provide(cid));
        }
        async *findProviders(cid, options) {
          for await (const event of this._dht.findProviders(cid, options)) {
            if (event.name === "PROVIDER") {
              yield* event.providers;
            }
          }
        }
      };
      module2.exports = { DHTContentRouting };
    }
  });

  // node_modules/libp2p/src/content-routing/index.js
  var require_content_routing = __commonJS({
    "node_modules/libp2p/src/content-routing/index.js"(exports2, module2) {
      "use strict";
      var errCode = require_err_code();
      var { messages, codes } = require_errors2();
      var {
        storeAddresses,
        uniquePeers,
        requirePeers,
        maybeLimitSource
      } = require_utils2();
      var drain = require_it_drain();
      var merge = require_it_merge();
      var { pipe } = require_it_pipe2();
      var { DHTContentRouting } = require_dht_content_routing();
      var ContentRouting = class {
        constructor(libp2p) {
          this.libp2p = libp2p;
          this.routers = libp2p._modules.contentRouting || [];
          this.dht = libp2p._dht;
          if (this.dht && libp2p._config.dht.enabled) {
            this.routers.push(new DHTContentRouting(this.dht));
          }
        }
        async *findProviders(key, options = {}) {
          if (!this.routers.length) {
            throw errCode(new Error("No content this.routers available"), "NO_ROUTERS_AVAILABLE");
          }
          yield* pipe(merge(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.libp2p.peerStore), (source) => uniquePeers(source), (source) => maybeLimitSource(source, options.maxNumProviders), (source) => requirePeers(source));
        }
        async provide(key) {
          if (!this.routers.length) {
            throw errCode(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE");
          }
          await Promise.all(this.routers.map((router) => router.provide(key)));
        }
        async put(key, value, options) {
          if (!this.libp2p.isStarted() || !this.dht.isStarted) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
          }
          await drain(this.dht.put(key, value, options));
        }
        async get(key, options) {
          if (!this.libp2p.isStarted() || !this.dht.isStarted) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
          }
          for await (const event of this.dht.get(key, options)) {
            if (event.name === "VALUE") {
              return { from: event.peerId, val: event.value };
            }
          }
          throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
        }
        async *getMany(key, nVals, options) {
          if (!this.libp2p.isStarted() || !this.dht.isStarted) {
            throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
          }
          if (!nVals) {
            return;
          }
          let gotValues = 0;
          for await (const event of this.dht.get(key, options)) {
            if (event.name === "VALUE") {
              yield { from: event.peerId, val: event.value };
              gotValues++;
              if (gotValues === nVals) {
                break;
              }
            }
          }
          if (gotValues === 0) {
            throw errCode(new Error(messages.NOT_FOUND), codes.ERR_NOT_FOUND);
          }
        }
      };
      module2.exports = ContentRouting;
    }
  });

  // node_modules/libp2p/src/get-peer.js
  var require_get_peer = __commonJS({
    "node_modules/libp2p/src/get-peer.js"(exports2, module2) {
      "use strict";
      var PeerId2 = require_src8();
      var { Multiaddr: Multiaddr2 } = require_src();
      var errCode = require_err_code();
      var { codes } = require_errors2();
      function getPeer(peer) {
        if (typeof peer === "string") {
          peer = new Multiaddr2(peer);
        }
        let addr;
        if (Multiaddr2.isMultiaddr(peer)) {
          addr = peer;
          const idStr = peer.getPeerId();
          if (!idStr) {
            throw errCode(new Error(`${peer} does not have a valid peer type`), codes.ERR_INVALID_MULTIADDR);
          }
          try {
            peer = PeerId2.createFromB58String(idStr);
          } catch (err) {
            throw errCode(new Error(`${peer} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
          }
        }
        return {
          id: peer,
          multiaddrs: addr ? [addr] : void 0
        };
      }
      module2.exports = getPeer;
    }
  });

  // node_modules/is-plain-obj/index.js
  var require_is_plain_obj = __commonJS({
    "node_modules/is-plain-obj/index.js"(exports2, module2) {
      "use strict";
      module2.exports = (value) => {
        if (Object.prototype.toString.call(value) !== "[object Object]") {
          return false;
        }
        const prototype = Object.getPrototypeOf(value);
        return prototype === null || prototype === Object.prototype;
      };
    }
  });

  // node_modules/merge-options/index.js
  var require_merge_options = __commonJS({
    "node_modules/merge-options/index.js"(exports2, module2) {
      "use strict";
      var isOptionObject = require_is_plain_obj();
      var { hasOwnProperty } = Object.prototype;
      var { propertyIsEnumerable } = Object;
      var defineProperty = (object, name, value) => Object.defineProperty(object, name, {
        value,
        writable: true,
        enumerable: true,
        configurable: true
      });
      var globalThis2 = exports2;
      var defaultMergeOptions = {
        concatArrays: false,
        ignoreUndefined: false
      };
      var getEnumerableOwnPropertyKeys = (value) => {
        const keys = [];
        for (const key in value) {
          if (hasOwnProperty.call(value, key)) {
            keys.push(key);
          }
        }
        if (Object.getOwnPropertySymbols) {
          const symbols = Object.getOwnPropertySymbols(value);
          for (const symbol of symbols) {
            if (propertyIsEnumerable.call(value, symbol)) {
              keys.push(symbol);
            }
          }
        }
        return keys;
      };
      function clone(value) {
        if (Array.isArray(value)) {
          return cloneArray(value);
        }
        if (isOptionObject(value)) {
          return cloneOptionObject(value);
        }
        return value;
      }
      function cloneArray(array) {
        const result = array.slice(0, 0);
        getEnumerableOwnPropertyKeys(array).forEach((key) => {
          defineProperty(result, key, clone(array[key]));
        });
        return result;
      }
      function cloneOptionObject(object) {
        const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
        getEnumerableOwnPropertyKeys(object).forEach((key) => {
          defineProperty(result, key, clone(object[key]));
        });
        return result;
      }
      var mergeKeys = (merged, source, keys, config) => {
        keys.forEach((key) => {
          if (typeof source[key] === "undefined" && config.ignoreUndefined) {
            return;
          }
          if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
            defineProperty(merged, key, merge(merged[key], source[key], config));
          } else {
            defineProperty(merged, key, clone(source[key]));
          }
        });
        return merged;
      };
      var concatArrays = (merged, source, config) => {
        let result = merged.slice(0, 0);
        let resultIndex = 0;
        [merged, source].forEach((array) => {
          const indices = [];
          for (let k = 0; k < array.length; k++) {
            if (!hasOwnProperty.call(array, k)) {
              continue;
            }
            indices.push(String(k));
            if (array === merged) {
              defineProperty(result, resultIndex++, array[k]);
            } else {
              defineProperty(result, resultIndex++, clone(array[k]));
            }
          }
          result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
        });
        return result;
      };
      function merge(merged, source, config) {
        if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
          return concatArrays(merged, source, config);
        }
        if (!isOptionObject(source) || !isOptionObject(merged)) {
          return clone(source);
        }
        return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
      }
      module2.exports = function(...options) {
        const config = merge(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
        let merged = { _: {} };
        for (const option of options) {
          if (option === void 0) {
            continue;
          }
          if (!isOptionObject(option)) {
            throw new TypeError("`" + option + "` is not an Option Object");
          }
          merged = merge(merged, { _: option }, config);
        }
        return merged._;
      };
    }
  });

  // node_modules/receptacle/node_modules/ms/index.js
  var require_ms2 = __commonJS({
    "node_modules/receptacle/node_modules/ms/index.js"(exports2, module2) {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module2.exports = function(val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return void 0;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    }
  });

  // node_modules/receptacle/index.js
  var require_receptacle = __commonJS({
    "node_modules/receptacle/index.js"(exports2, module2) {
      "use strict";
      module2.exports = Receptacle;
      var toMS = require_ms2();
      var cache = Receptacle.prototype;
      var counter = new Date() % 1e9;
      function getUID() {
        return (Math.random() * 1e9 >>> 0) + counter++;
      }
      function Receptacle(options) {
        options = options || {};
        this.id = options.id || getUID();
        this.max = options.max || Infinity;
        this.items = options.items || [];
        this._lookup = {};
        this.size = this.items.length;
        this.lastModified = new Date(options.lastModified || new Date());
        for (var item, ttl, i = this.items.length; i--; ) {
          item = this.items[i];
          ttl = new Date(item.expires) - new Date();
          this._lookup[item.key] = item;
          if (ttl > 0)
            this.expire(item.key, ttl);
          else if (ttl <= 0)
            this.delete(item.key);
        }
      }
      cache.has = function(key) {
        return key in this._lookup;
      };
      cache.get = function(key) {
        if (!this.has(key))
          return null;
        var record = this._lookup[key];
        if (record.refresh)
          this.expire(key, record.refresh);
        this.items.splice(this.items.indexOf(record), 1);
        this.items.push(record);
        return record.value;
      };
      cache.meta = function(key) {
        if (!this.has(key))
          return null;
        var record = this._lookup[key];
        if (!("meta" in record))
          return null;
        return record.meta;
      };
      cache.set = function(key, value, options) {
        var oldRecord = this._lookup[key];
        var record = this._lookup[key] = { key, value };
        this.lastModified = new Date();
        if (oldRecord) {
          clearTimeout(oldRecord.timeout);
          this.items.splice(this.items.indexOf(oldRecord), 1, record);
        } else {
          if (this.size >= this.max)
            this.delete(this.items[0].key);
          this.items.push(record);
          this.size++;
        }
        if (options) {
          if ("ttl" in options)
            this.expire(key, options.ttl);
          if ("meta" in options)
            record.meta = options.meta;
          if (options.refresh)
            record.refresh = options.ttl;
        }
        return this;
      };
      cache.delete = function(key) {
        var record = this._lookup[key];
        if (!record)
          return false;
        this.lastModified = new Date();
        this.items.splice(this.items.indexOf(record), 1);
        clearTimeout(record.timeout);
        delete this._lookup[key];
        this.size--;
        return this;
      };
      cache.expire = function(key, ttl) {
        var ms = ttl || 0;
        var record = this._lookup[key];
        if (!record)
          return this;
        if (typeof ms === "string")
          ms = toMS(ttl);
        if (typeof ms !== "number")
          throw new TypeError("Expiration time must be a string or number.");
        clearTimeout(record.timeout);
        record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
        record.expires = Number(new Date()) + ms;
        return this;
      };
      cache.clear = function() {
        for (var i = this.items.length; i--; )
          this.delete(this.items[i].key);
        return this;
      };
      cache.toJSON = function() {
        var items = new Array(this.items.length);
        var item;
        for (var i = items.length; i--; ) {
          item = this.items[i];
          items[i] = {
            key: item.key,
            meta: item.meta,
            value: item.value,
            expires: item.expires,
            refresh: item.refresh
          };
        }
        return {
          id: this.id,
          max: isFinite(this.max) ? this.max : void 0,
          lastModified: this.lastModified,
          items
        };
      };
    }
  });

  // node_modules/node-fetch/browser.js
  var require_browser5 = __commonJS({
    "node_modules/node-fetch/browser.js"(exports2, module2) {
      "use strict";
      var getGlobal = function() {
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global2 !== "undefined") {
          return global2;
        }
        throw new Error("unable to locate global object");
      };
      var global2 = getGlobal();
      module2.exports = exports2 = global2.fetch;
      if (global2.fetch) {
        exports2.default = global2.fetch.bind(global2);
      }
      exports2.Headers = global2.Headers;
      exports2.Request = global2.Request;
      exports2.Response = global2.Response;
    }
  });

  // node_modules/native-fetch/src/index.js
  var require_src12 = __commonJS({
    "node_modules/native-fetch/src/index.js"(exports2, module2) {
      "use strict";
      if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
        module2.exports = {
          default: globalThis.fetch,
          Headers: globalThis.Headers,
          Request: globalThis.Request,
          Response: globalThis.Response
        };
      } else {
        module2.exports = {
          default: require_browser5().default,
          Headers: require_browser5().Headers,
          Request: require_browser5().Request,
          Response: require_browser5().Response
        };
      }
    }
  });

  // node_modules/dns-over-http-resolver/src/utils.js
  var require_utils3 = __commonJS({
    "node_modules/dns-over-http-resolver/src/utils.js"(exports2, module2) {
      "use strict";
      var { default: nativeFetch, Headers } = require_src12();
      function buildResource({ serverResolver, hostname, recordType }) {
        return `${serverResolver}?name=${hostname}&type=${recordType}`;
      }
      function fetch(resource) {
        return nativeFetch(resource, {
          headers: new Headers({
            accept: "application/dns-json"
          })
        });
      }
      function getCacheKey(hostname, recordType) {
        return `${recordType}_${hostname}`;
      }
      module2.exports = {
        buildResource,
        fetch,
        getCacheKey
      };
    }
  });

  // node_modules/dns-over-http-resolver/src/index.js
  var require_src13 = __commonJS({
    "node_modules/dns-over-http-resolver/src/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = debug("dns-over-http-resolver");
      log.error = debug("dns-over-http-resolver:error");
      var Receptacle = require_receptacle();
      var utils = require_utils3();
      var Resolver = class {
        constructor({ maxCache = 100 } = {}) {
          this._cache = new Receptacle({ max: maxCache });
          this._servers = [
            "https://cloudflare-dns.com/dns-query",
            "https://dns.google/resolve"
          ];
        }
        getServers() {
          return this._servers;
        }
        _getShuffledServers() {
          const newServers = [].concat(this._servers);
          for (let i = newServers.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * i);
            const temp = newServers[i];
            newServers[i] = newServers[j];
            newServers[j] = temp;
          }
          return newServers;
        }
        setServers(servers) {
          this._servers = servers;
        }
        resolve(hostname, rrType = "A") {
          switch (rrType) {
            case "A":
              return this.resolve4(hostname);
            case "AAAA":
              return this.resolve6(hostname);
            case "TXT":
              return this.resolveTxt(hostname);
            default:
              throw new Error(`${rrType} is not supported`);
          }
        }
        async resolve4(hostname) {
          const recordType = "A";
          const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
          if (cached) {
            return cached;
          }
          for (const server of this._getShuffledServers()) {
            try {
              const response = await utils.fetch(utils.buildResource({
                serverResolver: server,
                hostname,
                recordType
              }));
              const d = await response.json();
              const data = d.Answer.map((a) => a.data);
              const ttl = Math.min(d.Answer.map((a) => a.TTL));
              this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl });
              return data;
            } catch (err) {
              log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            }
          }
          throw new Error(`Could not resolve ${hostname} record ${recordType}`);
        }
        async resolve6(hostname) {
          const recordType = "AAAA";
          const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
          if (cached) {
            return cached;
          }
          for (const server of this._getShuffledServers()) {
            try {
              const response = await utils.fetch(utils.buildResource({
                serverResolver: server,
                hostname,
                recordType
              }));
              const d = await response.json();
              const data = d.Answer.map((a) => a.data);
              const ttl = Math.min(d.Answer.map((a) => a.TTL));
              this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl });
              return data;
            } catch (err) {
              log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            }
          }
          throw new Error(`Could not resolve ${hostname} record ${recordType}`);
        }
        async resolveTxt(hostname) {
          const recordType = "TXT";
          const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
          if (cached) {
            return cached;
          }
          for (const server of this._getShuffledServers()) {
            try {
              const response = await utils.fetch(utils.buildResource({
                serverResolver: server,
                hostname,
                recordType
              }));
              const d = await response.json();
              const data = d.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
              const ttl = Math.min(d.Answer.map((a) => a.TTL));
              this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl });
              return data;
            } catch (err) {
              log.error(`${server} could not resolve ${hostname} record ${recordType}`);
            }
          }
          throw new Error(`Could not resolve ${hostname} record ${recordType}`);
        }
      };
      Resolver.Resolver = Resolver;
      module2.exports = Resolver;
    }
  });

  // node_modules/multiaddr/src/resolvers/dns.browser.js
  var require_dns_browser = __commonJS({
    "node_modules/multiaddr/src/resolvers/dns.browser.js"(exports2, module2) {
      "use strict";
      var dns = require_src13();
      module2.exports = dns;
    }
  });

  // node_modules/multiaddr/src/resolvers/index.js
  var require_resolvers = __commonJS({
    "node_modules/multiaddr/src/resolvers/index.js"(exports2, module2) {
      "use strict";
      var protocols = require_protocols_table();
      var { code: dnsaddrCode } = protocols("dnsaddr");
      async function dnsaddrResolver(addr) {
        const Resolver = require_dns_browser();
        const resolver = new Resolver();
        const peerId = addr.getPeerId();
        const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) || [];
        const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
        let addresses = records.flat().map((a) => a.split("=")[1]);
        if (peerId) {
          addresses = addresses.filter((entry) => entry.includes(peerId));
        }
        return addresses;
      }
      module2.exports = {
        dnsaddrResolver
      };
    }
  });

  // node_modules/libp2p/src/constants.js
  var require_constants5 = __commonJS({
    "node_modules/libp2p/src/constants.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        DIAL_TIMEOUT: 3e4,
        MAX_PARALLEL_DIALS: 100,
        MAX_PER_PEER_DIALS: 4,
        MAX_ADDRS_TO_DIAL: 25,
        METRICS: {
          computeThrottleMaxQueueSize: 1e3,
          computeThrottleTimeout: 2e3,
          movingAverageIntervals: [
            60 * 1e3,
            5 * 60 * 1e3,
            15 * 60 * 1e3
          ],
          maxOldPeersRetention: 50
        }
      };
    }
  });

  // libp2p-package:../../package.json
  var require_package = __commonJS({
    "libp2p-package:../../package.json"(exports2, module2) {
      module2.exports = { name: "libp2p", version: "0.33.0" };
    }
  });

  // node_modules/libp2p/src/identify/consts.js
  var require_consts = __commonJS({
    "node_modules/libp2p/src/identify/consts.js"(exports2, module2) {
      "use strict";
      var libp2pVersion = require_package().version;
      module2.exports.PROTOCOL_VERSION = "ipfs/0.1.0";
      module2.exports.AGENT_VERSION = `js-libp2p/${libp2pVersion}`;
      module2.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
      module2.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
      module2.exports.IDENTIFY_PROTOCOL_VERSION = "0.1.0";
      module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
      module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
      module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
      module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
    }
  });

  // node_modules/libp2p/src/circuit/constants.js
  var require_constants6 = __commonJS({
    "node_modules/libp2p/src/circuit/constants.js"(exports2, module2) {
      "use strict";
      var minute = 60 * 1e3;
      module2.exports = {
        ADVERTISE_BOOT_DELAY: 15 * minute,
        ADVERTISE_TTL: 30 * minute,
        CIRCUIT_PROTO_CODE: 290,
        HOP_METADATA_KEY: "hop_relay",
        HOP_METADATA_VALUE: "true",
        RELAY_RENDEZVOUS_NS: "/libp2p/relay"
      };
    }
  });

  // node_modules/netmask/lib/netmask.js
  var require_netmask = __commonJS({
    "node_modules/netmask/lib/netmask.js"(exports2) {
      (function() {
        var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
        long2ip = function(long) {
          var a, b, c, d;
          a = (long & 255 << 24) >>> 24;
          b = (long & 255 << 16) >>> 16;
          c = (long & 255 << 8) >>> 8;
          d = long & 255;
          return [a, b, c, d].join(".");
        };
        ip2long = function(ip) {
          var b, c, i, j, n, ref;
          b = [];
          for (i = j = 0; j <= 3; i = ++j) {
            if (ip.length === 0) {
              break;
            }
            if (i > 0) {
              if (ip[0] !== ".") {
                throw new Error("Invalid IP");
              }
              ip = ip.substring(1);
            }
            ref = atob(ip), n = ref[0], c = ref[1];
            ip = ip.substring(c);
            b.push(n);
          }
          if (ip.length !== 0) {
            throw new Error("Invalid IP");
          }
          switch (b.length) {
            case 1:
              if (b[0] > 4294967295) {
                throw new Error("Invalid IP");
              }
              return b[0] >>> 0;
            case 2:
              if (b[0] > 255 || b[1] > 16777215) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1]) >>> 0;
            case 3:
              if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
            case 4:
              if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
                throw new Error("Invalid IP");
              }
              return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
            default:
              throw new Error("Invalid IP");
          }
        };
        chr = function(b) {
          return b.charCodeAt(0);
        };
        chr0 = chr("0");
        chra = chr("a");
        chrA = chr("A");
        atob = function(s) {
          var base3, dmax, i, n, start;
          n = 0;
          base3 = 10;
          dmax = "9";
          i = 0;
          if (s.length > 1 && s[i] === "0") {
            if (s[i + 1] === "x" || s[i + 1] === "X") {
              i += 2;
              base3 = 16;
            } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
              i++;
              base3 = 8;
              dmax = "7";
            }
          }
          start = i;
          while (i < s.length) {
            if ("0" <= s[i] && s[i] <= dmax) {
              n = n * base3 + (chr(s[i]) - chr0) >>> 0;
            } else if (base3 === 16) {
              if ("a" <= s[i] && s[i] <= "f") {
                n = n * base3 + (10 + chr(s[i]) - chra) >>> 0;
              } else if ("A" <= s[i] && s[i] <= "F") {
                n = n * base3 + (10 + chr(s[i]) - chrA) >>> 0;
              } else {
                break;
              }
            } else {
              break;
            }
            if (n > 4294967295) {
              throw new Error("too large");
            }
            i++;
          }
          if (i === start) {
            throw new Error("empty octet");
          }
          return [n, i];
        };
        Netmask = function() {
          function Netmask2(net, mask) {
            var error, i, j, ref;
            if (typeof net !== "string") {
              throw new Error("Missing `net' parameter");
            }
            if (!mask) {
              ref = net.split("/", 2), net = ref[0], mask = ref[1];
            }
            if (!mask) {
              mask = 32;
            }
            if (typeof mask === "string" && mask.indexOf(".") > -1) {
              try {
                this.maskLong = ip2long(mask);
              } catch (error1) {
                error = error1;
                throw new Error("Invalid mask: " + mask);
              }
              for (i = j = 32; j >= 0; i = --j) {
                if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                  this.bitmask = i;
                  break;
                }
              }
            } else if (mask || mask === 0) {
              this.bitmask = parseInt(mask, 10);
              this.maskLong = 0;
              if (this.bitmask > 0) {
                this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
              }
            } else {
              throw new Error("Invalid mask: empty");
            }
            try {
              this.netLong = (ip2long(net) & this.maskLong) >>> 0;
            } catch (error1) {
              error = error1;
              throw new Error("Invalid net address: " + net);
            }
            if (!(this.bitmask <= 32)) {
              throw new Error("Invalid mask for ip4: " + mask);
            }
            this.size = Math.pow(2, 32 - this.bitmask);
            this.base = long2ip(this.netLong);
            this.mask = long2ip(this.maskLong);
            this.hostmask = long2ip(~this.maskLong);
            this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
            this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
            this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
          }
          Netmask2.prototype.contains = function(ip) {
            if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
              ip = new Netmask2(ip);
            }
            if (ip instanceof Netmask2) {
              return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
            } else {
              return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
            }
          };
          Netmask2.prototype.next = function(count) {
            if (count == null) {
              count = 1;
            }
            return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
          };
          Netmask2.prototype.forEach = function(fn) {
            var index, lastLong, long;
            long = ip2long(this.first);
            lastLong = ip2long(this.last);
            index = 0;
            while (long <= lastLong) {
              fn(long2ip(long), long, index);
              index++;
              long++;
            }
          };
          Netmask2.prototype.toString = function() {
            return this.base + "/" + this.bitmask;
          };
          return Netmask2;
        }();
        exports2.ip2long = ip2long;
        exports2.long2ip = long2ip;
        exports2.Netmask = Netmask;
      }).call(exports2);
    }
  });

  // node_modules/ipaddr.js/lib/ipaddr.js
  var require_ipaddr = __commonJS({
    "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
      (function(root) {
        "use strict";
        const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
        const ipv4Regexes = {
          fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
          threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
          twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
          longValue: new RegExp(`^${ipv4Part}$`, "i")
        };
        const octalRegex = new RegExp(`^0[0-7]+$`, "i");
        const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
        const zoneIndex = "%[0-9a-z]{1,}";
        const ipv6Part = "(?:[0-9a-f]+::?)+";
        const ipv6Regexes = {
          zoneIndex: new RegExp(zoneIndex, "i"),
          "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
          deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
          transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
        };
        function expandIPv6(string2, parts) {
          if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
            return null;
          }
          let colonCount = 0;
          let lastColon = -1;
          let zoneId = (string2.match(ipv6Regexes.zoneIndex) || [])[0];
          let replacement, replacementCount;
          if (zoneId) {
            zoneId = zoneId.substring(1);
            string2 = string2.replace(/%.+$/, "");
          }
          while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
            colonCount++;
          }
          if (string2.substr(0, 2) === "::") {
            colonCount--;
          }
          if (string2.substr(-2, 2) === "::") {
            colonCount--;
          }
          if (colonCount > parts) {
            return null;
          }
          replacementCount = parts - colonCount;
          replacement = ":";
          while (replacementCount--) {
            replacement += "0:";
          }
          string2 = string2.replace("::", replacement);
          if (string2[0] === ":") {
            string2 = string2.slice(1);
          }
          if (string2[string2.length - 1] === ":") {
            string2 = string2.slice(0, -1);
          }
          parts = function() {
            const ref = string2.split(":");
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              results.push(parseInt(ref[i], 16));
            }
            return results;
          }();
          return {
            parts,
            zoneId
          };
        }
        function matchCIDR(first, second, partSize, cidrBits) {
          if (first.length !== second.length) {
            throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
          }
          let part = 0;
          let shift;
          while (cidrBits > 0) {
            shift = partSize - cidrBits;
            if (shift < 0) {
              shift = 0;
            }
            if (first[part] >> shift !== second[part] >> shift) {
              return false;
            }
            cidrBits -= partSize;
            part += 1;
          }
          return true;
        }
        function parseIntAuto(string2) {
          if (hexRegex.test(string2)) {
            return parseInt(string2, 16);
          }
          if (string2[0] === "0" && !isNaN(parseInt(string2[1], 10))) {
            if (octalRegex.test(string2)) {
              return parseInt(string2, 8);
            }
            throw new Error(`ipaddr: cannot parse ${string2} as octal`);
          }
          return parseInt(string2, 10);
        }
        function padPart(part, length2) {
          while (part.length < length2) {
            part = `0${part}`;
          }
          return part;
        }
        const ipaddr = {};
        ipaddr.IPv4 = function() {
          function IPv4(octets) {
            if (octets.length !== 4) {
              throw new Error("ipaddr: ipv4 octet count should be 4");
            }
            let i, octet;
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
              }
            }
            this.octets = octets;
          }
          IPv4.prototype.SpecialRanges = {
            unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
            broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
            multicast: [[new IPv4([224, 0, 0, 0]), 4]],
            linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
            loopback: [[new IPv4([127, 0, 0, 0]), 8]],
            carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
            "private": [
              [new IPv4([10, 0, 0, 0]), 8],
              [new IPv4([172, 16, 0, 0]), 12],
              [new IPv4([192, 168, 0, 0]), 16]
            ],
            reserved: [
              [new IPv4([192, 0, 0, 0]), 24],
              [new IPv4([192, 0, 2, 0]), 24],
              [new IPv4([192, 88, 99, 0]), 24],
              [new IPv4([198, 51, 100, 0]), 24],
              [new IPv4([203, 0, 113, 0]), 24],
              [new IPv4([240, 0, 0, 0]), 4]
            ]
          };
          IPv4.prototype.kind = function() {
            return "ipv4";
          };
          IPv4.prototype.match = function(other, cidrRange) {
            let ref;
            if (cidrRange === void 0) {
              ref = other;
              other = ref[0];
              cidrRange = ref[1];
            }
            if (other.kind() !== "ipv4") {
              throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
            }
            return matchCIDR(this.octets, other.octets, 8, cidrRange);
          };
          IPv4.prototype.prefixLengthFromSubnetMask = function() {
            let cidr = 0;
            let stop = false;
            const zerotable = {
              0: 8,
              128: 7,
              192: 6,
              224: 5,
              240: 4,
              248: 3,
              252: 2,
              254: 1,
              255: 0
            };
            let i, octet, zeros;
            for (i = 3; i >= 0; i -= 1) {
              octet = this.octets[i];
              if (octet in zerotable) {
                zeros = zerotable[octet];
                if (stop && zeros !== 0) {
                  return null;
                }
                if (zeros !== 8) {
                  stop = true;
                }
                cidr += zeros;
              } else {
                return null;
              }
            }
            return 32 - cidr;
          };
          IPv4.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
          };
          IPv4.prototype.toByteArray = function() {
            return this.octets.slice(0);
          };
          IPv4.prototype.toIPv4MappedAddress = function() {
            return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
          };
          IPv4.prototype.toNormalizedString = function() {
            return this.toString();
          };
          IPv4.prototype.toString = function() {
            return this.octets.join(".");
          };
          return IPv4;
        }();
        ipaddr.IPv4.broadcastAddressFromCIDR = function(string2) {
          try {
            const cidr = this.parseCIDR(string2);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while (i < 4) {
              octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
              i++;
            }
            return new this(octets);
          } catch (e) {
            throw new Error("ipaddr: the address does not have IPv4 CIDR format");
          }
        };
        ipaddr.IPv4.isIPv4 = function(string2) {
          return this.parser(string2) !== null;
        };
        ipaddr.IPv4.isValid = function(string2) {
          try {
            new this(this.parser(string2));
            return true;
          } catch (e) {
            return false;
          }
        };
        ipaddr.IPv4.isValidFourPartDecimal = function(string2) {
          if (ipaddr.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
            return true;
          } else {
            return false;
          }
        };
        ipaddr.IPv4.networkAddressFromCIDR = function(string2) {
          let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
          try {
            cidr = this.parseCIDR(string2);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while (i < 4) {
              octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
              i++;
            }
            return new this(octets);
          } catch (e) {
            throw new Error("ipaddr: the address does not have IPv4 CIDR format");
          }
        };
        ipaddr.IPv4.parse = function(string2) {
          const parts = this.parser(string2);
          if (parts === null) {
            throw new Error("ipaddr: string is not formatted like an IPv4 Address");
          }
          return new this(parts);
        };
        ipaddr.IPv4.parseCIDR = function(string2) {
          let match;
          if (match = string2.match(/^(.+)\/(\d+)$/)) {
            const maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 32) {
              const parsed = [this.parse(match[1]), maskLength];
              Object.defineProperty(parsed, "toString", {
                value: function() {
                  return this.join("/");
                }
              });
              return parsed;
            }
          }
          throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
        };
        ipaddr.IPv4.parser = function(string2) {
          let match, part, value;
          if (match = string2.match(ipv4Regexes.fourOctet)) {
            return function() {
              const ref = match.slice(1, 6);
              const results = [];
              for (let i = 0; i < ref.length; i++) {
                part = ref[i];
                results.push(parseIntAuto(part));
              }
              return results;
            }();
          } else if (match = string2.match(ipv4Regexes.longValue)) {
            value = parseIntAuto(match[1]);
            if (value > 4294967295 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            return function() {
              const results = [];
              let shift;
              for (shift = 0; shift <= 24; shift += 8) {
                results.push(value >> shift & 255);
              }
              return results;
            }().reverse();
          } else if (match = string2.match(ipv4Regexes.twoOctet)) {
            return function() {
              const ref = match.slice(1, 4);
              const results = [];
              value = parseIntAuto(ref[1]);
              if (value > 16777215 || value < 0) {
                throw new Error("ipaddr: address outside defined range");
              }
              results.push(parseIntAuto(ref[0]));
              results.push(value >> 16 & 255);
              results.push(value >> 8 & 255);
              results.push(value & 255);
              return results;
            }();
          } else if (match = string2.match(ipv4Regexes.threeOctet)) {
            return function() {
              const ref = match.slice(1, 5);
              const results = [];
              value = parseIntAuto(ref[2]);
              if (value > 65535 || value < 0) {
                throw new Error("ipaddr: address outside defined range");
              }
              results.push(parseIntAuto(ref[0]));
              results.push(parseIntAuto(ref[1]));
              results.push(value >> 8 & 255);
              results.push(value & 255);
              return results;
            }();
          } else {
            return null;
          }
        };
        ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
          prefix = parseInt(prefix);
          if (prefix < 0 || prefix > 32) {
            throw new Error("ipaddr: invalid IPv4 prefix length");
          }
          const octets = [0, 0, 0, 0];
          let j = 0;
          const filledOctetCount = Math.floor(prefix / 8);
          while (j < filledOctetCount) {
            octets[j] = 255;
            j++;
          }
          if (filledOctetCount < 4) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
          }
          return new this(octets);
        };
        ipaddr.IPv6 = function() {
          function IPv6(parts, zoneId) {
            let i, part;
            if (parts.length === 16) {
              this.parts = [];
              for (i = 0; i <= 14; i += 2) {
                this.parts.push(parts[i] << 8 | parts[i + 1]);
              }
            } else if (parts.length === 8) {
              this.parts = parts;
            } else {
              throw new Error("ipaddr: ipv6 part count should be 8 or 16");
            }
            for (i = 0; i < this.parts.length; i++) {
              part = this.parts[i];
              if (!(0 <= part && part <= 65535)) {
                throw new Error("ipaddr: ipv6 part should fit in 16 bits");
              }
            }
            if (zoneId) {
              this.zoneId = zoneId;
            }
          }
          IPv6.prototype.SpecialRanges = {
            unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
            linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
            multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
            loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
            uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
            ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
            rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
            rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
            "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
            teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
            reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
          };
          IPv6.prototype.isIPv4MappedAddress = function() {
            return this.range() === "ipv4Mapped";
          };
          IPv6.prototype.kind = function() {
            return "ipv6";
          };
          IPv6.prototype.match = function(other, cidrRange) {
            let ref;
            if (cidrRange === void 0) {
              ref = other;
              other = ref[0];
              cidrRange = ref[1];
            }
            if (other.kind() !== "ipv6") {
              throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
            }
            return matchCIDR(this.parts, other.parts, 16, cidrRange);
          };
          IPv6.prototype.prefixLengthFromSubnetMask = function() {
            let cidr = 0;
            let stop = false;
            const zerotable = {
              0: 16,
              32768: 15,
              49152: 14,
              57344: 13,
              61440: 12,
              63488: 11,
              64512: 10,
              65024: 9,
              65280: 8,
              65408: 7,
              65472: 6,
              65504: 5,
              65520: 4,
              65528: 3,
              65532: 2,
              65534: 1,
              65535: 0
            };
            let part, zeros;
            for (let i = 7; i >= 0; i -= 1) {
              part = this.parts[i];
              if (part in zerotable) {
                zeros = zerotable[part];
                if (stop && zeros !== 0) {
                  return null;
                }
                if (zeros !== 16) {
                  stop = true;
                }
                cidr += zeros;
              } else {
                return null;
              }
            }
            return 128 - cidr;
          };
          IPv6.prototype.range = function() {
            return ipaddr.subnetMatch(this, this.SpecialRanges);
          };
          IPv6.prototype.toByteArray = function() {
            let part;
            const bytes = [];
            const ref = this.parts;
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              bytes.push(part >> 8);
              bytes.push(part & 255);
            }
            return bytes;
          };
          IPv6.prototype.toFixedLengthString = function() {
            const addr = function() {
              const results = [];
              for (let i = 0; i < this.parts.length; i++) {
                results.push(padPart(this.parts[i].toString(16), 4));
              }
              return results;
            }.call(this).join(":");
            let suffix = "";
            if (this.zoneId) {
              suffix = `%${this.zoneId}`;
            }
            return addr + suffix;
          };
          IPv6.prototype.toIPv4Address = function() {
            if (!this.isIPv4MappedAddress()) {
              throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
            }
            const ref = this.parts.slice(-2);
            const high = ref[0];
            const low = ref[1];
            return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
          };
          IPv6.prototype.toNormalizedString = function() {
            const addr = function() {
              const results = [];
              for (let i = 0; i < this.parts.length; i++) {
                results.push(this.parts[i].toString(16));
              }
              return results;
            }.call(this).join(":");
            let suffix = "";
            if (this.zoneId) {
              suffix = `%${this.zoneId}`;
            }
            return addr + suffix;
          };
          IPv6.prototype.toRFC5952String = function() {
            const regex = /((^|:)(0(:|$)){2,})/g;
            const string2 = this.toNormalizedString();
            let bestMatchIndex = 0;
            let bestMatchLength = -1;
            let match;
            while (match = regex.exec(string2)) {
              if (match[0].length > bestMatchLength) {
                bestMatchIndex = match.index;
                bestMatchLength = match[0].length;
              }
            }
            if (bestMatchLength < 0) {
              return string2;
            }
            return `${string2.substring(0, bestMatchIndex)}::${string2.substring(bestMatchIndex + bestMatchLength)}`;
          };
          IPv6.prototype.toString = function() {
            return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
          };
          return IPv6;
        }();
        ipaddr.IPv6.broadcastAddressFromCIDR = function(string2) {
          try {
            const cidr = this.parseCIDR(string2);
            const ipInterfaceOctets = cidr[0].toByteArray();
            const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            const octets = [];
            let i = 0;
            while (i < 16) {
              octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
              i++;
            }
            return new this(octets);
          } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
          }
        };
        ipaddr.IPv6.isIPv6 = function(string2) {
          return this.parser(string2) !== null;
        };
        ipaddr.IPv6.isValid = function(string2) {
          if (typeof string2 === "string" && string2.indexOf(":") === -1) {
            return false;
          }
          try {
            const addr = this.parser(string2);
            new this(addr.parts, addr.zoneId);
            return true;
          } catch (e) {
            return false;
          }
        };
        ipaddr.IPv6.networkAddressFromCIDR = function(string2) {
          let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
          try {
            cidr = this.parseCIDR(string2);
            ipInterfaceOctets = cidr[0].toByteArray();
            subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
            octets = [];
            i = 0;
            while (i < 16) {
              octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
              i++;
            }
            return new this(octets);
          } catch (e) {
            throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
          }
        };
        ipaddr.IPv6.parse = function(string2) {
          const addr = this.parser(string2);
          if (addr.parts === null) {
            throw new Error("ipaddr: string is not formatted like an IPv6 Address");
          }
          return new this(addr.parts, addr.zoneId);
        };
        ipaddr.IPv6.parseCIDR = function(string2) {
          let maskLength, match, parsed;
          if (match = string2.match(/^(.+)\/(\d+)$/)) {
            maskLength = parseInt(match[2]);
            if (maskLength >= 0 && maskLength <= 128) {
              parsed = [this.parse(match[1]), maskLength];
              Object.defineProperty(parsed, "toString", {
                value: function() {
                  return this.join("/");
                }
              });
              return parsed;
            }
          }
          throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
        };
        ipaddr.IPv6.parser = function(string2) {
          let addr, i, match, octet, octets, zoneId;
          if (match = string2.match(ipv6Regexes.deprecatedTransitional)) {
            return this.parser(`::ffff:${match[1]}`);
          }
          if (ipv6Regexes.native.test(string2)) {
            return expandIPv6(string2, 8);
          }
          if (match = string2.match(ipv6Regexes.transitional)) {
            zoneId = match[6] || "";
            addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
            if (addr.parts) {
              octets = [
                parseInt(match[2]),
                parseInt(match[3]),
                parseInt(match[4]),
                parseInt(match[5])
              ];
              for (i = 0; i < octets.length; i++) {
                octet = octets[i];
                if (!(0 <= octet && octet <= 255)) {
                  return null;
                }
              }
              addr.parts.push(octets[0] << 8 | octets[1]);
              addr.parts.push(octets[2] << 8 | octets[3]);
              return {
                parts: addr.parts,
                zoneId: addr.zoneId
              };
            }
          }
          return null;
        };
        ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
          prefix = parseInt(prefix);
          if (prefix < 0 || prefix > 128) {
            throw new Error("ipaddr: invalid IPv6 prefix length");
          }
          const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          let j = 0;
          const filledOctetCount = Math.floor(prefix / 8);
          while (j < filledOctetCount) {
            octets[j] = 255;
            j++;
          }
          if (filledOctetCount < 16) {
            octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
          }
          return new this(octets);
        };
        ipaddr.fromByteArray = function(bytes) {
          const length2 = bytes.length;
          if (length2 === 4) {
            return new ipaddr.IPv4(bytes);
          } else if (length2 === 16) {
            return new ipaddr.IPv6(bytes);
          } else {
            throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
          }
        };
        ipaddr.isValid = function(string2) {
          return ipaddr.IPv6.isValid(string2) || ipaddr.IPv4.isValid(string2);
        };
        ipaddr.parse = function(string2) {
          if (ipaddr.IPv6.isValid(string2)) {
            return ipaddr.IPv6.parse(string2);
          } else if (ipaddr.IPv4.isValid(string2)) {
            return ipaddr.IPv4.parse(string2);
          } else {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
          }
        };
        ipaddr.parseCIDR = function(string2) {
          try {
            return ipaddr.IPv6.parseCIDR(string2);
          } catch (e) {
            try {
              return ipaddr.IPv4.parseCIDR(string2);
            } catch (e2) {
              throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
            }
          }
        };
        ipaddr.process = function(string2) {
          const addr = this.parse(string2);
          if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
            return addr.toIPv4Address();
          } else {
            return addr;
          }
        };
        ipaddr.subnetMatch = function(address, rangeList, defaultName) {
          let i, rangeName, rangeSubnets, subnet;
          if (defaultName === void 0 || defaultName === null) {
            defaultName = "unicast";
          }
          for (rangeName in rangeList) {
            if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
              rangeSubnets = rangeList[rangeName];
              if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
                rangeSubnets = [rangeSubnets];
              }
              for (i = 0; i < rangeSubnets.length; i++) {
                subnet = rangeSubnets[i];
                if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                  return rangeName;
                }
              }
            }
          }
          return defaultName;
        };
        if (typeof module2 !== "undefined" && module2.exports) {
          module2.exports = ipaddr;
        } else {
          root.ipaddr = ipaddr;
        }
      })(exports2);
    }
  });

  // node_modules/private-ip/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/private-ip/lib/index.js"(exports2) {
      "use strict";
      var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
        return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
      };
      Object.defineProperty(exports2, "__esModule", { value: true });
      var netmask_1 = require_netmask();
      var ip_regex_1 = __importDefault(require_ip_regex());
      var is_ip_1 = __importDefault(require_is_ip());
      var ipaddr_js_1 = require_ipaddr();
      var PRIVATE_IP_RANGES = [
        "0.0.0.0/8",
        "10.0.0.0/8",
        "100.64.0.0/10",
        "127.0.0.0/8",
        "169.254.0.0/16",
        "172.16.0.0/12",
        "192.0.0.0/24",
        "192.0.0.0/29",
        "192.0.0.8/32",
        "192.0.0.9/32",
        "192.0.0.10/32",
        "192.0.0.170/32",
        "192.0.0.171/32",
        "192.0.2.0/24",
        "192.31.196.0/24",
        "192.52.193.0/24",
        "192.88.99.0/24",
        "192.168.0.0/16",
        "192.175.48.0/24",
        "198.18.0.0/15",
        "198.51.100.0/24",
        "203.0.113.0/24",
        "240.0.0.0/4",
        "255.255.255.255/32"
      ];
      var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
      function ipv4_check(ip_addr) {
        for (let r of NETMASK_RANGES) {
          if (r.contains(ip_addr))
            return true;
        }
        return false;
      }
      function ipv6_check(ip_addr) {
        return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
      }
      exports2.default = (ip) => {
        if (ipaddr_js_1.isValid(ip)) {
          const parsed = ipaddr_js_1.parse(ip);
          if (parsed.kind() === "ipv4")
            return ipv4_check(parsed.toNormalizedString());
          else if (parsed.kind() === "ipv6")
            return ipv6_check(ip);
        } else if (is_ip_1.default(ip) && ip_regex_1.default.v6().test(ip))
          return ipv6_check(ip);
        return void 0;
      };
    }
  });

  // node_modules/private-ip/index.js
  var require_private_ip = __commonJS({
    "node_modules/private-ip/index.js"(exports2, module2) {
      "use strict";
      module2.exports = require_lib2().default;
    }
  });

  // node_modules/libp2p-utils/src/multiaddr/is-private.js
  var require_is_private = __commonJS({
    "node_modules/libp2p-utils/src/multiaddr/is-private.js"(exports2, module2) {
      "use strict";
      var isIpPrivate = require_private_ip();
      function isPrivate(ma) {
        const { address } = ma.nodeAddress();
        return isIpPrivate(address);
      }
      module2.exports = isPrivate;
    }
  });

  // node_modules/libp2p-utils/src/address-sort.js
  var require_address_sort = __commonJS({
    "node_modules/libp2p-utils/src/address-sort.js"(exports2, module2) {
      "use strict";
      var isPrivate = require_is_private();
      function addressesPublicFirstCompareFunction(a, b) {
        const isAPrivate = isPrivate(a.multiaddr);
        const isBPrivate = isPrivate(b.multiaddr);
        if (isAPrivate && !isBPrivate) {
          return 1;
        } else if (!isAPrivate && isBPrivate) {
          return -1;
        }
        if (a.isCertified && !b.isCertified) {
          return -1;
        } else if (!a.isCertified && b.isCertified) {
          return 1;
        }
        return 0;
      }
      function publicAddressesFirst(addresses) {
        return [...addresses].sort(addressesPublicFirstCompareFunction);
      }
      module2.exports.publicAddressesFirst = publicAddressesFirst;
    }
  });

  // node_modules/p-reflect/index.js
  var require_p_reflect = __commonJS({
    "node_modules/p-reflect/index.js"(exports2, module2) {
      "use strict";
      var pReflect = async (promise) => {
        try {
          const value = await promise;
          return {
            isFulfilled: true,
            isRejected: false,
            value
          };
        } catch (error) {
          return {
            isFulfilled: false,
            isRejected: true,
            reason: error
          };
        }
      };
      module2.exports = pReflect;
      module2.exports.default = pReflect;
    }
  });

  // node_modules/p-try/index.js
  var require_p_try = __commonJS({
    "node_modules/p-try/index.js"(exports2, module2) {
      "use strict";
      var pTry = (fn, ...arguments_) => new Promise((resolve) => {
        resolve(fn(...arguments_));
      });
      module2.exports = pTry;
      module2.exports.default = pTry;
    }
  });

  // node_modules/p-limit/index.js
  var require_p_limit = __commonJS({
    "node_modules/p-limit/index.js"(exports2, module2) {
      "use strict";
      var pTry = require_p_try();
      var pLimit = (concurrency) => {
        if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
          return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
        }
        const queue = [];
        let activeCount = 0;
        const next = () => {
          activeCount--;
          if (queue.length > 0) {
            queue.shift()();
          }
        };
        const run = (fn, resolve, ...args) => {
          activeCount++;
          const result = pTry(fn, ...args);
          resolve(result);
          result.then(next, next);
        };
        const enqueue = (fn, resolve, ...args) => {
          if (activeCount < concurrency) {
            run(fn, resolve, ...args);
          } else {
            queue.push(run.bind(null, fn, resolve, ...args));
          }
        };
        const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
        Object.defineProperties(generator, {
          activeCount: {
            get: () => activeCount
          },
          pendingCount: {
            get: () => queue.length
          },
          clearQueue: {
            value: () => {
              queue.length = 0;
            }
          }
        });
        return generator;
      };
      module2.exports = pLimit;
      module2.exports.default = pLimit;
    }
  });

  // node_modules/p-settle/index.js
  var require_p_settle = __commonJS({
    "node_modules/p-settle/index.js"(exports2, module2) {
      "use strict";
      var pReflect = require_p_reflect();
      var pLimit = require_p_limit();
      module2.exports = async (array, options = {}) => {
        const { concurrency = Infinity } = options;
        const limit = pLimit(concurrency);
        return Promise.all(array.map((element) => {
          if (element && typeof element.then === "function") {
            return pReflect(element);
          }
          if (typeof element === "function") {
            return pReflect(limit(() => element()));
          }
          return pReflect(Promise.resolve(element));
        }));
      };
    }
  });

  // node_modules/libp2p/src/record/envelope/envelope.js
  var require_envelope = __commonJS({
    "node_modules/libp2p/src/record/envelope/envelope.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-envelope"] || ($protobuf.roots["libp2p-envelope"] = {});
      $root.Envelope = function() {
        function Envelope(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Envelope.prototype.publicKey = $util.newBuffer([]);
        Envelope.prototype.payloadType = $util.newBuffer([]);
        Envelope.prototype.payload = $util.newBuffer([]);
        Envelope.prototype.signature = $util.newBuffer([]);
        Envelope.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
            w.uint32(10).bytes(m.publicKey);
          if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
            w.uint32(18).bytes(m.payloadType);
          if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
            w.uint32(26).bytes(m.payload);
          if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
            w.uint32(42).bytes(m.signature);
          return w;
        };
        Envelope.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.Envelope();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.publicKey = r.bytes();
                break;
              case 2:
                m.payloadType = r.bytes();
                break;
              case 3:
                m.payload = r.bytes();
                break;
              case 5:
                m.signature = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Envelope.fromObject = function fromObject(d) {
          if (d instanceof $root.Envelope)
            return d;
          var m = new $root.Envelope();
          if (d.publicKey != null) {
            if (typeof d.publicKey === "string")
              $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);
            else if (d.publicKey.length)
              m.publicKey = d.publicKey;
          }
          if (d.payloadType != null) {
            if (typeof d.payloadType === "string")
              $util.base64.decode(d.payloadType, m.payloadType = $util.newBuffer($util.base64.length(d.payloadType)), 0);
            else if (d.payloadType.length)
              m.payloadType = d.payloadType;
          }
          if (d.payload != null) {
            if (typeof d.payload === "string")
              $util.base64.decode(d.payload, m.payload = $util.newBuffer($util.base64.length(d.payload)), 0);
            else if (d.payload.length)
              m.payload = d.payload;
          }
          if (d.signature != null) {
            if (typeof d.signature === "string")
              $util.base64.decode(d.signature, m.signature = $util.newBuffer($util.base64.length(d.signature)), 0);
            else if (d.signature.length)
              m.signature = d.signature;
          }
          return m;
        };
        Envelope.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.publicKey = "";
            else {
              d.publicKey = [];
              if (o.bytes !== Array)
                d.publicKey = $util.newBuffer(d.publicKey);
            }
            if (o.bytes === String)
              d.payloadType = "";
            else {
              d.payloadType = [];
              if (o.bytes !== Array)
                d.payloadType = $util.newBuffer(d.payloadType);
            }
            if (o.bytes === String)
              d.payload = "";
            else {
              d.payload = [];
              if (o.bytes !== Array)
                d.payload = $util.newBuffer(d.payload);
            }
            if (o.bytes === String)
              d.signature = "";
            else {
              d.signature = [];
              if (o.bytes !== Array)
                d.signature = $util.newBuffer(d.signature);
            }
          }
          if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
            d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
          }
          if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
            d.payloadType = o.bytes === String ? $util.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
          }
          if (m.payload != null && m.hasOwnProperty("payload")) {
            d.payload = o.bytes === String ? $util.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
          }
          if (m.signature != null && m.hasOwnProperty("signature")) {
            d.signature = o.bytes === String ? $util.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
          }
          return d;
        };
        Envelope.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Envelope;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p/src/record/envelope/index.js
  var require_envelope2 = __commonJS({
    "node_modules/libp2p/src/record/envelope/index.js"(exports2, module2) {
      "use strict";
      var errCode = require_err_code();
      var { concat: uint8arraysConcat } = (init_concat(), concat_exports);
      var { fromString: uint8arraysFromString } = (init_from_string(), from_string_exports);
      var cryptoKeys = require_keys4();
      var PeerId2 = require_src8();
      var varint4 = require_varint();
      var { equals: uint8arraysEquals } = (init_equals(), equals_exports);
      var { codes } = require_errors2();
      var { Envelope: Protobuf } = require_envelope();
      var Envelope = class {
        constructor({ peerId, payloadType, payload, signature }) {
          this.peerId = peerId;
          this.payloadType = payloadType;
          this.payload = payload;
          this.signature = signature;
          this._marshal = void 0;
        }
        marshal() {
          if (this._marshal) {
            return this._marshal;
          }
          const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);
          this._marshal = Protobuf.encode({
            publicKey,
            payloadType: this.payloadType,
            payload: this.payload,
            signature: this.signature
          }).finish();
          return this._marshal;
        }
        equals(other) {
          return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);
        }
        validate(domain) {
          const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
          return this.peerId.pubKey.verify(signData, this.signature);
        }
      };
      var formatSignaturePayload = (domain, payloadType, payload) => {
        const domainUint8Array = uint8arraysFromString(domain);
        const domainLength = varint4.encode(domainUint8Array.byteLength);
        const payloadTypeLength = varint4.encode(payloadType.length);
        const payloadLength = varint4.encode(payload.length);
        return uint8arraysConcat([
          new Uint8Array(domainLength),
          domainUint8Array,
          new Uint8Array(payloadTypeLength),
          payloadType,
          new Uint8Array(payloadLength),
          payload
        ]);
      };
      Envelope.createFromProtobuf = async (data) => {
        const envelopeData = Protobuf.decode(data);
        const peerId = await PeerId2.createFromPubKey(envelopeData.publicKey);
        return new Envelope({
          peerId,
          payloadType: envelopeData.payloadType,
          payload: envelopeData.payload,
          signature: envelopeData.signature
        });
      };
      Envelope.seal = async (record, peerId) => {
        const domain = record.domain;
        const payloadType = record.codec;
        const payload = record.marshal();
        const signData = formatSignaturePayload(domain, payloadType, payload);
        const signature = await peerId.privKey.sign(signData);
        return new Envelope({
          peerId,
          payloadType,
          payload,
          signature
        });
      };
      Envelope.openAndCertify = async (data, domain) => {
        const envelope = await Envelope.createFromProtobuf(data);
        const valid = await envelope.validate(domain);
        if (!valid) {
          throw errCode(new Error("envelope signature is not valid for the given domain"), codes.ERR_SIGNATURE_NOT_VALID);
        }
        return envelope;
      };
      module2.exports = Envelope;
    }
  });

  // node_modules/libp2p-utils/src/array-equals.js
  var require_array_equals = __commonJS({
    "node_modules/libp2p-utils/src/array-equals.js"(exports2, module2) {
      "use strict";
      function arrayEquals(a, b) {
        return a.length === b.length && b.sort() && a.sort().every((item, index) => b[index].equals(item));
      }
      module2.exports = arrayEquals;
    }
  });

  // node_modules/libp2p/src/record/peer-record/peer-record.js
  var require_peer_record = __commonJS({
    "node_modules/libp2p/src/record/peer-record/peer-record.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-peer-record"] || ($protobuf.roots["libp2p-peer-record"] = {});
      $root.PeerRecord = function() {
        function PeerRecord(p) {
          this.addresses = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        PeerRecord.prototype.peerId = $util.newBuffer([]);
        PeerRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
        PeerRecord.prototype.addresses = $util.emptyArray;
        PeerRecord.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
            w.uint32(10).bytes(m.peerId);
          if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
            w.uint32(16).uint64(m.seq);
          if (m.addresses != null && m.addresses.length) {
            for (var i = 0; i < m.addresses.length; ++i)
              $root.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
          }
          return w;
        };
        PeerRecord.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.PeerRecord();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.peerId = r.bytes();
                break;
              case 2:
                m.seq = r.uint64();
                break;
              case 3:
                if (!(m.addresses && m.addresses.length))
                  m.addresses = [];
                m.addresses.push($root.PeerRecord.AddressInfo.decode(r, r.uint32()));
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        PeerRecord.fromObject = function fromObject(d) {
          if (d instanceof $root.PeerRecord)
            return d;
          var m = new $root.PeerRecord();
          if (d.peerId != null) {
            if (typeof d.peerId === "string")
              $util.base64.decode(d.peerId, m.peerId = $util.newBuffer($util.base64.length(d.peerId)), 0);
            else if (d.peerId.length)
              m.peerId = d.peerId;
          }
          if (d.seq != null) {
            if ($util.Long)
              (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;
            else if (typeof d.seq === "string")
              m.seq = parseInt(d.seq, 10);
            else if (typeof d.seq === "number")
              m.seq = d.seq;
            else if (typeof d.seq === "object")
              m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
          }
          if (d.addresses) {
            if (!Array.isArray(d.addresses))
              throw TypeError(".PeerRecord.addresses: array expected");
            m.addresses = [];
            for (var i = 0; i < d.addresses.length; ++i) {
              if (typeof d.addresses[i] !== "object")
                throw TypeError(".PeerRecord.addresses: object expected");
              m.addresses[i] = $root.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
            }
          }
          return m;
        };
        PeerRecord.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addresses = [];
          }
          if (o.defaults) {
            if (o.bytes === String)
              d.peerId = "";
            else {
              d.peerId = [];
              if (o.bytes !== Array)
                d.peerId = $util.newBuffer(d.peerId);
            }
            if ($util.Long) {
              var n = new $util.Long(0, 0, true);
              d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
              d.seq = o.longs === String ? "0" : 0;
          }
          if (m.peerId != null && m.hasOwnProperty("peerId")) {
            d.peerId = o.bytes === String ? $util.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
          }
          if (m.seq != null && m.hasOwnProperty("seq")) {
            if (typeof m.seq === "number")
              d.seq = o.longs === String ? String(m.seq) : m.seq;
            else
              d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
          }
          if (m.addresses && m.addresses.length) {
            d.addresses = [];
            for (var j = 0; j < m.addresses.length; ++j) {
              d.addresses[j] = $root.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
            }
          }
          return d;
        };
        PeerRecord.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        PeerRecord.AddressInfo = function() {
          function AddressInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          AddressInfo.prototype.multiaddr = $util.newBuffer([]);
          AddressInfo.encode = function encode3(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
              w.uint32(10).bytes(m.multiaddr);
            return w;
          };
          AddressInfo.decode = function decode5(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.PeerRecord.AddressInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.multiaddr = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          AddressInfo.fromObject = function fromObject(d) {
            if (d instanceof $root.PeerRecord.AddressInfo)
              return d;
            var m = new $root.PeerRecord.AddressInfo();
            if (d.multiaddr != null) {
              if (typeof d.multiaddr === "string")
                $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);
              else if (d.multiaddr.length)
                m.multiaddr = d.multiaddr;
            }
            return m;
          };
          AddressInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              if (o.bytes === String)
                d.multiaddr = "";
              else {
                d.multiaddr = [];
                if (o.bytes !== Array)
                  d.multiaddr = $util.newBuffer(d.multiaddr);
              }
            }
            if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
              d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
            }
            return d;
          };
          AddressInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return AddressInfo;
        }();
        return PeerRecord;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p/src/record/peer-record/consts.js
  var require_consts2 = __commonJS({
    "node_modules/libp2p/src/record/peer-record/consts.js"(exports2, module2) {
      "use strict";
      var domain = "libp2p-peer-record";
      var payloadType = Uint8Array.from([3, 1]);
      module2.exports = {
        ENVELOPE_DOMAIN_PEER_RECORD: domain,
        ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: payloadType
      };
    }
  });

  // node_modules/libp2p/src/record/peer-record/index.js
  var require_peer_record2 = __commonJS({
    "node_modules/libp2p/src/record/peer-record/index.js"(exports2, module2) {
      "use strict";
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var arrayEquals = require_array_equals();
      var { PeerRecord: Protobuf } = require_peer_record();
      var {
        ENVELOPE_DOMAIN_PEER_RECORD,
        ENVELOPE_PAYLOAD_TYPE_PEER_RECORD
      } = require_consts2();
      var PeerRecord = class {
        constructor({ peerId, multiaddrs = [], seqNumber = Date.now() }) {
          this.domain = ENVELOPE_DOMAIN_PEER_RECORD;
          this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
          this.peerId = peerId;
          this.multiaddrs = multiaddrs;
          this.seqNumber = seqNumber;
          this._marshal = void 0;
        }
        marshal() {
          if (this._marshal) {
            return this._marshal;
          }
          this._marshal = Protobuf.encode({
            peerId: this.peerId.toBytes(),
            seq: this.seqNumber,
            addresses: this.multiaddrs.map((m) => ({
              multiaddr: m.bytes
            }))
          }).finish();
          return this._marshal;
        }
        equals(other) {
          if (!(other instanceof PeerRecord)) {
            return false;
          }
          if (!this.peerId.equals(other.peerId)) {
            return false;
          }
          if (this.seqNumber !== other.seqNumber) {
            return false;
          }
          if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
            return false;
          }
          return true;
        }
      };
      PeerRecord.createFromProtobuf = (buf) => {
        const peerRecord = Protobuf.decode(buf);
        const peerId = PeerId2.createFromBytes(peerRecord.peerId);
        const multiaddrs = (peerRecord.addresses || []).map((a) => new Multiaddr2(a.multiaddr));
        const seqNumber = Number(peerRecord.seq);
        return new PeerRecord({ peerId, multiaddrs, seqNumber });
      };
      PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
      module2.exports = PeerRecord;
    }
  });

  // node_modules/libp2p/src/record/utils.js
  var require_utils4 = __commonJS({
    "node_modules/libp2p/src/record/utils.js"(exports2, module2) {
      "use strict";
      var Envelope = require_envelope2();
      var PeerRecord = require_peer_record2();
      async function updateSelfPeerRecord(libp2p) {
        const peerRecord = new PeerRecord({
          peerId: libp2p.peerId,
          multiaddrs: libp2p.multiaddrs
        });
        const envelope = await Envelope.seal(peerRecord, libp2p.peerId);
        libp2p.peerStore.addressBook.consumePeerRecord(envelope);
      }
      module2.exports.updateSelfPeerRecord = updateSelfPeerRecord;
    }
  });

  // node_modules/libp2p/src/transport-manager.js
  var require_transport_manager = __commonJS({
    "node_modules/libp2p/src/transport-manager.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:transports"), {
        error: debug("libp2p:transports:err")
      });
      var pSettle = require_p_settle();
      var { codes } = require_errors2();
      var errCode = require_err_code();
      var { updateSelfPeerRecord } = require_utils4();
      var TransportManager = class {
        constructor({ libp2p, upgrader, faultTolerance = FAULT_TOLERANCE.FATAL_ALL }) {
          this.libp2p = libp2p;
          this.upgrader = upgrader;
          this._transports = /* @__PURE__ */ new Map();
          this._listeners = /* @__PURE__ */ new Map();
          this._listenerOptions = /* @__PURE__ */ new Map();
          this.faultTolerance = faultTolerance;
        }
        add(key, Transport, transportOptions = {}) {
          log("adding %s", key);
          if (!key) {
            throw errCode(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);
          }
          if (this._transports.has(key)) {
            throw errCode(new Error("There is already a transport with this key"), codes.ERR_DUPLICATE_TRANSPORT);
          }
          const transport = new Transport({
            ...transportOptions,
            libp2p: this.libp2p,
            upgrader: this.upgrader
          });
          this._transports.set(key, transport);
          this._listenerOptions.set(key, transportOptions.listenerOptions || {});
          if (!this._listeners.has(key)) {
            this._listeners.set(key, []);
          }
        }
        async close() {
          const tasks = [];
          for (const [key, listeners] of this._listeners) {
            log("closing listeners for %s", key);
            while (listeners.length) {
              const listener = listeners.pop();
              listener.removeAllListeners("listening");
              listener.removeAllListeners("close");
              tasks.push(listener.close());
            }
          }
          await Promise.all(tasks);
          log("all listeners closed");
          for (const key of this._listeners.keys()) {
            this._listeners.set(key, []);
          }
        }
        async dial(ma, options) {
          const transport = this.transportForMultiaddr(ma);
          if (!transport) {
            throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
          }
          try {
            return await transport.dial(ma, options);
          } catch (err) {
            if (!err.code)
              err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
            throw err;
          }
        }
        getAddrs() {
          let addrs = [];
          for (const listeners of this._listeners.values()) {
            for (const listener of listeners) {
              addrs = [...addrs, ...listener.getAddrs()];
            }
          }
          return addrs;
        }
        getTransports() {
          return this._transports.values();
        }
        transportForMultiaddr(ma) {
          for (const transport of this._transports.values()) {
            const addrs = transport.filter([ma]);
            if (addrs.length)
              return transport;
          }
          return null;
        }
        async listen(addrs) {
          if (!addrs || addrs.length === 0) {
            log("no addresses were provided for listening, this node is dial only");
            return;
          }
          const couldNotListen = [];
          for (const [key, transport] of this._transports.entries()) {
            const supportedAddrs = transport.filter(addrs);
            const tasks = [];
            for (const addr of supportedAddrs) {
              log("creating listener for %s on %s", key, addr);
              const listener = transport.createListener(this._listenerOptions.get(key));
              this._listeners.get(key).push(listener);
              listener.on("listening", () => updateSelfPeerRecord(this.libp2p));
              listener.on("close", () => updateSelfPeerRecord(this.libp2p));
              tasks.push(listener.listen(addr));
            }
            if (tasks.length === 0) {
              couldNotListen.push(key);
              continue;
            }
            const results = await pSettle(tasks);
            const isListening = results.find((r) => r.isFulfilled === true);
            if (!isListening && this.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {
              throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
            }
          }
          if (couldNotListen.length === this._transports.size) {
            const message = `no valid addresses were provided for transports [${couldNotListen}]`;
            if (this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {
              throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);
            }
            log(`libp2p in dial mode only: ${message}`);
          }
        }
        async remove(key) {
          log("removing %s", key);
          if (this._listeners.has(key)) {
            for (const listener of this._listeners.get(key)) {
              listener.removeAllListeners("listening");
              listener.removeAllListeners("close");
              await listener.close();
            }
          }
          this._transports.delete(key);
          this._listeners.delete(key);
        }
        async removeAll() {
          const tasks = [];
          for (const key of this._transports.keys()) {
            tasks.push(this.remove(key));
          }
          await Promise.all(tasks);
        }
      };
      var FAULT_TOLERANCE = {
        FATAL_ALL: 0,
        NO_FATAL: 1
      };
      TransportManager.FaultTolerance = FAULT_TOLERANCE;
      module2.exports = TransportManager;
    }
  });

  // node_modules/libp2p/src/config.js
  var require_config = __commonJS({
    "node_modules/libp2p/src/config.js"(exports2, module2) {
      "use strict";
      var mergeOptions = require_merge_options();
      var { dnsaddrResolver } = require_resolvers();
      var Constants = require_constants5();
      var { AGENT_VERSION } = require_consts();
      var RelayConstants = require_constants6();
      var { publicAddressesFirst } = require_address_sort();
      var { FaultTolerance } = require_transport_manager();
      var DefaultConfig = {
        addresses: {
          listen: [],
          announce: [],
          noAnnounce: [],
          announceFilter: (multiaddrs) => multiaddrs
        },
        connectionManager: {
          minConnections: 25
        },
        transportManager: {
          faultTolerance: FaultTolerance.FATAL_ALL
        },
        dialer: {
          maxParallelDials: Constants.MAX_PARALLEL_DIALS,
          maxDialsPerPeer: Constants.MAX_PER_PEER_DIALS,
          dialTimeout: Constants.DIAL_TIMEOUT,
          resolvers: {
            dnsaddr: dnsaddrResolver
          },
          addressSorter: publicAddressesFirst
        },
        host: {
          agentVersion: AGENT_VERSION
        },
        metrics: {
          enabled: false
        },
        peerStore: {
          persistence: false,
          threshold: 5
        },
        peerRouting: {
          refreshManager: {
            enabled: true,
            interval: 6e5,
            bootDelay: 1e4
          }
        },
        config: {
          protocolPrefix: "ipfs",
          dht: {
            enabled: false,
            kBucketSize: 20,
            randomWalk: {
              enabled: false,
              queriesPerPeriod: 1,
              interval: 3e5,
              timeout: 1e4
            }
          },
          nat: {
            enabled: true,
            ttl: 7200,
            keepAlive: true,
            gateway: null,
            externalIp: null,
            pmp: {
              enabled: false
            }
          },
          peerDiscovery: {
            autoDial: true
          },
          pubsub: {
            enabled: true
          },
          relay: {
            enabled: true,
            advertise: {
              bootDelay: RelayConstants.ADVERTISE_BOOT_DELAY,
              enabled: false,
              ttl: RelayConstants.ADVERTISE_TTL
            },
            hop: {
              enabled: false,
              active: false
            },
            autoRelay: {
              enabled: false,
              maxListeners: 2
            }
          },
          transport: {}
        }
      };
      module2.exports.validate = (opts) => {
        const resultingOptions = mergeOptions(DefaultConfig, opts);
        if (resultingOptions.modules.transport.length < 1)
          throw new Error("'options.modules.transport' must contain at least 1 transport");
        return resultingOptions;
      };
    }
  });

  // node_modules/libp2p/src/address-manager/index.js
  var require_address_manager = __commonJS({
    "node_modules/libp2p/src/address-manager/index.js"(exports2, module2) {
      "use strict";
      var { EventEmitter } = require_events();
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var AddressManager = class extends EventEmitter {
        constructor(peerId, { listen = [], announce = [] } = {}) {
          super();
          this.peerId = peerId;
          this.listen = new Set(listen.map((ma) => ma.toString()));
          this.announce = new Set(announce.map((ma) => ma.toString()));
          this.observed = /* @__PURE__ */ new Set();
        }
        getListenAddrs() {
          return Array.from(this.listen).map((a) => new Multiaddr2(a));
        }
        getAnnounceAddrs() {
          return Array.from(this.announce).map((a) => new Multiaddr2(a));
        }
        getObservedAddrs() {
          return Array.from(this.observed).map((a) => new Multiaddr2(a));
        }
        addObservedAddr(addr) {
          let ma = new Multiaddr2(addr);
          const remotePeer = ma.getPeerId();
          if (remotePeer) {
            const remotePeerId = PeerId2.createFromB58String(remotePeer);
            if (remotePeerId.equals(this.peerId)) {
              ma = ma.decapsulate(new Multiaddr2(`/p2p/${this.peerId}`));
            }
          }
          const addrString = ma.toString();
          if (this.observed.has(addrString)) {
            return;
          }
          this.observed.add(addrString);
          this.emit("change:addresses");
        }
      };
      module2.exports = AddressManager;
    }
  });

  // node_modules/libp2p/src/connection-manager/visibility-change-emitter.js
  var require_visibility_change_emitter = __commonJS({
    "node_modules/libp2p/src/connection-manager/visibility-change-emitter.js"(exports2, module2) {
      "use strict";
      var { EventEmitter } = require_events();
      var debug = require_browser2()("latency-monitor:VisibilityChangeEmitter");
      var VisibilityChangeEmitter = class extends EventEmitter {
        constructor() {
          super();
          if (typeof document === "undefined") {
            debug('This is not a browser, no "document" found. Stopping.');
            return;
          }
          this._initializeVisibilityVarNames();
          this._addVisibilityChangeListener();
        }
        _initializeVisibilityVarNames() {
          let hidden2;
          let visibilityChange;
          if (typeof document.hidden !== "undefined") {
            hidden2 = "hidden";
            visibilityChange = "visibilitychange";
          } else if (typeof document.mozHidden !== "undefined") {
            hidden2 = "mozHidden";
            visibilityChange = "mozvisibilitychange";
          } else if (typeof document.msHidden !== "undefined") {
            hidden2 = "msHidden";
            visibilityChange = "msvisibilitychange";
          } else if (typeof document.webkitHidden !== "undefined") {
            hidden2 = "webkitHidden";
            visibilityChange = "webkitvisibilitychange";
          }
          this._hidden = hidden2;
          this._visibilityChange = visibilityChange;
        }
        _addVisibilityChangeListener() {
          if (typeof document.addEventListener === "undefined" || typeof document[this._hidden] === "undefined") {
            debug("Checking page visibility requires a browser that supports the Page Visibility API.");
          } else {
            document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
          }
        }
        isVisible() {
          if (this._hidden === void 0 || document[this._hidden] === void 0) {
            return void 0;
          }
          return !document[this._hidden];
        }
        _handleVisibilityChange() {
          const visible = !document[this._hidden];
          debug(visible ? "Page Visible" : "Page Hidden");
          this.emit("visibilityChange", visible);
        }
      };
      module2.exports = VisibilityChangeEmitter;
    }
  });

  // node_modules/libp2p/src/connection-manager/latency-monitor.js
  var require_latency_monitor = __commonJS({
    "node_modules/libp2p/src/connection-manager/latency-monitor.js"(exports2, module2) {
      "use strict";
      var { EventEmitter } = require_events();
      var VisibilityChangeEmitter = require_visibility_change_emitter();
      var debug = require_browser2()("latency-monitor:LatencyMonitor");
      var LatencyMonitor = class extends EventEmitter {
        constructor({ latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = {}) {
          super();
          const that = this;
          that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500;
          that.latencyRandomPercentage = latencyRandomPercentage || 10;
          that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100) * that.latencyCheckIntervalMs;
          that._latecyCheckSubtract = that._latecyCheckMultiply / 2;
          that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs || 5 * 1e3;
          debug("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
          if (that.dataEmitIntervalMs) {
            debug("Expecting ~%s events per summary", that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
          } else {
            debug("Not emitting summaries");
          }
          that.asyncTestFn = asyncTestFn;
        }
        start() {
          if (globalThis.process && globalThis.process.hrtime) {
            debug("Using process.hrtime for timing");
            this.now = globalThis.process.hrtime;
            this.getDeltaMS = (startTime) => {
              const hrtime = this.now(startTime);
              return hrtime[0] * 1e3 + hrtime[1] / 1e6;
            };
          } else if (typeof window !== "undefined" && window.performance && window.performance.now) {
            debug("Using performance.now for timing");
            this.now = window.performance.now.bind(window.performance);
            this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
          } else {
            debug("Using Date.now for timing");
            this.now = Date.now;
            this.getDeltaMS = (startTime) => this.now() - startTime;
          }
          this._latencyData = this._initLatencyData();
          if (isBrowser()) {
            this._visibilityChangeEmitter = new VisibilityChangeEmitter();
            this._visibilityChangeEmitter.on("visibilityChange", (pageInFocus) => {
              if (pageInFocus) {
                this._startTimers();
              } else {
                this._emitSummary();
                this._stopTimers();
              }
            });
          }
          if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {
            this._startTimers();
          }
        }
        stop() {
          this._stopTimers();
        }
        _startTimers() {
          if (this._checkLatencyID) {
            return;
          }
          this._checkLatency();
          if (this.dataEmitIntervalMs) {
            this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
            if (typeof this._emitIntervalID.unref === "function") {
              this._emitIntervalID.unref();
            }
          }
        }
        _stopTimers() {
          if (this._checkLatencyID) {
            clearTimeout(this._checkLatencyID);
            this._checkLatencyID = void 0;
          }
          if (this._emitIntervalID) {
            clearInterval(this._emitIntervalID);
            this._emitIntervalID = void 0;
          }
        }
        _emitSummary() {
          const summary = this.getSummary();
          if (summary.events > 0) {
            this.emit("data", summary);
          }
        }
        getSummary() {
          const latency = {
            events: this._latencyData.events,
            minMs: this._latencyData.minMs,
            maxMs: this._latencyData.maxMs,
            avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
            lengthMs: this.getDeltaMS(this._latencyData.startTime)
          };
          this._latencyData = this._initLatencyData();
          debug("Summary: %O", latency);
          return latency;
        }
        _checkLatency() {
          const that = this;
          const randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;
          const localData = {
            deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
            startTime: that.now()
          };
          const cb = () => {
            if (!this._checkLatencyID) {
              return;
            }
            const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
            that._checkLatency();
            that._latencyData.events++;
            that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
            that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
            that._latencyData.totalMs += deltaMS;
            debug("MS: %s Data: %O", deltaMS, that._latencyData);
          };
          debug("localData: %O", localData);
          this._checkLatencyID = setTimeout(() => {
            if (that.asyncTestFn) {
              localData.deltaOffset = 0;
              localData.startTime = that.now();
              that.asyncTestFn(cb);
            } else {
              localData.deltaOffset -= 1;
              cb();
            }
          }, localData.deltaOffset);
          if (typeof this._checkLatencyID.unref === "function") {
            this._checkLatencyID.unref();
          }
        }
        _initLatencyData() {
          return {
            startTime: this.now(),
            minMs: Number.POSITIVE_INFINITY,
            maxMs: Number.NEGATIVE_INFINITY,
            events: 0,
            totalMs: 0
          };
        }
      };
      function isBrowser() {
        return typeof window !== "undefined";
      }
      module2.exports = LatencyMonitor;
    }
  });

  // node_modules/retimer/time-browser.js
  var require_time_browser = __commonJS({
    "node_modules/retimer/time-browser.js"(exports2, module2) {
      "use strict";
      module2.exports = function getTime() {
        return Date.now();
      };
    }
  });

  // node_modules/retimer/retimer.js
  var require_retimer = __commonJS({
    "node_modules/retimer/retimer.js"(exports2, module2) {
      "use strict";
      var getTime = require_time_browser();
      var Retimer = class {
        constructor(callback, timeout, args) {
          const that = this;
          this._started = getTime();
          this._rescheduled = 0;
          this._scheduled = timeout;
          this._args = args;
          this._triggered = false;
          this._timerWrapper = () => {
            if (that._rescheduled > 0) {
              that._scheduled = that._rescheduled - (getTime() - that._started);
              that._schedule(that._scheduled);
            } else {
              that._triggered = true;
              callback.apply(null, that._args);
            }
          };
          this._timer = setTimeout(this._timerWrapper, timeout);
        }
        reschedule(timeout) {
          if (!timeout) {
            timeout = this._scheduled;
          }
          const now = getTime();
          if (now + timeout - (this._started + this._scheduled) < 0) {
            clearTimeout(this._timer);
            this._schedule(timeout);
          } else if (!this._triggered) {
            this._started = now;
            this._rescheduled = timeout;
          } else {
            this._schedule(timeout);
          }
        }
        _schedule(timeout) {
          this._triggered = false;
          this._started = getTime();
          this._rescheduled = 0;
          this._scheduled = timeout;
          this._timer = setTimeout(this._timerWrapper, timeout);
        }
        clear() {
          clearTimeout(this._timer);
        }
      };
      function retimer() {
        if (typeof arguments[0] !== "function") {
          throw new Error("callback needed");
        }
        if (typeof arguments[1] !== "number") {
          throw new Error("timeout needed");
        }
        let args;
        if (arguments.length > 0) {
          args = new Array(arguments.length - 2);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 2];
          }
        }
        return new Retimer(arguments[0], arguments[1], args);
      }
      module2.exports = retimer;
    }
  });

  // node_modules/libp2p/src/connection-manager/index.js
  var require_connection_manager = __commonJS({
    "node_modules/libp2p/src/connection-manager/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:connection-manager"), {
        error: debug("libp2p:connection-manager:err")
      });
      var errcode = require_err_code();
      var mergeOptions = require_merge_options();
      var LatencyMonitor = require_latency_monitor();
      var retimer = require_retimer();
      var { EventEmitter } = require_events();
      var PeerId2 = require_src8();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var defaultOptions = {
        maxConnections: Infinity,
        minConnections: 0,
        maxData: Infinity,
        maxSentData: Infinity,
        maxReceivedData: Infinity,
        maxEventLoopDelay: Infinity,
        pollInterval: 2e3,
        autoDialInterval: 1e4,
        movingAverageInterval: 6e4,
        defaultPeerValue: 1
      };
      var ConnectionManager = class extends EventEmitter {
        constructor(libp2p, options = {}) {
          super();
          this._libp2p = libp2p;
          this._peerId = libp2p.peerId.toB58String();
          this._options = mergeOptions.call({ ignoreUndefined: true }, defaultOptions, options);
          if (this._options.maxConnections < this._options.minConnections) {
            throw errcode(new Error("Connection Manager maxConnections must be greater than minConnections"), ERR_INVALID_PARAMETERS);
          }
          log("options: %j", this._options);
          this._peerValues = /* @__PURE__ */ new Map();
          this.connections = /* @__PURE__ */ new Map();
          this._started = false;
          this._timer = null;
          this._autoDialTimeout = null;
          this._checkMetrics = this._checkMetrics.bind(this);
          this._autoDial = this._autoDial.bind(this);
          this._latencyMonitor = new LatencyMonitor({
            latencyCheckIntervalMs: this._options.pollInterval,
            dataEmitIntervalMs: this._options.pollInterval
          });
        }
        get size() {
          return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);
        }
        start() {
          if (this._libp2p.metrics) {
            this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);
          }
          this._latencyMonitor.start();
          this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
          this._latencyMonitor.on("data", this._onLatencyMeasure);
          this._started = true;
          log("started");
          this._options.autoDial && this._autoDial();
        }
        async stop() {
          this._autoDialTimeout && this._autoDialTimeout.clear();
          this._timer && this._timer.clear();
          this._latencyMonitor.removeListener("data", this._onLatencyMeasure);
          this._latencyMonitor.stop();
          this._started = false;
          await this._close();
          log("stopped");
        }
        async _close() {
          const tasks = [];
          for (const connectionList of this.connections.values()) {
            for (const connection of connectionList) {
              tasks.push(connection.close());
            }
          }
          await Promise.all(tasks);
          this.connections.clear();
        }
        setPeerValue(peerId, value) {
          if (value < 0 || value > 1) {
            throw new Error("value should be a number between 0 and 1");
          }
          this._peerValues.set(peerId.toB58String(), value);
        }
        _checkMetrics() {
          if (this._libp2p.metrics) {
            const movingAverages = this._libp2p.metrics.global.movingAverages;
            const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();
            this._checkMaxLimit("maxReceivedData", received);
            const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();
            this._checkMaxLimit("maxSentData", sent);
            const total = received + sent;
            this._checkMaxLimit("maxData", total);
            log("metrics update", total);
            this._timer = retimer(this._checkMetrics, this._options.pollInterval);
          }
        }
        onConnect(connection) {
          const peerId = connection.remotePeer;
          const peerIdStr = peerId.toB58String();
          const storedConn = this.connections.get(peerIdStr);
          this.emit("peer:connect", connection);
          if (storedConn) {
            storedConn.push(connection);
          } else {
            this.connections.set(peerIdStr, [connection]);
          }
          this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);
          if (!this._peerValues.has(peerIdStr)) {
            this._peerValues.set(peerIdStr, this._options.defaultPeerValue);
          }
          this._checkMaxLimit("maxConnections", this.size);
        }
        onDisconnect(connection) {
          const peerId = connection.remotePeer.toB58String();
          let storedConn = this.connections.get(peerId);
          if (storedConn && storedConn.length > 1) {
            storedConn = storedConn.filter((conn) => conn.id !== connection.id);
            this.connections.set(peerId, storedConn);
          } else if (storedConn) {
            this.connections.delete(peerId);
            this._peerValues.delete(connection.remotePeer.toB58String());
            this.emit("peer:disconnect", connection);
          }
        }
        get(peerId) {
          const connections = this.getAll(peerId);
          if (connections.length) {
            return connections[0];
          }
          return null;
        }
        getAll(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const id = peerId.toB58String();
          const connections = this.connections.get(id);
          if (connections) {
            return connections.filter((connection) => connection.stat.status === "open");
          }
          return [];
        }
        _onLatencyMeasure(summary) {
          this._checkMaxLimit("maxEventLoopDelay", summary.avgMs);
        }
        _checkMaxLimit(name, value) {
          const limit = this._options[name];
          log("checking limit of %s. current value: %d of %d", name, value, limit);
          if (value > limit) {
            log("%s: limit exceeded: %s, %d", this._peerId, name, value);
            this._maybeDisconnectOne();
          }
        }
        async _autoDial() {
          const minConnections = this._options.minConnections;
          if (this.size >= minConnections) {
            this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
            return;
          }
          const peers = Array.from(this._libp2p.peerStore.peers.values()).sort((a, b) => {
            if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {
              return 1;
            } else if (b.id.pubKey && !a.id.pubKey) {
              return 1;
            }
            return -1;
          });
          for (let i = 0; i < peers.length && this.size < minConnections; i++) {
            if (!this.get(peers[i].id)) {
              log("connecting to a peerStore stored peer %s", peers[i].id.toB58String());
              try {
                await this._libp2p.dialer.connectToPeer(peers[i].id);
                if (!this._started) {
                  return;
                }
              } catch (err) {
                log.error("could not connect to peerStore stored peer", err);
              }
            }
          }
          this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
        }
        _maybeDisconnectOne() {
          if (this._options.minConnections < this.connections.size) {
            const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])));
            log("%s: sorted peer values: %j", this._peerId, peerValues);
            const disconnectPeer = peerValues[0];
            if (disconnectPeer) {
              const peerId = disconnectPeer[0];
              log("%s: lowest value peer is %s", this._peerId, peerId);
              log("%s: closing a connection to %j", this._peerId, peerId);
              for (const connections of this.connections.values()) {
                if (connections[0].remotePeer.toB58String() === peerId) {
                  connections[0].close();
                  break;
                }
              }
            }
          }
        }
      };
      module2.exports = ConnectionManager;
    }
  });

  // node_modules/libp2p/src/circuit/protocol/index.js
  var require_protocol = __commonJS({
    "node_modules/libp2p/src/circuit/protocol/index.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-circuit"] || ($protobuf.roots["libp2p-circuit"] = {});
      $root.CircuitRelay = function() {
        function CircuitRelay(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        CircuitRelay.prototype.type = 1;
        CircuitRelay.prototype.srcPeer = null;
        CircuitRelay.prototype.dstPeer = null;
        CircuitRelay.prototype.code = 100;
        CircuitRelay.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.type != null && Object.hasOwnProperty.call(m, "type"))
            w.uint32(8).int32(m.type);
          if (m.srcPeer != null && Object.hasOwnProperty.call(m, "srcPeer"))
            $root.CircuitRelay.Peer.encode(m.srcPeer, w.uint32(18).fork()).ldelim();
          if (m.dstPeer != null && Object.hasOwnProperty.call(m, "dstPeer"))
            $root.CircuitRelay.Peer.encode(m.dstPeer, w.uint32(26).fork()).ldelim();
          if (m.code != null && Object.hasOwnProperty.call(m, "code"))
            w.uint32(32).int32(m.code);
          return w;
        };
        CircuitRelay.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.CircuitRelay();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.type = r.int32();
                break;
              case 2:
                m.srcPeer = $root.CircuitRelay.Peer.decode(r, r.uint32());
                break;
              case 3:
                m.dstPeer = $root.CircuitRelay.Peer.decode(r, r.uint32());
                break;
              case 4:
                m.code = r.int32();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        CircuitRelay.fromObject = function fromObject(d) {
          if (d instanceof $root.CircuitRelay)
            return d;
          var m = new $root.CircuitRelay();
          switch (d.type) {
            case "HOP":
            case 1:
              m.type = 1;
              break;
            case "STOP":
            case 2:
              m.type = 2;
              break;
            case "STATUS":
            case 3:
              m.type = 3;
              break;
            case "CAN_HOP":
            case 4:
              m.type = 4;
              break;
          }
          if (d.srcPeer != null) {
            if (typeof d.srcPeer !== "object")
              throw TypeError(".CircuitRelay.srcPeer: object expected");
            m.srcPeer = $root.CircuitRelay.Peer.fromObject(d.srcPeer);
          }
          if (d.dstPeer != null) {
            if (typeof d.dstPeer !== "object")
              throw TypeError(".CircuitRelay.dstPeer: object expected");
            m.dstPeer = $root.CircuitRelay.Peer.fromObject(d.dstPeer);
          }
          switch (d.code) {
            case "SUCCESS":
            case 100:
              m.code = 100;
              break;
            case "HOP_SRC_ADDR_TOO_LONG":
            case 220:
              m.code = 220;
              break;
            case "HOP_DST_ADDR_TOO_LONG":
            case 221:
              m.code = 221;
              break;
            case "HOP_SRC_MULTIADDR_INVALID":
            case 250:
              m.code = 250;
              break;
            case "HOP_DST_MULTIADDR_INVALID":
            case 251:
              m.code = 251;
              break;
            case "HOP_NO_CONN_TO_DST":
            case 260:
              m.code = 260;
              break;
            case "HOP_CANT_DIAL_DST":
            case 261:
              m.code = 261;
              break;
            case "HOP_CANT_OPEN_DST_STREAM":
            case 262:
              m.code = 262;
              break;
            case "HOP_CANT_SPEAK_RELAY":
            case 270:
              m.code = 270;
              break;
            case "HOP_CANT_RELAY_TO_SELF":
            case 280:
              m.code = 280;
              break;
            case "STOP_SRC_ADDR_TOO_LONG":
            case 320:
              m.code = 320;
              break;
            case "STOP_DST_ADDR_TOO_LONG":
            case 321:
              m.code = 321;
              break;
            case "STOP_SRC_MULTIADDR_INVALID":
            case 350:
              m.code = 350;
              break;
            case "STOP_DST_MULTIADDR_INVALID":
            case 351:
              m.code = 351;
              break;
            case "STOP_RELAY_REFUSED":
            case 390:
              m.code = 390;
              break;
            case "MALFORMED_MESSAGE":
            case 400:
              m.code = 400;
              break;
          }
          return m;
        };
        CircuitRelay.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            d.type = o.enums === String ? "HOP" : 1;
            d.srcPeer = null;
            d.dstPeer = null;
            d.code = o.enums === String ? "SUCCESS" : 100;
          }
          if (m.type != null && m.hasOwnProperty("type")) {
            d.type = o.enums === String ? $root.CircuitRelay.Type[m.type] : m.type;
          }
          if (m.srcPeer != null && m.hasOwnProperty("srcPeer")) {
            d.srcPeer = $root.CircuitRelay.Peer.toObject(m.srcPeer, o);
          }
          if (m.dstPeer != null && m.hasOwnProperty("dstPeer")) {
            d.dstPeer = $root.CircuitRelay.Peer.toObject(m.dstPeer, o);
          }
          if (m.code != null && m.hasOwnProperty("code")) {
            d.code = o.enums === String ? $root.CircuitRelay.Status[m.code] : m.code;
          }
          return d;
        };
        CircuitRelay.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        CircuitRelay.Status = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[100] = "SUCCESS"] = 100;
          values[valuesById[220] = "HOP_SRC_ADDR_TOO_LONG"] = 220;
          values[valuesById[221] = "HOP_DST_ADDR_TOO_LONG"] = 221;
          values[valuesById[250] = "HOP_SRC_MULTIADDR_INVALID"] = 250;
          values[valuesById[251] = "HOP_DST_MULTIADDR_INVALID"] = 251;
          values[valuesById[260] = "HOP_NO_CONN_TO_DST"] = 260;
          values[valuesById[261] = "HOP_CANT_DIAL_DST"] = 261;
          values[valuesById[262] = "HOP_CANT_OPEN_DST_STREAM"] = 262;
          values[valuesById[270] = "HOP_CANT_SPEAK_RELAY"] = 270;
          values[valuesById[280] = "HOP_CANT_RELAY_TO_SELF"] = 280;
          values[valuesById[320] = "STOP_SRC_ADDR_TOO_LONG"] = 320;
          values[valuesById[321] = "STOP_DST_ADDR_TOO_LONG"] = 321;
          values[valuesById[350] = "STOP_SRC_MULTIADDR_INVALID"] = 350;
          values[valuesById[351] = "STOP_DST_MULTIADDR_INVALID"] = 351;
          values[valuesById[390] = "STOP_RELAY_REFUSED"] = 390;
          values[valuesById[400] = "MALFORMED_MESSAGE"] = 400;
          return values;
        }();
        CircuitRelay.Type = function() {
          var valuesById = {}, values = Object.create(valuesById);
          values[valuesById[1] = "HOP"] = 1;
          values[valuesById[2] = "STOP"] = 2;
          values[valuesById[3] = "STATUS"] = 3;
          values[valuesById[4] = "CAN_HOP"] = 4;
          return values;
        }();
        CircuitRelay.Peer = function() {
          function Peer(p) {
            this.addrs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Peer.prototype.id = $util.newBuffer([]);
          Peer.prototype.addrs = $util.emptyArray;
          Peer.encode = function encode3(m, w) {
            if (!w)
              w = $Writer.create();
            w.uint32(10).bytes(m.id);
            if (m.addrs != null && m.addrs.length) {
              for (var i = 0; i < m.addrs.length; ++i)
                w.uint32(18).bytes(m.addrs[i]);
            }
            return w;
          };
          Peer.decode = function decode5(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.CircuitRelay.Peer();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.id = r.bytes();
                  break;
                case 2:
                  if (!(m.addrs && m.addrs.length))
                    m.addrs = [];
                  m.addrs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            if (!m.hasOwnProperty("id"))
              throw $util.ProtocolError("missing required 'id'", { instance: m });
            return m;
          };
          Peer.fromObject = function fromObject(d) {
            if (d instanceof $root.CircuitRelay.Peer)
              return d;
            var m = new $root.CircuitRelay.Peer();
            if (d.id != null) {
              if (typeof d.id === "string")
                $util.base64.decode(d.id, m.id = $util.newBuffer($util.base64.length(d.id)), 0);
              else if (d.id.length)
                m.id = d.id;
            }
            if (d.addrs) {
              if (!Array.isArray(d.addrs))
                throw TypeError(".CircuitRelay.Peer.addrs: array expected");
              m.addrs = [];
              for (var i = 0; i < d.addrs.length; ++i) {
                if (typeof d.addrs[i] === "string")
                  $util.base64.decode(d.addrs[i], m.addrs[i] = $util.newBuffer($util.base64.length(d.addrs[i])), 0);
                else if (d.addrs[i].length)
                  m.addrs[i] = d.addrs[i];
              }
            }
            return m;
          };
          Peer.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.addrs = [];
            }
            if (o.defaults) {
              if (o.bytes === String)
                d.id = "";
              else {
                d.id = [];
                if (o.bytes !== Array)
                  d.id = $util.newBuffer(d.id);
              }
            }
            if (m.id != null && m.hasOwnProperty("id")) {
              d.id = o.bytes === String ? $util.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
            }
            if (m.addrs && m.addrs.length) {
              d.addrs = [];
              for (var j = 0; j < m.addrs.length; ++j) {
                d.addrs[j] = o.bytes === String ? $util.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
              }
            }
            return d;
          };
          Peer.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Peer;
        }();
        return CircuitRelay;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p-utils/src/stream-to-ma-conn.js
  var require_stream_to_ma_conn = __commonJS({
    "node_modules/libp2p-utils/src/stream-to-ma-conn.js"(exports2, module2) {
      "use strict";
      var { source: abortable } = require_abortable_iterator();
      var debug = require_browser2();
      var log = debug("libp2p:stream:converter");
      function streamToMaConnection({ stream, remoteAddr, localAddr }, options = {}) {
        const { sink, source } = stream;
        const maConn = {
          async sink(source2) {
            if (options.signal) {
              source2 = abortable(source2, options.signal);
            }
            try {
              await sink(source2);
            } catch (err) {
              if (err.type !== "aborted") {
                log(err);
              }
            }
            close();
          },
          source: options.signal ? abortable(source, options.signal) : source,
          conn: stream,
          localAddr,
          remoteAddr,
          timeline: { open: Date.now(), close: void 0 },
          close() {
            sink(new Uint8Array(0));
            return close();
          }
        };
        function close() {
          if (!maConn.timeline.close) {
            maConn.timeline.close = Date.now();
          }
          return Promise.resolve();
        }
        return maConn;
      }
      module2.exports = streamToMaConnection;
    }
  });

  // node_modules/libp2p/src/circuit/multicodec.js
  var require_multicodec = __commonJS({
    "node_modules/libp2p/src/circuit/multicodec.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        relay: "/libp2p/circuit/relay/0.1.0"
      };
    }
  });

  // node_modules/libp2p/src/circuit/listener.js
  var require_listener = __commonJS({
    "node_modules/libp2p/src/circuit/listener.js"(exports2, module2) {
      "use strict";
      var { EventEmitter } = require_events();
      var { Multiaddr: Multiaddr2 } = require_src();
      module2.exports = (libp2p) => {
        const listeningAddrs = /* @__PURE__ */ new Map();
        async function listen(addr) {
          const addrString = String(addr).split("/p2p-circuit").find((a) => a !== "");
          const relayConn = await libp2p.dial(new Multiaddr2(addrString));
          const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
          listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);
          listener.emit("listening");
        }
        function getAddrs() {
          const addrs = [];
          for (const addr of listeningAddrs.values()) {
            addrs.push(addr);
          }
          return addrs;
        }
        const listener = Object.assign(new EventEmitter(), {
          close: () => Promise.resolve(),
          listen,
          getAddrs
        });
        libp2p.connectionManager.on("peer:disconnect", (connection) => {
          const deleted = listeningAddrs.delete(connection.remotePeer.toB58String());
          if (deleted) {
            listener.emit("close");
          }
        });
        return listener;
      };
    }
  });

  // node_modules/libp2p/src/circuit/circuit/utils.js
  var require_utils5 = __commonJS({
    "node_modules/libp2p/src/circuit/circuit/utils.js"(exports2, module2) {
      "use strict";
      var { Multiaddr: Multiaddr2 } = require_src();
      var { CircuitRelay } = require_protocol();
      function writeResponse(streamHandler, status) {
        streamHandler.write({
          type: CircuitRelay.Type.STATUS,
          code: status
        });
      }
      function validateAddrs(msg, streamHandler) {
        try {
          if (msg.dstPeer && msg.dstPeer.addrs) {
            msg.dstPeer.addrs.forEach((addr) => {
              return new Multiaddr2(addr);
            });
          }
        } catch (err) {
          writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
          throw err;
        }
        try {
          if (msg.srcPeer && msg.srcPeer.addrs) {
            msg.srcPeer.addrs.forEach((addr) => {
              return new Multiaddr2(addr);
            });
          }
        } catch (err) {
          writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
          throw err;
        }
      }
      module2.exports = {
        validateAddrs
      };
    }
  });

  // node_modules/it-length-prefixed/src/varint-encode.js
  var require_varint_encode3 = __commonJS({
    "node_modules/it-length-prefixed/src/varint-encode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint();
      var { Buffer: Buffer2 } = require_buffer();
      var varintEncode = (value, target, offset) => {
        const ret = Varint.encode(value, target, offset);
        varintEncode.bytes = Varint.encode.bytes;
        return target || Buffer2.from(ret);
      };
      module2.exports = varintEncode;
    }
  });

  // node_modules/it-length-prefixed/src/encode.js
  var require_encode5 = __commonJS({
    "node_modules/it-length-prefixed/src/encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintEncode = require_varint_encode3();
      var MIN_POOL_SIZE = 8;
      var DEFAULT_POOL_SIZE = 10 * 1024;
      function encode3(options) {
        options = options || {};
        const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
        const encodeLength = options.lengthEncoder || varintEncode;
        const encoder = async function* (source) {
          let pool = Buffer2.alloc(poolSize);
          let poolOffset = 0;
          for await (const chunk of source) {
            encodeLength(chunk.length, pool, poolOffset);
            const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
            poolOffset += encodeLength.bytes;
            if (pool.length - poolOffset < MIN_POOL_SIZE) {
              pool = Buffer2.alloc(poolSize);
              poolOffset = 0;
            }
            yield new BufferList().append(encodedLength).append(chunk);
          }
        };
        return encoder;
      }
      encode3.single = (chunk, options) => {
        options = options || {};
        const encodeLength = options.lengthEncoder || varintEncode;
        return new BufferList([encodeLength(chunk.length), chunk.slice()]);
      };
      module2.exports = encode3;
      module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
      module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
    }
  });

  // node_modules/it-length-prefixed/src/varint-decode.js
  var require_varint_decode3 = __commonJS({
    "node_modules/it-length-prefixed/src/varint-decode.js"(exports2, module2) {
      "use strict";
      var Varint = require_varint();
      var { Buffer: Buffer2 } = require_buffer();
      var toBufferProxy = (bl) => new Proxy({}, {
        get: (_, prop) => {
          return prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop));
        }
      });
      var varintDecode = (data) => {
        const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
        varintDecode.bytes = Varint.decode.bytes;
        return len;
      };
      module2.exports = varintDecode;
    }
  });

  // node_modules/it-length-prefixed/src/decode.js
  var require_decode6 = __commonJS({
    "node_modules/it-length-prefixed/src/decode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      var varintDecode = require_varint_decode3();
      var MAX_LENGTH_LENGTH = 8;
      var MAX_DATA_LENGTH = 1024 * 1024 * 4;
      var Empty = Buffer2.alloc(0);
      var ReadModes = { LENGTH: "readLength", DATA: "readData" };
      var ReadHandlers = {
        [ReadModes.LENGTH]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          let dataLength;
          try {
            dataLength = options.lengthDecoder(buffer);
          } catch (err) {
            if (buffer.length > options.maxLengthLength) {
              throw Object.assign(err, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
            }
            if (err instanceof RangeError) {
              return { mode: ReadModes.LENGTH, buffer, chunk: void 0, state: void 0, data: void 0 };
            }
            throw err;
          }
          if (dataLength > options.maxDataLength) {
            throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" });
          }
          chunk = buffer.shallowSlice(options.lengthDecoder.bytes);
          buffer = new BufferList();
          if (options.onLength)
            options.onLength(dataLength);
          if (dataLength <= 0) {
            if (options.onData)
              options.onData(Empty);
            return { mode: ReadModes.LENGTH, chunk, buffer, data: Empty };
          }
          return { mode: ReadModes.DATA, chunk, buffer, state: { dataLength }, data: void 0 };
        },
        [ReadModes.DATA]: (chunk, buffer, state, options) => {
          buffer = buffer.append(chunk);
          if (!state) {
            throw new Error("state is required");
          }
          if (buffer.length < state.dataLength) {
            return { mode: ReadModes.DATA, buffer, state, chunk: void 0, data: void 0 };
          }
          const { dataLength } = state;
          const data = buffer.shallowSlice(0, dataLength);
          const nextChunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : void 0;
          buffer = new BufferList();
          if (options.onData)
            options.onData(data);
          return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer, state: void 0, data };
        }
      };
      function decode5(options) {
        options = options || {};
        const opts = {
          lengthDecoder: options.lengthDecoder || varintDecode,
          maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
          maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
          onLength: options.onLength,
          onData: options.onData
        };
        const decoder = async function* (source) {
          let buffer = new BufferList();
          let mode = ReadModes.LENGTH;
          let state;
          for await (const chunk of source) {
            let nextChunk = chunk;
            while (nextChunk) {
              const result = ReadHandlers[mode](nextChunk, buffer, state, opts);
              mode = result.mode;
              nextChunk = result.chunk;
              buffer = result.buffer;
              state = result.state;
              if (result.data) {
                yield result.data;
              }
            }
          }
          if (buffer.length) {
            throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" });
          }
        };
        return decoder;
      }
      decode5.fromReader = (reader, options) => {
        let byteLength = 1;
        const varByteSource = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: async () => {
            try {
              return await reader.next(byteLength);
            } catch (err) {
              if (err.code === "ERR_UNDER_READ") {
                return { done: true, value: null };
              }
              throw err;
            } finally {
              byteLength = 1;
            }
          }
        };
        const onLength = (l) => {
          byteLength = l;
        };
        return decode5({
          ...options || {},
          onLength
        })(varByteSource);
      };
      module2.exports = decode5;
      module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
      module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
    }
  });

  // node_modules/it-length-prefixed/src/int32BE-encode.js
  var require_int32BE_encode3 = __commonJS({
    "node_modules/it-length-prefixed/src/int32BE-encode.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var int32BEEncode = (value, target, offset) => {
        target = target || Buffer2.allocUnsafe(4);
        target.writeInt32BE(value, offset);
        return target;
      };
      int32BEEncode.bytes = 4;
      module2.exports = int32BEEncode;
    }
  });

  // node_modules/it-length-prefixed/src/int32BE-decode.js
  var require_int32BE_decode3 = __commonJS({
    "node_modules/it-length-prefixed/src/int32BE-decode.js"(exports2, module2) {
      "use strict";
      var int32BEDecode = (data) => {
        if (data.length < 4)
          throw RangeError("Could not decode int32BE");
        return data.readInt32BE(0);
      };
      int32BEDecode.bytes = 4;
      module2.exports = int32BEDecode;
    }
  });

  // node_modules/it-length-prefixed/src/index.js
  var require_src14 = __commonJS({
    "node_modules/it-length-prefixed/src/index.js"(exports2) {
      "use strict";
      exports2.encode = require_encode5();
      exports2.decode = require_decode6();
      exports2.varintEncode = require_varint_encode3();
      exports2.varintDecode = require_varint_decode3();
      exports2.int32BEEncode = require_int32BE_encode3();
      exports2.int32BEDecode = require_int32BE_decode3();
    }
  });

  // node_modules/it-reader/index.js
  var require_it_reader2 = __commonJS({
    "node_modules/it-reader/index.js"(exports2, module2) {
      var BufferList = require_BufferList();
      module2.exports = (source) => {
        const reader = async function* () {
          let bytes = yield;
          let bl = new BufferList();
          for await (const chunk of source) {
            if (!bytes) {
              bytes = yield bl.append(chunk);
              bl = new BufferList();
              continue;
            }
            bl.append(chunk);
            while (bl.length >= bytes) {
              const data = bl.shallowSlice(0, bytes);
              bl.consume(bytes);
              bytes = yield data;
              if (!bytes) {
                if (bl.length) {
                  bytes = yield bl;
                  bl = new BufferList();
                }
                break;
              }
            }
          }
          if (bytes) {
            throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
          }
        }();
        reader.next();
        return reader;
      };
    }
  });

  // node_modules/it-handshake/src/index.js
  var require_src15 = __commonJS({
    "node_modules/it-handshake/src/index.js"(exports2, module2) {
      "use strict";
      var Reader = require_it_reader2();
      var Writer = require_it_pushable2();
      var defer = require_p_defer();
      module2.exports = (stream) => {
        const writer = Writer();
        const reader = Reader(stream.source);
        const sourcePromise = defer();
        let sinkErr;
        const sinkPromise = stream.sink(async function* () {
          yield* writer;
          const source = await sourcePromise.promise;
          yield* source;
        }());
        sinkPromise.catch((err) => {
          sinkErr = err;
        });
        const rest = {
          sink: (source) => {
            if (sinkErr) {
              return Promise.reject(sinkErr);
            }
            sourcePromise.resolve(source);
            return sinkPromise;
          },
          source: reader
        };
        return {
          reader,
          writer,
          stream: rest,
          rest: () => writer.end(),
          write: writer.push,
          read: async () => {
            return (await reader.next()).value;
          }
        };
      };
    }
  });

  // node_modules/libp2p/src/circuit/circuit/stream-handler.js
  var require_stream_handler = __commonJS({
    "node_modules/libp2p/src/circuit/circuit/stream-handler.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:circuit:stream-handler"), {
        error: debug("libp2p:circuit:stream-handler:err")
      });
      var lp = require_src14();
      var handshake = require_src15();
      var { CircuitRelay } = require_protocol();
      var StreamHandler = class {
        constructor({ stream, maxLength = 4096 }) {
          this.stream = stream;
          this.shake = handshake(this.stream);
          this.decoder = lp.decode.fromReader(this.shake.reader, { maxDataLength: maxLength });
        }
        async read() {
          const msg = await this.decoder.next();
          if (msg.value) {
            const value = CircuitRelay.decode(msg.value.slice());
            log("read message type", value.type);
            return value;
          }
          log("read received no value, closing stream");
          this.close();
        }
        write(msg) {
          log("write message type %s", msg.type);
          this.shake.write(lp.encode.single(CircuitRelay.encode(msg).finish()));
        }
        rest() {
          this.shake.rest();
          return this.shake.stream;
        }
        end(msg) {
          this.write(msg);
          this.close();
        }
        close() {
          log("closing the stream");
          this.rest().sink([]);
        }
      };
      module2.exports = StreamHandler;
    }
  });

  // node_modules/libp2p/src/circuit/circuit/stop.js
  var require_stop = __commonJS({
    "node_modules/libp2p/src/circuit/circuit/stop.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:circuit:stop"), {
        error: debug("libp2p:circuit:stop:err")
      });
      var { CircuitRelay: CircuitPB } = require_protocol();
      var multicodec = require_multicodec();
      var StreamHandler = require_stream_handler();
      var { validateAddrs } = require_utils5();
      module2.exports.handleStop = function handleStop({
        connection,
        request,
        streamHandler
      }) {
        try {
          validateAddrs(request, streamHandler);
        } catch (err) {
          return log.error("invalid stop request via peer %s", connection.remotePeer.toB58String(), err);
        }
        log("stop request is valid");
        streamHandler.write({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.SUCCESS
        });
        return streamHandler.rest();
      };
      module2.exports.stop = async function stop({
        connection,
        request
      }) {
        const { stream } = await connection.newStream([multicodec.relay]);
        log("starting stop request to %s", connection.remotePeer.toB58String());
        const streamHandler = new StreamHandler({ stream });
        streamHandler.write(request);
        const response = await streamHandler.read();
        if (!response) {
          return streamHandler.close();
        }
        if (response.code === CircuitPB.Status.SUCCESS) {
          log("stop request to %s was successful", connection.remotePeer.toB58String());
          return streamHandler.rest();
        }
        log("stop request failed with code %d", response.code);
        streamHandler.close();
      };
    }
  });

  // node_modules/libp2p/src/circuit/circuit/hop.js
  var require_hop = __commonJS({
    "node_modules/libp2p/src/circuit/circuit/hop.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:circuit:hop"), {
        error: debug("libp2p:circuit:hop:err")
      });
      var errCode = require_err_code();
      var PeerId2 = require_src8();
      var { validateAddrs } = require_utils5();
      var StreamHandler = require_stream_handler();
      var { CircuitRelay: CircuitPB } = require_protocol();
      var { pipe } = require_it_pipe2();
      var { codes: Errors } = require_errors2();
      var { stop } = require_stop();
      var multicodec = require_multicodec();
      async function handleHop({
        connection,
        request,
        streamHandler,
        circuit
      }) {
        if (!circuit._options.hop.enabled) {
          log("HOP request received but we are not acting as a relay");
          return streamHandler.end({
            type: CircuitPB.Type.STATUS,
            code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY
          });
        }
        try {
          validateAddrs(request, streamHandler);
        } catch (err) {
          return log.error("invalid hop request via peer %s", connection.remotePeer.toB58String(), err);
        }
        if (!request.dstPeer) {
          log("HOP request received but we do not receive a dstPeer");
          return;
        }
        const destinationPeer = new PeerId2(request.dstPeer.id);
        const destinationConnection = circuit._connectionManager.get(destinationPeer);
        if (!destinationConnection && !circuit._options.hop.active) {
          log("HOP request received but we are not connected to the destination peer");
          return streamHandler.end({
            type: CircuitPB.Type.STATUS,
            code: CircuitPB.Status.HOP_NO_CONN_TO_DST
          });
        }
        if (!destinationConnection) {
          return;
        }
        const stopRequest = {
          type: CircuitPB.Type.STOP,
          dstPeer: request.dstPeer,
          srcPeer: request.srcPeer
        };
        let destinationStream;
        try {
          destinationStream = await stop({
            connection: destinationConnection,
            request: stopRequest
          });
        } catch (err) {
          return log.error(err);
        }
        log("hop request from %s is valid", connection.remotePeer.toB58String());
        streamHandler.write({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.SUCCESS
        });
        const sourceStream = streamHandler.rest();
        return pipe(sourceStream, destinationStream, sourceStream);
      }
      async function hop({
        connection,
        request
      }) {
        const { stream } = await connection.newStream([multicodec.relay]);
        const streamHandler = new StreamHandler({ stream });
        streamHandler.write(request);
        const response = await streamHandler.read();
        if (!response) {
          throw errCode(new Error("HOP request had no response"), Errors.ERR_HOP_REQUEST_FAILED);
        }
        if (response.code === CircuitPB.Status.SUCCESS) {
          log("hop request was successful");
          return streamHandler.rest();
        }
        log("hop request failed with code %d, closing stream", response.code);
        streamHandler.close();
        throw errCode(new Error(`HOP request failed with code ${response.code}`), Errors.ERR_HOP_REQUEST_FAILED);
      }
      async function canHop({
        connection
      }) {
        const { stream } = await connection.newStream([multicodec.relay]);
        const streamHandler = new StreamHandler({ stream });
        streamHandler.write({
          type: CircuitPB.Type.CAN_HOP
        });
        const response = await streamHandler.read();
        await streamHandler.close();
        if (!response || response.code !== CircuitPB.Status.SUCCESS) {
          return false;
        }
        return true;
      }
      function handleCanHop({
        connection,
        streamHandler,
        circuit
      }) {
        const canHop2 = circuit._options.hop.enabled;
        log("can hop (%s) request from %s", canHop2, connection.remotePeer.toB58String());
        streamHandler.end({
          type: CircuitPB.Type.STATUS,
          code: canHop2 ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY
        });
      }
      module2.exports = {
        handleHop,
        hop,
        canHop,
        handleCanHop
      };
    }
  });

  // node_modules/libp2p/src/circuit/transport.js
  var require_transport = __commonJS({
    "node_modules/libp2p/src/circuit/transport.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:circuit"), {
        error: debug("libp2p:circuit:err")
      });
      var errCode = require_err_code();
      var mafmt = require_src2();
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var { CircuitRelay: CircuitPB } = require_protocol();
      var { codes } = require_errors2();
      var toConnection = require_stream_to_ma_conn();
      var { relay: multicodec } = require_multicodec();
      var createListener = require_listener();
      var { handleCanHop, handleHop, hop } = require_hop();
      var { handleStop } = require_stop();
      var StreamHandler = require_stream_handler();
      var transportSymbol = Symbol.for("@libp2p/js-libp2p-circuit/circuit");
      var Circuit = class {
        constructor({ libp2p, upgrader }) {
          this._dialer = libp2p.dialer;
          this._registrar = libp2p.registrar;
          this._connectionManager = libp2p.connectionManager;
          this._upgrader = upgrader;
          this._options = libp2p._config.relay;
          this._libp2p = libp2p;
          this.peerId = libp2p.peerId;
          this._registrar.handle(multicodec, this._onProtocol.bind(this));
        }
        async _onProtocol({ connection, stream }) {
          const streamHandler = new StreamHandler({ stream });
          const request = await streamHandler.read();
          if (!request) {
            return;
          }
          const circuit = this;
          let virtualConnection;
          switch (request.type) {
            case CircuitPB.Type.CAN_HOP: {
              log("received CAN_HOP request from %s", connection.remotePeer.toB58String());
              await handleCanHop({ circuit, connection, streamHandler });
              break;
            }
            case CircuitPB.Type.HOP: {
              log("received HOP request from %s", connection.remotePeer.toB58String());
              virtualConnection = await handleHop({
                connection,
                request,
                streamHandler,
                circuit
              });
              break;
            }
            case CircuitPB.Type.STOP: {
              log("received STOP request from %s", connection.remotePeer.toB58String());
              virtualConnection = await handleStop({
                connection,
                request,
                streamHandler
              });
              break;
            }
            default: {
              log("Request of type %s not supported", request.type);
            }
          }
          if (virtualConnection) {
            const remoteAddr = new Multiaddr2(request.dstPeer.addrs[0]);
            const localAddr = new Multiaddr2(request.srcPeer.addrs[0]);
            const maConn = toConnection({
              stream: virtualConnection,
              remoteAddr,
              localAddr
            });
            const type = request.type === CircuitPB.Type.HOP ? "relay" : "inbound";
            log("new %s connection %s", type, maConn.remoteAddr);
            const conn = await this._upgrader.upgradeInbound(maConn);
            log("%s connection %s upgraded", type, maConn.remoteAddr);
            this.handler && this.handler(conn);
          }
        }
        async dial(ma, options) {
          const addrs = ma.toString().split("/p2p-circuit");
          const relayAddr = new Multiaddr2(addrs[0]);
          const destinationAddr = new Multiaddr2(addrs[addrs.length - 1]);
          const relayId = relayAddr.getPeerId();
          const destinationId = destinationAddr.getPeerId();
          if (!relayId || !destinationId) {
            const errMsg = "Circuit relay dial failed as addresses did not have peer id";
            log.error(errMsg);
            throw errCode(new Error(errMsg), codes.ERR_RELAYED_DIAL);
          }
          const relayPeer = PeerId2.createFromB58String(relayId);
          const destinationPeer = PeerId2.createFromB58String(destinationId);
          let disconnectOnFailure = false;
          let relayConnection = this._connectionManager.get(relayPeer);
          if (!relayConnection) {
            relayConnection = await this._dialer.connectToPeer(relayAddr, options);
            disconnectOnFailure = true;
          }
          try {
            const virtualConnection = await hop({
              connection: relayConnection,
              request: {
                type: CircuitPB.Type.HOP,
                srcPeer: {
                  id: this.peerId.toBytes(),
                  addrs: this._libp2p.multiaddrs.map((addr) => addr.bytes)
                },
                dstPeer: {
                  id: destinationPeer.toBytes(),
                  addrs: [new Multiaddr2(destinationAddr).bytes]
                }
              }
            });
            const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`);
            const maConn = toConnection({
              stream: virtualConnection,
              remoteAddr: ma,
              localAddr
            });
            log("new outbound connection %s", maConn.remoteAddr);
            return this._upgrader.upgradeOutbound(maConn);
          } catch (err) {
            log.error("Circuit relay dial failed", err);
            disconnectOnFailure && await relayConnection.close();
            throw err;
          }
        }
        createListener(options, handler) {
          if (typeof options === "function") {
            handler = options;
            options = {};
          }
          this.handler = handler;
          return createListener(this._libp2p);
        }
        filter(multiaddrs) {
          multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
          return multiaddrs.filter((ma) => {
            return mafmt.Circuit.matches(ma);
          });
        }
        get [Symbol.toStringTag]() {
          return "Circuit";
        }
        static isTransport(other) {
          return Boolean(other && other[transportSymbol]);
        }
      };
      module2.exports = Circuit;
    }
  });

  // node_modules/libp2p/src/circuit/utils.js
  var require_utils6 = __commonJS({
    "node_modules/libp2p/src/circuit/utils.js"(exports2, module2) {
      "use strict";
      var { CID: CID2 } = (init_cid(), cid_exports);
      var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
      module2.exports.namespaceToCid = async (namespace) => {
        const bytes = new TextEncoder().encode(namespace);
        const hash = await sha2562.digest(bytes);
        return CID2.createV0(hash);
      };
    }
  });

  // node_modules/libp2p/src/circuit/auto-relay.js
  var require_auto_relay = __commonJS({
    "node_modules/libp2p/src/circuit/auto-relay.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:auto-relay"), {
        error: debug("libp2p:auto-relay:err")
      });
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var { relay: multicodec } = require_multicodec();
      var { canHop } = require_hop();
      var { namespaceToCid } = require_utils6();
      var {
        CIRCUIT_PROTO_CODE,
        HOP_METADATA_KEY,
        HOP_METADATA_VALUE,
        RELAY_RENDEZVOUS_NS
      } = require_constants6();
      var AutoRelay = class {
        constructor({ libp2p, maxListeners = 1, onError }) {
          this._libp2p = libp2p;
          this._peerId = libp2p.peerId;
          this._peerStore = libp2p.peerStore;
          this._connectionManager = libp2p.connectionManager;
          this._transportManager = libp2p.transportManager;
          this._addressSorter = libp2p.dialer.addressSorter;
          this.maxListeners = maxListeners;
          this._listenRelays = /* @__PURE__ */ new Set();
          this._onProtocolChange = this._onProtocolChange.bind(this);
          this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
          this._peerStore.on("change:protocols", this._onProtocolChange);
          this._connectionManager.on("peer:disconnect", this._onPeerDisconnected);
          this._onError = (error, msg) => {
            log.error(msg || error);
            onError && onError(error, msg);
          };
        }
        async _onProtocolChange({ peerId, protocols }) {
          const id = peerId.toB58String();
          const hasProtocol = protocols.find((protocol) => protocol === multicodec);
          if (!hasProtocol && this._listenRelays.has(id)) {
            this._removeListenRelay(id);
            return;
          } else if (!hasProtocol || this._listenRelays.has(id)) {
            return;
          }
          try {
            const connection = this._connectionManager.get(peerId);
            if (!connection) {
              return;
            }
            if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
              log(`relayed connection to ${id} will not be used to hop on`);
              return;
            }
            const supportsHop = await canHop({ connection });
            if (supportsHop) {
              this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));
              await this._addListenRelay(connection, id);
            }
          } catch (err) {
            this._onError(err);
          }
        }
        _onPeerDisconnected(connection) {
          const peerId = connection.remotePeer;
          const id = peerId.toB58String();
          if (!this._listenRelays.has(id)) {
            return;
          }
          this._removeListenRelay(id);
        }
        async _addListenRelay(connection, id) {
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
          const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);
          if (!remoteAddrs || !remoteAddrs.length) {
            return;
          }
          const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`;
          this._listenRelays.add(id);
          try {
            await this._transportManager.listen([new Multiaddr2(listenAddr)]);
          } catch (err) {
            this._onError(err);
            this._listenRelays.delete(id);
          }
        }
        _removeListenRelay(id) {
          if (this._listenRelays.delete(id)) {
            this._listenOnAvailableHopRelays([id]);
          }
        }
        async _listenOnAvailableHopRelays(peersToIgnore = []) {
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
          const knownHopsToDial = [];
          for (const [id, metadataMap] of this._peerStore.metadataBook.data.entries()) {
            if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {
              continue;
            }
            const supportsHop = metadataMap.get(HOP_METADATA_KEY);
            if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {
              continue;
            }
            const peerId = PeerId2.createFromB58String(id);
            const connection = this._connectionManager.get(peerId);
            if (!connection) {
              knownHopsToDial.push(peerId);
              continue;
            }
            await this._addListenRelay(connection, id);
            if (this._listenRelays.size >= this.maxListeners) {
              return;
            }
          }
          for (const peerId of knownHopsToDial) {
            await this._tryToListenOnRelay(peerId);
            if (this._listenRelays.size >= this.maxListeners) {
              return;
            }
          }
          try {
            const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
            for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {
              if (!provider.multiaddrs.length) {
                continue;
              }
              const peerId = provider.id;
              this._peerStore.addressBook.add(peerId, provider.multiaddrs);
              await this._tryToListenOnRelay(peerId);
              if (this._listenRelays.size >= this.maxListeners) {
                return;
              }
            }
          } catch (err) {
            this._onError(err);
          }
        }
        async _tryToListenOnRelay(peerId) {
          try {
            const connection = await this._libp2p.dial(peerId);
            await this._addListenRelay(connection, peerId.toB58String());
          } catch (err) {
            this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`);
          }
        }
      };
      module2.exports = AutoRelay;
    }
  });

  // node_modules/libp2p/src/circuit/index.js
  var require_circuit = __commonJS({
    "node_modules/libp2p/src/circuit/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:relay"), {
        error: debug("libp2p:relay:err")
      });
      var {
        setDelayedInterval,
        clearDelayedInterval
      } = require_src11();
      var AutoRelay = require_auto_relay();
      var { namespaceToCid } = require_utils6();
      var {
        RELAY_RENDEZVOUS_NS
      } = require_constants6();
      var Relay = class {
        constructor(libp2p) {
          this._libp2p = libp2p;
          this._options = {
            ...libp2p._config.relay
          };
          this._autoRelay = this._options.autoRelay.enabled && new AutoRelay({ libp2p, ...this._options.autoRelay });
          this._advertiseService = this._advertiseService.bind(this);
        }
        start() {
          const canHop = this._options.hop.enabled;
          if (canHop && this._options.advertise.enabled) {
            this._timeout = setDelayedInterval(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay);
          }
        }
        stop() {
          clearDelayedInterval(this._timeout);
        }
        async _advertiseService() {
          try {
            const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
            await this._libp2p.contentRouting.provide(cid);
          } catch (err) {
            if (err.code === "NO_ROUTERS_AVAILABLE") {
              log.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
              this.stop();
            } else {
              log.error(err);
            }
          }
        }
      };
      module2.exports = Relay;
    }
  });

  // node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js
  var require_time_browser2 = __commonJS({
    "node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js"(exports2, module2) {
      "use strict";
      module2.exports = function getTime() {
        return Date.now();
      };
    }
  });

  // node_modules/timeout-abort-controller/node_modules/retimer/retimer.js
  var require_retimer2 = __commonJS({
    "node_modules/timeout-abort-controller/node_modules/retimer/retimer.js"(exports2, module2) {
      "use strict";
      var getTime = require_time_browser2();
      function Retimer(callback, timeout, args) {
        var that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._timer = setTimeout(timerWrapper, timeout);
        function timerWrapper() {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._timer = setTimeout(timerWrapper, that._scheduled);
            that._rescheduled = 0;
          } else {
            callback.apply(null, that._args);
          }
        }
      }
      Retimer.prototype.reschedule = function(timeout) {
        var now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          return false;
        } else {
          this._started = now;
          this._rescheduled = timeout;
          return true;
        }
      };
      Retimer.prototype.clear = function() {
        clearTimeout(this._timer);
      };
      function retimer() {
        if (typeof arguments[0] !== "function") {
          throw new Error("callback needed");
        }
        if (typeof arguments[1] !== "number") {
          throw new Error("timeout needed");
        }
        var args;
        if (arguments.length > 0) {
          args = new Array(arguments.length - 2);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 2];
          }
        }
        return new Retimer(arguments[0], arguments[1], args);
      }
      module2.exports = retimer;
    }
  });

  // node_modules/timeout-abort-controller/index.js
  var require_timeout_abort_controller = __commonJS({
    "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
      "use strict";
      var { AbortController } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : require_browser4();
      var retimer = require_retimer2();
      var TimeoutController = class extends AbortController {
        constructor(ms) {
          super();
          this._ms = ms;
          this._timer = retimer(() => this.abort(), ms);
          Object.setPrototypeOf(this, TimeoutController.prototype);
        }
        abort() {
          this._timer.clear();
          return super.abort();
        }
        clear() {
          this._timer.clear();
        }
        reset() {
          this._timer.clear();
          this._timer = retimer(() => this.abort(), this._ms);
        }
      };
      module2.exports = TimeoutController;
      module2.exports.TimeoutController = TimeoutController;
    }
  });

  // node_modules/native-abort-controller/src/index.js
  var require_src16 = __commonJS({
    "node_modules/native-abort-controller/src/index.js"(exports2, module2) {
      "use strict";
      var impl;
      if (globalThis.AbortController && globalThis.AbortSignal) {
        impl = globalThis;
      } else {
        impl = require_browser4();
      }
      module2.exports.AbortSignal = impl.AbortSignal;
      module2.exports.AbortController = impl.AbortController;
    }
  });

  // node_modules/any-signal/index.js
  var require_any_signal = __commonJS({
    "node_modules/any-signal/index.js"(exports2, module2) {
      var { AbortController } = require_src16();
      function anySignal(signals) {
        const controller = new AbortController();
        function onAbort() {
          controller.abort();
          for (const signal of signals) {
            if (!signal || !signal.removeEventListener)
              continue;
            signal.removeEventListener("abort", onAbort);
          }
        }
        for (const signal of signals) {
          if (!signal || !signal.addEventListener)
            continue;
          if (signal.aborted) {
            onAbort();
            break;
          }
          signal.addEventListener("abort", onAbort);
        }
        return controller.signal;
      }
      module2.exports = anySignal;
      module2.exports.anySignal = anySignal;
    }
  });

  // node_modules/p-fifo/index.js
  var require_p_fifo = __commonJS({
    "node_modules/p-fifo/index.js"(exports2, module2) {
      var Fifo = require_fast_fifo2();
      var defer = require_p_defer();
      module2.exports = class PFifo {
        constructor() {
          this._buffer = new Fifo();
          this._waitingConsumers = new Fifo();
        }
        push(chunk) {
          const { promise, resolve } = defer();
          this._buffer.push({ chunk, resolve });
          this._consume();
          return promise;
        }
        _consume() {
          while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
            const nextConsumer = this._waitingConsumers.shift();
            const nextChunk = this._buffer.shift();
            nextConsumer.resolve(nextChunk.chunk);
            nextChunk.resolve();
          }
        }
        shift() {
          const { promise, resolve } = defer();
          this._waitingConsumers.push({ resolve });
          this._consume();
          return promise;
        }
        isEmpty() {
          return this._buffer.isEmpty();
        }
      };
    }
  });

  // node_modules/indent-string/index.js
  var require_indent_string = __commonJS({
    "node_modules/indent-string/index.js"(exports2, module2) {
      "use strict";
      module2.exports = (string2, count = 1, options) => {
        options = {
          indent: " ",
          includeEmptyLines: false,
          ...options
        };
        if (typeof string2 !== "string") {
          throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string2}\``);
        }
        if (typeof count !== "number") {
          throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
        }
        if (typeof options.indent !== "string") {
          throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
        }
        if (count === 0) {
          return string2;
        }
        const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
        return string2.replace(regex, options.indent.repeat(count));
      };
    }
  });

  // (disabled):os
  var require_os = __commonJS({
    "(disabled):os"() {
    }
  });

  // node_modules/clean-stack/index.js
  var require_clean_stack = __commonJS({
    "node_modules/clean-stack/index.js"(exports2, module2) {
      "use strict";
      var os = require_os();
      var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
      var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
      var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
      module2.exports = (stack, options) => {
        options = Object.assign({ pretty: false }, options);
        return stack.replace(/\\/g, "/").split("\n").filter((line) => {
          const pathMatches = line.match(extractPathRegex);
          if (pathMatches === null || !pathMatches[1]) {
            return true;
          }
          const match = pathMatches[1];
          if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
            return false;
          }
          return !pathRegex.test(match);
        }).filter((line) => line.trim() !== "").map((line) => {
          if (options.pretty) {
            return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
          }
          return line;
        }).join("\n");
      };
    }
  });

  // node_modules/aggregate-error/index.js
  var require_aggregate_error = __commonJS({
    "node_modules/aggregate-error/index.js"(exports2, module2) {
      "use strict";
      var indentString = require_indent_string();
      var cleanStack = require_clean_stack();
      var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
      var AggregateError = class extends Error {
        constructor(errors) {
          if (!Array.isArray(errors)) {
            throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
          }
          errors = [...errors].map((error) => {
            if (error instanceof Error) {
              return error;
            }
            if (error !== null && typeof error === "object") {
              return Object.assign(new Error(error.message), error);
            }
            return new Error(error);
          });
          let message = errors.map((error) => {
            return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
          }).join("\n");
          message = "\n" + indentString(message, 4);
          super(message);
          this.name = "AggregateError";
          Object.defineProperty(this, "_errors", { value: errors });
        }
        *[Symbol.iterator]() {
          for (const error of this._errors) {
            yield error;
          }
        }
      };
      module2.exports = AggregateError;
    }
  });

  // node_modules/p-cancelable/index.js
  var require_p_cancelable = __commonJS({
    "node_modules/p-cancelable/index.js"(exports2, module2) {
      "use strict";
      var CancelError = class extends Error {
        constructor(reason) {
          super(reason || "Promise was canceled");
          this.name = "CancelError";
        }
        get isCanceled() {
          return true;
        }
      };
      var PCancelable = class {
        static fn(userFn) {
          return (...arguments_) => {
            return new PCancelable((resolve, reject, onCancel) => {
              arguments_.push(onCancel);
              userFn(...arguments_).then(resolve, reject);
            });
          };
        }
        constructor(executor) {
          this._cancelHandlers = [];
          this._isPending = true;
          this._isCanceled = false;
          this._rejectOnCancel = true;
          this._promise = new Promise((resolve, reject) => {
            this._reject = reject;
            const onResolve = (value) => {
              if (!this._isCanceled || !onCancel.shouldReject) {
                this._isPending = false;
                resolve(value);
              }
            };
            const onReject = (error) => {
              this._isPending = false;
              reject(error);
            };
            const onCancel = (handler) => {
              if (!this._isPending) {
                throw new Error("The `onCancel` handler was attached after the promise settled.");
              }
              this._cancelHandlers.push(handler);
            };
            Object.defineProperties(onCancel, {
              shouldReject: {
                get: () => this._rejectOnCancel,
                set: (boolean) => {
                  this._rejectOnCancel = boolean;
                }
              }
            });
            return executor(onResolve, onReject, onCancel);
          });
        }
        then(onFulfilled, onRejected) {
          return this._promise.then(onFulfilled, onRejected);
        }
        catch(onRejected) {
          return this._promise.catch(onRejected);
        }
        finally(onFinally) {
          return this._promise.finally(onFinally);
        }
        cancel(reason) {
          if (!this._isPending || this._isCanceled) {
            return;
          }
          this._isCanceled = true;
          if (this._cancelHandlers.length > 0) {
            try {
              for (const handler of this._cancelHandlers) {
                handler();
              }
            } catch (error) {
              this._reject(error);
              return;
            }
          }
          if (this._rejectOnCancel) {
            this._reject(new CancelError(reason));
          }
        }
        get isCanceled() {
          return this._isCanceled;
        }
      };
      Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
      module2.exports = PCancelable;
      module2.exports.CancelError = CancelError;
    }
  });

  // node_modules/p-some/index.js
  var require_p_some = __commonJS({
    "node_modules/p-some/index.js"(exports2, module2) {
      "use strict";
      var AggregateError = require_aggregate_error();
      var PCancelable = require_p_cancelable();
      var FilterError = class extends Error {
      };
      var pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {
        const {
          count,
          filter = () => true
        } = options;
        if (!Number.isFinite(count)) {
          reject(new TypeError(`Expected a finite number, got ${typeof options.count}`));
          return;
        }
        const values = [];
        const errors = [];
        let elementCount = 0;
        let isSettled = false;
        const completed = /* @__PURE__ */ new Set();
        const maybeSettle = () => {
          if (values.length === count) {
            resolve(values);
            isSettled = true;
          }
          if (elementCount - errors.length < count) {
            reject(new AggregateError(errors));
            isSettled = true;
          }
          return isSettled;
        };
        const cancelPending = () => {
          for (const promise of iterable) {
            if (!completed.has(promise) && typeof promise.cancel === "function") {
              promise.cancel();
            }
          }
        };
        onCancel(cancelPending);
        for (const element of iterable) {
          elementCount++;
          (async () => {
            try {
              const value = await element;
              if (isSettled) {
                return;
              }
              if (!filter(value)) {
                throw new FilterError("Value does not satisfy filter");
              }
              values.push(value);
            } catch (error) {
              errors.push(error);
            } finally {
              completed.add(element);
              if (!isSettled && maybeSettle()) {
                cancelPending();
              }
            }
          })();
        }
        if (count > elementCount) {
          reject(new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`));
          cancelPending();
        }
      });
      module2.exports = pSome;
      module2.exports.AggregateError = AggregateError;
      module2.exports.FilterError = FilterError;
    }
  });

  // node_modules/p-any/index.js
  var require_p_any = __commonJS({
    "node_modules/p-any/index.js"(exports2, module2) {
      "use strict";
      var pSome = require_p_some();
      var PCancelable = require_p_cancelable();
      module2.exports = (iterable, options) => {
        const anyCancelable = pSome(iterable, { ...options, count: 1 });
        return PCancelable.fn(async (onCancel) => {
          onCancel(() => {
            anyCancelable.cancel();
          });
          const [value] = await anyCancelable;
          return value;
        })();
      };
      module2.exports.AggregateError = pSome.AggregateError;
    }
  });

  // node_modules/libp2p/src/dialer/dial-request.js
  var require_dial_request = __commonJS({
    "node_modules/libp2p/src/dialer/dial-request.js"(exports2, module2) {
      "use strict";
      var errCode = require_err_code();
      var AbortController = require_browser4().default;
      var { anySignal } = require_any_signal();
      var FIFO = require_p_fifo();
      var pAny = require_p_any();
      var DialRequest = class {
        constructor({
          addrs,
          dialAction,
          dialer
        }) {
          this.addrs = addrs;
          this.dialer = dialer;
          this.dialAction = dialAction;
        }
        async run(options = {}) {
          const tokens = this.dialer.getTokens(this.addrs.length);
          if (tokens.length < 1) {
            throw errCode(new Error("No dial tokens available"), "ERR_NO_DIAL_TOKENS");
          }
          const tokenHolder = new FIFO();
          tokens.forEach((token) => tokenHolder.push(token));
          const dialAbortControllers = this.addrs.map(() => new AbortController());
          let completedDials = 0;
          try {
            return await pAny(this.addrs.map(async (addr, i) => {
              const token = await tokenHolder.shift();
              let conn;
              try {
                const signal = dialAbortControllers[i].signal;
                conn = await this.dialAction(addr, { ...options, signal: options.signal ? anySignal([signal, options.signal]) : signal });
                dialAbortControllers.splice(i, 1);
              } finally {
                completedDials++;
                if (this.addrs.length - completedDials >= tokens.length) {
                  tokenHolder.push(token);
                } else {
                  this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
                }
              }
              return conn;
            }));
          } finally {
            dialAbortControllers.map((c) => c.abort());
            tokens.forEach((token) => this.dialer.releaseToken(token));
          }
        }
      };
      module2.exports = DialRequest;
    }
  });

  // node_modules/libp2p/src/dialer/index.js
  var require_dialer = __commonJS({
    "node_modules/libp2p/src/dialer/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:dialer"), {
        error: debug("libp2p:dialer:err")
      });
      var errCode = require_err_code();
      var { Multiaddr: Multiaddr2 } = require_src();
      var TimeoutController = require_timeout_abort_controller();
      var { AbortError } = require_abortable_iterator();
      var { anySignal } = require_any_signal();
      var DialRequest = require_dial_request();
      var { publicAddressesFirst } = require_address_sort();
      var getPeer = require_get_peer();
      var { codes } = require_errors2();
      var {
        DIAL_TIMEOUT,
        MAX_PARALLEL_DIALS,
        MAX_PER_PEER_DIALS,
        MAX_ADDRS_TO_DIAL
      } = require_constants5();
      var Dialer = class {
        constructor({
          transportManager,
          peerStore,
          addressSorter = publicAddressesFirst,
          maxParallelDials = MAX_PARALLEL_DIALS,
          maxAddrsToDial = MAX_ADDRS_TO_DIAL,
          dialTimeout = DIAL_TIMEOUT,
          maxDialsPerPeer = MAX_PER_PEER_DIALS,
          resolvers = {}
        }) {
          this.transportManager = transportManager;
          this.peerStore = peerStore;
          this.addressSorter = addressSorter;
          this.maxParallelDials = maxParallelDials;
          this.maxAddrsToDial = maxAddrsToDial;
          this.timeout = dialTimeout;
          this.maxDialsPerPeer = maxDialsPerPeer;
          this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);
          this._pendingDials = /* @__PURE__ */ new Map();
          this._pendingDialTargets = /* @__PURE__ */ new Map();
          for (const [key, value] of Object.entries(resolvers)) {
            Multiaddr2.resolvers.set(key, value);
          }
        }
        destroy() {
          for (const dial of this._pendingDials.values()) {
            try {
              dial.controller.abort();
            } catch (err) {
              log.error(err);
            }
          }
          this._pendingDials.clear();
          for (const pendingTarget of this._pendingDialTargets.values()) {
            pendingTarget.reject(new AbortError("Dialer was destroyed"));
          }
          this._pendingDialTargets.clear();
        }
        async connectToPeer(peer, options = {}) {
          const dialTarget = await this._createCancellableDialTarget(peer);
          if (!dialTarget.addrs.length) {
            throw errCode(new Error("The dial request has no valid addresses"), codes.ERR_NO_VALID_ADDRESSES);
          }
          const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);
          try {
            const connection = await pendingDial.promise;
            log("dial succeeded to %s", dialTarget.id);
            return connection;
          } catch (err) {
            if (pendingDial.controller.signal.aborted) {
              err.code = codes.ERR_TIMEOUT;
            }
            log.error(err);
            throw err;
          } finally {
            pendingDial.destroy();
          }
        }
        async _createCancellableDialTarget(peer) {
          const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;
          const cancellablePromise = new Promise((resolve, reject) => {
            this._pendingDialTargets.set(id, { resolve, reject });
          });
          const dialTarget = await Promise.race([
            this._createDialTarget(peer),
            cancellablePromise
          ]);
          this._pendingDialTargets.delete(id);
          return dialTarget;
        }
        async _createDialTarget(peer) {
          const { id, multiaddrs } = getPeer(peer);
          if (multiaddrs) {
            this.peerStore.addressBook.add(id, multiaddrs);
          }
          let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || [];
          if (Multiaddr2.isMultiaddr(peer)) {
            knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr));
            knownAddrs.unshift(peer);
          }
          const addrs = [];
          for (const a of knownAddrs) {
            const resolvedAddrs = await this._resolve(a);
            resolvedAddrs.forEach((ra) => addrs.push(ra));
          }
          const supportedAddrs = addrs.filter((a) => this.transportManager.transportForMultiaddr(a));
          if (supportedAddrs.length > this.maxAddrsToDial) {
            this.peerStore.delete(id);
            throw errCode(new Error("dial with more addresses than allowed"), codes.ERR_TOO_MANY_ADDRESSES);
          }
          return {
            id: id.toB58String(),
            addrs: supportedAddrs
          };
        }
        _createPendingDial(dialTarget, options = {}) {
          const dialAction = (addr, options2) => {
            if (options2.signal.aborted)
              throw errCode(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
            return this.transportManager.dial(addr, options2);
          };
          const dialRequest = new DialRequest({
            addrs: dialTarget.addrs,
            dialAction,
            dialer: this
          });
          const timeoutController = new TimeoutController(this.timeout);
          const signals = [timeoutController.signal];
          options.signal && signals.push(options.signal);
          const signal = anySignal(signals);
          const pendingDial = {
            dialRequest,
            controller: timeoutController,
            promise: dialRequest.run({ ...options, signal }),
            destroy: () => {
              timeoutController.clear();
              this._pendingDials.delete(dialTarget.id);
            }
          };
          this._pendingDials.set(dialTarget.id, pendingDial);
          return pendingDial;
        }
        getTokens(num) {
          const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
          const tokens = this.tokens.splice(0, total);
          log("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
          return tokens;
        }
        releaseToken(token) {
          if (this.tokens.indexOf(token) > -1)
            return;
          log("token %d released", token);
          this.tokens.push(token);
        }
        async _resolve(ma) {
          const resolvableProto = ma.protoNames().includes("dnsaddr");
          if (!resolvableProto) {
            return [ma];
          }
          const resolvedMultiaddrs = await this._resolveRecord(ma);
          const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {
            return this._resolve(nm);
          }));
          const addrs = recursiveMultiaddrs.flat();
          return addrs.reduce((array, newM) => {
            if (!array.find((m) => m.equals(newM))) {
              array.push(newM);
            }
            return array;
          }, []);
        }
        async _resolveRecord(ma) {
          try {
            ma = new Multiaddr2(ma.toString());
            const multiaddrs = await ma.resolve();
            return multiaddrs;
          } catch (_) {
            log.error(`multiaddr ${ma} could not be resolved`);
            return [];
          }
        }
      };
      module2.exports = Dialer;
    }
  });

  // node_modules/truncate-utf8-bytes/lib/truncate.js
  var require_truncate = __commonJS({
    "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
      "use strict";
      function isHighSurrogate(codePoint) {
        return codePoint >= 55296 && codePoint <= 56319;
      }
      function isLowSurrogate(codePoint) {
        return codePoint >= 56320 && codePoint <= 57343;
      }
      module2.exports = function truncate(getLength, string2, byteLength) {
        if (typeof string2 !== "string") {
          throw new Error("Input must be string");
        }
        var charLength = string2.length;
        var curByteLength = 0;
        var codePoint;
        var segment;
        for (var i = 0; i < charLength; i += 1) {
          codePoint = string2.charCodeAt(i);
          segment = string2[i];
          if (isHighSurrogate(codePoint) && isLowSurrogate(string2.charCodeAt(i + 1))) {
            i += 1;
            segment += string2[i];
          }
          curByteLength += getLength(segment);
          if (curByteLength === byteLength) {
            return string2.slice(0, i + 1);
          } else if (curByteLength > byteLength) {
            return string2.slice(0, i - segment.length + 1);
          }
        }
        return string2;
      };
    }
  });

  // node_modules/utf8-byte-length/browser.js
  var require_browser6 = __commonJS({
    "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
      "use strict";
      function isHighSurrogate(codePoint) {
        return codePoint >= 55296 && codePoint <= 56319;
      }
      function isLowSurrogate(codePoint) {
        return codePoint >= 56320 && codePoint <= 57343;
      }
      module2.exports = function getByteLength(string2) {
        if (typeof string2 !== "string") {
          throw new Error("Input must be string");
        }
        var charLength = string2.length;
        var byteLength = 0;
        var codePoint = null;
        var prevCodePoint = null;
        for (var i = 0; i < charLength; i++) {
          codePoint = string2.charCodeAt(i);
          if (isLowSurrogate(codePoint)) {
            if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
              byteLength += 1;
            } else {
              byteLength += 3;
            }
          } else if (codePoint <= 127) {
            byteLength += 1;
          } else if (codePoint >= 128 && codePoint <= 2047) {
            byteLength += 2;
          } else if (codePoint >= 2048 && codePoint <= 65535) {
            byteLength += 3;
          }
          prevCodePoint = codePoint;
        }
        return byteLength;
      };
    }
  });

  // node_modules/truncate-utf8-bytes/browser.js
  var require_browser7 = __commonJS({
    "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
      "use strict";
      var truncate = require_truncate();
      var getLength = require_browser6();
      module2.exports = truncate.bind(null, getLength);
    }
  });

  // node_modules/sanitize-filename/index.js
  var require_sanitize_filename = __commonJS({
    "node_modules/sanitize-filename/index.js"(exports2, module2) {
      "use strict";
      var truncate = require_browser7();
      var illegalRe = /[\/\?<>\\:\*\|"]/g;
      var controlRe = /[\x00-\x1f\x80-\x9f]/g;
      var reservedRe = /^\.+$/;
      var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
      var windowsTrailingRe = /[\. ]+$/;
      function sanitize(input, replacement) {
        if (typeof input !== "string") {
          throw new Error("Input must be string");
        }
        var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
        return truncate(sanitized, 255);
      }
      module2.exports = function(input, options) {
        var replacement = options && options.replacement || "";
        var output = sanitize(input, replacement);
        if (replacement === "") {
          return output;
        }
        return sanitize(output, "");
      };
    }
  });

  // node_modules/nanoid/url-alphabet/index.js
  var init_url_alphabet = __esm({
    "node_modules/nanoid/url-alphabet/index.js"() {
    }
  });

  // node_modules/nanoid/index.prod.js
  var nanoid;
  var init_index_prod = __esm({
    "node_modules/nanoid/index.prod.js"() {
      init_url_alphabet();
      if (false) {
        if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
          throw new Error("React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID.");
        }
        if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
          throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");
        }
        if (typeof crypto === "undefined") {
          throw new Error("Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure.");
        }
      }
      nanoid = (size = 21) => {
        let id = "";
        let bytes = crypto.getRandomValues(new Uint8Array(size));
        while (size--) {
          let byte = bytes[size] & 63;
          if (byte < 36) {
            id += byte.toString(36);
          } else if (byte < 62) {
            id += (byte - 26).toString(36).toUpperCase();
          } else if (byte < 63) {
            id += "_";
          } else {
            id += "-";
          }
        }
        return id;
      };
    }
  });

  // node_modules/interface-datastore/esm/src/key.js
  var key_exports = {};
  __export(key_exports, {
    Key: () => Key
  });
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }
  var pathSepS, pathSepB, pathSep, Key;
  var init_key = __esm({
    "node_modules/interface-datastore/esm/src/key.js"() {
      init_index_prod();
      init_to_string();
      init_from_string();
      pathSepS = "/";
      pathSepB = new TextEncoder().encode(pathSepS);
      pathSep = pathSepB[0];
      Key = class {
        constructor(s, clean) {
          if (typeof s === "string") {
            this._buf = fromString2(s);
          } else if (s instanceof Uint8Array) {
            this._buf = s;
          } else {
            throw new Error("Invalid key, should be String of Uint8Array");
          }
          if (clean == null) {
            clean = true;
          }
          if (clean) {
            this.clean();
          }
          if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
            throw new Error("Invalid key");
          }
        }
        toString(encoding = "utf8") {
          return toString2(this._buf, encoding);
        }
        uint8Array() {
          return this._buf;
        }
        get [Symbol.toStringTag]() {
          return `Key(${this.toString()})`;
        }
        static withNamespaces(list) {
          return new Key(list.join(pathSepS));
        }
        static random() {
          return new Key(nanoid().replace(/-/g, ""));
        }
        static asKey(other) {
          if (other instanceof Uint8Array || typeof other === "string") {
            return new Key(other);
          }
          if (other.uint8Array) {
            return new Key(other.uint8Array());
          }
          return null;
        }
        clean() {
          if (!this._buf || this._buf.byteLength === 0) {
            this._buf = pathSepB;
          }
          if (this._buf[0] !== pathSep) {
            const bytes = new Uint8Array(this._buf.byteLength + 1);
            bytes.fill(pathSep, 0, 1);
            bytes.set(this._buf, 1);
            this._buf = bytes;
          }
          while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
            this._buf = this._buf.subarray(0, -1);
          }
        }
        less(key) {
          const list1 = this.list();
          const list2 = key.list();
          for (let i = 0; i < list1.length; i++) {
            if (list2.length < i + 1) {
              return false;
            }
            const c1 = list1[i];
            const c2 = list2[i];
            if (c1 < c2) {
              return true;
            } else if (c1 > c2) {
              return false;
            }
          }
          return list1.length < list2.length;
        }
        reverse() {
          return Key.withNamespaces(this.list().slice().reverse());
        }
        namespaces() {
          return this.list();
        }
        baseNamespace() {
          const ns = this.namespaces();
          return ns[ns.length - 1];
        }
        list() {
          return this.toString().split(pathSepS).slice(1);
        }
        type() {
          return namespaceType(this.baseNamespace());
        }
        name() {
          return namespaceValue(this.baseNamespace());
        }
        instance(s) {
          return new Key(this.toString() + ":" + s);
        }
        path() {
          let p = this.parent().toString();
          if (!p.endsWith(pathSepS)) {
            p += pathSepS;
          }
          p += this.type();
          return new Key(p);
        }
        parent() {
          const list = this.list();
          if (list.length === 1) {
            return new Key(pathSepS);
          }
          return new Key(list.slice(0, -1).join(pathSepS));
        }
        child(key) {
          if (this.toString() === pathSepS) {
            return key;
          } else if (key.toString() === pathSepS) {
            return this;
          }
          return new Key(this.toString() + key.toString(), false);
        }
        isAncestorOf(other) {
          if (other.toString() === this.toString()) {
            return false;
          }
          return other.toString().startsWith(this.toString());
        }
        isDecendantOf(other) {
          if (other.toString() === this.toString()) {
            return false;
          }
          return this.toString().startsWith(other.toString());
        }
        isTopLevel() {
          return this.list().length === 1;
        }
        concat(...keys) {
          return Key.withNamespaces([
            ...this.namespaces(),
            ...flatten(keys.map((key) => key.namespaces()))
          ]);
        }
      };
    }
  });

  // node_modules/node-forge/lib/pkcs7asn1.js
  var require_pkcs7asn1 = __commonJS({
    "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
      var forge = require_forge();
      require_asn1();
      require_util();
      var asn1 = forge.asn1;
      var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
      forge.pkcs7 = forge.pkcs7 || {};
      forge.pkcs7.asn1 = p7v;
      var contentInfoValidator = {
        name: "ContentInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "ContentInfo.ContentType",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "contentType"
        }, {
          name: "ContentInfo.content",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          captureAsn1: "content"
        }]
      };
      p7v.contentInfoValidator = contentInfoValidator;
      var encryptedContentInfoValidator = {
        name: "EncryptedContentInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentType",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "contentType"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encAlgorithm"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "EncryptedContentInfo.encryptedContent",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          capture: "encryptedContent",
          captureAsn1: "encryptedContentAsn1"
        }]
      };
      p7v.envelopedDataValidator = {
        name: "EnvelopedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EnvelopedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }, {
          name: "EnvelopedData.RecipientInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "recipientInfos"
        }].concat(encryptedContentInfoValidator)
      };
      p7v.encryptedDataValidator = {
        name: "EncryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }].concat(encryptedContentInfoValidator)
      };
      var signerValidator = {
        name: "SignerInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false
        }, {
          name: "SignerInfo.issuerAndSerialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.issuerAndSerialNumber.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer"
          }, {
            name: "SignerInfo.issuerAndSerialNumber.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "serial"
          }]
        }, {
          name: "SignerInfo.digestAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.digestAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "digestAlgorithm"
          }, {
            name: "SignerInfo.digestAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "digestParameter",
            optional: true
          }]
        }, {
          name: "SignerInfo.authenticatedAttributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "authenticatedAttributes"
        }, {
          name: "SignerInfo.digestEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          capture: "signatureAlgorithm"
        }, {
          name: "SignerInfo.encryptedDigest",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "signature"
        }, {
          name: "SignerInfo.unauthenticatedAttributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          capture: "unauthenticatedAttributes"
        }]
      };
      p7v.signedDataValidator = {
        name: "SignedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "SignedData.Version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          },
          {
            name: "SignedData.DigestAlgorithms",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true,
            captureAsn1: "digestAlgorithms"
          },
          contentInfoValidator,
          {
            name: "SignedData.Certificates",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            optional: true,
            captureAsn1: "certificates"
          },
          {
            name: "SignedData.CertificateRevocationLists",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            optional: true,
            captureAsn1: "crls"
          },
          {
            name: "SignedData.SignerInfos",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            capture: "signerInfos",
            optional: true,
            value: [signerValidator]
          }
        ]
      };
      p7v.recipientInfoValidator = {
        name: "RecipientInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }, {
          name: "RecipientInfo.issuerAndSerial",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.issuerAndSerial.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer"
          }, {
            name: "RecipientInfo.issuerAndSerial.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "serial"
          }]
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encAlgorithm"
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "RecipientInfo.encryptedKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encKey"
        }]
      };
    }
  });

  // node_modules/node-forge/lib/mgf1.js
  var require_mgf1 = __commonJS({
    "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
      var forge = require_forge();
      require_util();
      forge.mgf = forge.mgf || {};
      var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
      mgf1.create = function(md) {
        var mgf = {
          generate: function(seed, maskLen) {
            var t = new forge.util.ByteBuffer();
            var len = Math.ceil(maskLen / md.digestLength);
            for (var i = 0; i < len; i++) {
              var c = new forge.util.ByteBuffer();
              c.putInt32(i);
              md.start();
              md.update(seed + c.getBytes());
              t.putBuffer(md.digest());
            }
            t.truncate(t.length() - maskLen);
            return t.getBytes();
          }
        };
        return mgf;
      };
    }
  });

  // node_modules/node-forge/lib/mgf.js
  var require_mgf = __commonJS({
    "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
      var forge = require_forge();
      require_mgf1();
      module2.exports = forge.mgf = forge.mgf || {};
      forge.mgf.mgf1 = forge.mgf1;
    }
  });

  // node_modules/node-forge/lib/pss.js
  var require_pss = __commonJS({
    "node_modules/node-forge/lib/pss.js"(exports2, module2) {
      var forge = require_forge();
      require_random2();
      require_util();
      var pss = module2.exports = forge.pss = forge.pss || {};
      pss.create = function(options) {
        if (arguments.length === 3) {
          options = {
            md: arguments[0],
            mgf: arguments[1],
            saltLength: arguments[2]
          };
        }
        var hash = options.md;
        var mgf = options.mgf;
        var hLen = hash.digestLength;
        var salt_ = options.salt || null;
        if (typeof salt_ === "string") {
          salt_ = forge.util.createBuffer(salt_);
        }
        var sLen;
        if ("saltLength" in options) {
          sLen = options.saltLength;
        } else if (salt_ !== null) {
          sLen = salt_.length();
        } else {
          throw new Error("Salt length not specified or specific salt not given.");
        }
        if (salt_ !== null && salt_.length() !== sLen) {
          throw new Error("Given salt length does not match length of given salt.");
        }
        var prng = options.prng || forge.random;
        var pssobj = {};
        pssobj.encode = function(md, modBits) {
          var i;
          var emBits = modBits - 1;
          var emLen = Math.ceil(emBits / 8);
          var mHash = md.digest().getBytes();
          if (emLen < hLen + sLen + 2) {
            throw new Error("Message is too long to encrypt.");
          }
          var salt;
          if (salt_ === null) {
            salt = prng.getBytesSync(sLen);
          } else {
            salt = salt_.bytes();
          }
          var m_ = new forge.util.ByteBuffer();
          m_.fillWithByte(0, 8);
          m_.putBytes(mHash);
          m_.putBytes(salt);
          hash.start();
          hash.update(m_.getBytes());
          var h = hash.digest().getBytes();
          var ps = new forge.util.ByteBuffer();
          ps.fillWithByte(0, emLen - sLen - hLen - 2);
          ps.putByte(1);
          ps.putBytes(salt);
          var db = ps.getBytes();
          var maskLen = emLen - hLen - 1;
          var dbMask = mgf.generate(h, maskLen);
          var maskedDB = "";
          for (i = 0; i < maskLen; i++) {
            maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
          }
          var mask = 65280 >> 8 * emLen - emBits & 255;
          maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
          return maskedDB + h + String.fromCharCode(188);
        };
        pssobj.verify = function(mHash, em, modBits) {
          var i;
          var emBits = modBits - 1;
          var emLen = Math.ceil(emBits / 8);
          em = em.substr(-emLen);
          if (emLen < hLen + sLen + 2) {
            throw new Error("Inconsistent parameters to PSS signature verification.");
          }
          if (em.charCodeAt(emLen - 1) !== 188) {
            throw new Error("Encoded message does not end in 0xBC.");
          }
          var maskLen = emLen - hLen - 1;
          var maskedDB = em.substr(0, maskLen);
          var h = em.substr(maskLen, hLen);
          var mask = 65280 >> 8 * emLen - emBits & 255;
          if ((maskedDB.charCodeAt(0) & mask) !== 0) {
            throw new Error("Bits beyond keysize not zero as expected.");
          }
          var dbMask = mgf.generate(h, maskLen);
          var db = "";
          for (i = 0; i < maskLen; i++) {
            db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
          }
          db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
          var checkLen = emLen - hLen - sLen - 2;
          for (i = 0; i < checkLen; i++) {
            if (db.charCodeAt(i) !== 0) {
              throw new Error("Leftmost octets not zero as expected");
            }
          }
          if (db.charCodeAt(checkLen) !== 1) {
            throw new Error("Inconsistent PSS signature, 0x01 marker not found");
          }
          var salt = db.substr(-sLen);
          var m_ = new forge.util.ByteBuffer();
          m_.fillWithByte(0, 8);
          m_.putBytes(mHash);
          m_.putBytes(salt);
          hash.start();
          hash.update(m_.getBytes());
          var h_ = hash.digest().getBytes();
          return h === h_;
        };
        return pssobj;
      };
    }
  });

  // node_modules/node-forge/lib/x509.js
  var require_x509 = __commonJS({
    "node_modules/node-forge/lib/x509.js"(exports2, module2) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_md();
      require_mgf();
      require_oids();
      require_pem();
      require_pss();
      require_rsa();
      require_util();
      var asn1 = forge.asn1;
      var pki = module2.exports = forge.pki = forge.pki || {};
      var oids = pki.oids;
      var _shortNames = {};
      _shortNames["CN"] = oids["commonName"];
      _shortNames["commonName"] = "CN";
      _shortNames["C"] = oids["countryName"];
      _shortNames["countryName"] = "C";
      _shortNames["L"] = oids["localityName"];
      _shortNames["localityName"] = "L";
      _shortNames["ST"] = oids["stateOrProvinceName"];
      _shortNames["stateOrProvinceName"] = "ST";
      _shortNames["O"] = oids["organizationName"];
      _shortNames["organizationName"] = "O";
      _shortNames["OU"] = oids["organizationalUnitName"];
      _shortNames["organizationalUnitName"] = "OU";
      _shortNames["E"] = oids["emailAddress"];
      _shortNames["emailAddress"] = "E";
      var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
      var x509CertificateValidator = {
        name: "Certificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "tbsCertificate",
          value: [
            {
              name: "Certificate.TBSCertificate.version",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.version.integer",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: "certVersion"
              }]
            },
            {
              name: "Certificate.TBSCertificate.serialNumber",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certSerialNumber"
            },
            {
              name: "Certificate.TBSCertificate.signature",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "Certificate.TBSCertificate.signature.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "certinfoSignatureOid"
              }, {
                name: "Certificate.TBSCertificate.signature.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                optional: true,
                captureAsn1: "certinfoSignatureParams"
              }]
            },
            {
              name: "Certificate.TBSCertificate.issuer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certIssuer"
            },
            {
              name: "Certificate.TBSCertificate.validity",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.UTCTIME,
                constructed: false,
                optional: true,
                capture: "certValidity1UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.GENERALIZEDTIME,
                constructed: false,
                optional: true,
                capture: "certValidity2GeneralizedTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.UTCTIME,
                constructed: false,
                optional: true,
                capture: "certValidity3UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.GENERALIZEDTIME,
                constructed: false,
                optional: true,
                capture: "certValidity4GeneralizedTime"
              }]
            },
            {
              name: "Certificate.TBSCertificate.subject",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certSubject"
            },
            publicKeyValidator,
            {
              name: "Certificate.TBSCertificate.issuerUniqueID",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.issuerUniqueID.id",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.BITSTRING,
                constructed: false,
                captureBitStringValue: "certIssuerUniqueId"
              }]
            },
            {
              name: "Certificate.TBSCertificate.subjectUniqueID",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 2,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.subjectUniqueID.id",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.BITSTRING,
                constructed: false,
                captureBitStringValue: "certSubjectUniqueId"
              }]
            },
            {
              name: "Certificate.TBSCertificate.extensions",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 3,
              constructed: true,
              captureAsn1: "certExtensions",
              optional: true
            }
          ]
        }, {
          name: "Certificate.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "certSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "certSignatureParams"
          }]
        }, {
          name: "Certificate.signatureValue",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "certSignature"
        }]
      };
      var rsassaPssParameterValidator = {
        name: "rsapss",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "hashOid"
            }]
          }]
        }, {
          name: "rsapss.maskGenAlgorithm",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenOid"
            }, {
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "maskGenHashOid"
              }]
            }]
          }]
        }, {
          name: "rsapss.saltLength",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          optional: true,
          value: [{
            name: "rsapss.saltLength.saltLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.INTEGER,
            constructed: false,
            capture: "saltLength"
          }]
        }, {
          name: "rsapss.trailerField",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          optional: true,
          value: [{
            name: "rsapss.trailer.trailer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.INTEGER,
            constructed: false,
            capture: "trailer"
          }]
        }]
      };
      var certificationRequestInfoValidator = {
        name: "CertificationRequestInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certificationRequestInfo",
        value: [
          {
            name: "CertificationRequestInfo.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certificationRequestInfoVersion"
          },
          {
            name: "CertificationRequestInfo.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certificationRequestInfoSubject"
          },
          publicKeyValidator,
          {
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            capture: "certificationRequestInfoAttributes",
            value: [{
              name: "CertificationRequestInfo.attributes",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "CertificationRequestInfo.attributes.type",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false
              }, {
                name: "CertificationRequestInfo.attributes.value",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SET,
                constructed: true
              }]
            }]
          }
        ]
      };
      var certificationRequestValidator = {
        name: "CertificationRequest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "csr",
        value: [
          certificationRequestInfoValidator,
          {
            name: "CertificationRequest.signatureAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequest.signatureAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "csrSignatureOid"
            }, {
              name: "CertificationRequest.signatureAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "csrSignatureParams"
            }]
          },
          {
            name: "CertificationRequest.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "csrSignature"
          }
        ]
      };
      pki.RDNAttributesAsArray = function(rdn, md) {
        var rval = [];
        var set, attr, obj;
        for (var si = 0; si < rdn.value.length; ++si) {
          set = rdn.value[si];
          for (var i = 0; i < set.value.length; ++i) {
            obj = {};
            attr = set.value[i];
            obj.type = asn1.derToOid(attr.value[0].value);
            obj.value = attr.value[1].value;
            obj.valueTagClass = attr.value[1].type;
            if (obj.type in oids) {
              obj.name = oids[obj.type];
              if (obj.name in _shortNames) {
                obj.shortName = _shortNames[obj.name];
              }
            }
            if (md) {
              md.update(obj.type);
              md.update(obj.value);
            }
            rval.push(obj);
          }
        }
        return rval;
      };
      pki.CRIAttributesAsArray = function(attributes) {
        var rval = [];
        for (var si = 0; si < attributes.length; ++si) {
          var seq = attributes[si];
          var type = asn1.derToOid(seq.value[0].value);
          var values = seq.value[1].value;
          for (var vi = 0; vi < values.length; ++vi) {
            var obj = {};
            obj.type = type;
            obj.value = values[vi].value;
            obj.valueTagClass = values[vi].type;
            if (obj.type in oids) {
              obj.name = oids[obj.type];
              if (obj.name in _shortNames) {
                obj.shortName = _shortNames[obj.name];
              }
            }
            if (obj.type === oids.extensionRequest) {
              obj.extensions = [];
              for (var ei = 0; ei < obj.value.length; ++ei) {
                obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
              }
            }
            rval.push(obj);
          }
        }
        return rval;
      };
      function _getAttribute(obj, options) {
        if (typeof options === "string") {
          options = { shortName: options };
        }
        var rval = null;
        var attr;
        for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
          attr = obj.attributes[i];
          if (options.type && options.type === attr.type) {
            rval = attr;
          } else if (options.name && options.name === attr.name) {
            rval = attr;
          } else if (options.shortName && options.shortName === attr.shortName) {
            rval = attr;
          }
        }
        return rval;
      }
      var _readSignatureParameters = function(oid, obj, fillDefaults) {
        var params = {};
        if (oid !== oids["RSASSA-PSS"]) {
          return params;
        }
        if (fillDefaults) {
          params = {
            hash: {
              algorithmOid: oids["sha1"]
            },
            mgf: {
              algorithmOid: oids["mgf1"],
              hash: {
                algorithmOid: oids["sha1"]
              }
            },
            saltLength: 20
          };
        }
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
          var error = new Error("Cannot read RSASSA-PSS parameter block.");
          error.errors = errors;
          throw error;
        }
        if (capture.hashOid !== void 0) {
          params.hash = params.hash || {};
          params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
        }
        if (capture.maskGenOid !== void 0) {
          params.mgf = params.mgf || {};
          params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
          params.mgf.hash = params.mgf.hash || {};
          params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
        }
        if (capture.saltLength !== void 0) {
          params.saltLength = capture.saltLength.charCodeAt(0);
        }
        return params;
      };
      pki.certificateFromPem = function(pem, computeHash, strict) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
          var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body, strict);
        return pki.certificateFromAsn1(obj, computeHash);
      };
      pki.certificateToPem = function(cert, maxline) {
        var msg = {
          type: "CERTIFICATE",
          body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.publicKeyFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
          var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert public key from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body);
        return pki.publicKeyFromAsn1(obj);
      };
      pki.publicKeyToPem = function(key, maxline) {
        var msg = {
          type: "PUBLIC KEY",
          body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
        var msg = {
          type: "RSA PUBLIC KEY",
          body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.getPublicKeyFingerprint = function(key, options) {
        options = options || {};
        var md = options.md || forge.md.sha1.create();
        var type = options.type || "RSAPublicKey";
        var bytes;
        switch (type) {
          case "RSAPublicKey":
            bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
            break;
          case "SubjectPublicKeyInfo":
            bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
            break;
          default:
            throw new Error('Unknown fingerprint type "' + options.type + '".');
        }
        md.start();
        md.update(bytes);
        var digest = md.digest();
        if (options.encoding === "hex") {
          var hex = digest.toHex();
          if (options.delimiter) {
            return hex.match(/.{2}/g).join(options.delimiter);
          }
          return hex;
        } else if (options.encoding === "binary") {
          return digest.getBytes();
        } else if (options.encoding) {
          throw new Error('Unknown encoding "' + options.encoding + '".');
        }
        return digest;
      };
      pki.certificationRequestFromPem = function(pem, computeHash, strict) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "CERTIFICATE REQUEST") {
          var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body, strict);
        return pki.certificationRequestFromAsn1(obj, computeHash);
      };
      pki.certificationRequestToPem = function(csr, maxline) {
        var msg = {
          type: "CERTIFICATE REQUEST",
          body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.createCertificate = function() {
        var cert = {};
        cert.version = 2;
        cert.serialNumber = "00";
        cert.signatureOid = null;
        cert.signature = null;
        cert.siginfo = {};
        cert.siginfo.algorithmOid = null;
        cert.validity = {};
        cert.validity.notBefore = new Date();
        cert.validity.notAfter = new Date();
        cert.issuer = {};
        cert.issuer.getField = function(sn) {
          return _getAttribute(cert.issuer, sn);
        };
        cert.issuer.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.issuer.attributes.push(attr);
        };
        cert.issuer.attributes = [];
        cert.issuer.hash = null;
        cert.subject = {};
        cert.subject.getField = function(sn) {
          return _getAttribute(cert.subject, sn);
        };
        cert.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.subject.attributes.push(attr);
        };
        cert.subject.attributes = [];
        cert.subject.hash = null;
        cert.extensions = [];
        cert.publicKey = null;
        cert.md = null;
        cert.setSubject = function(attrs, uniqueId) {
          _fillMissingFields(attrs);
          cert.subject.attributes = attrs;
          delete cert.subject.uniqueId;
          if (uniqueId) {
            cert.subject.uniqueId = uniqueId;
          }
          cert.subject.hash = null;
        };
        cert.setIssuer = function(attrs, uniqueId) {
          _fillMissingFields(attrs);
          cert.issuer.attributes = attrs;
          delete cert.issuer.uniqueId;
          if (uniqueId) {
            cert.issuer.uniqueId = uniqueId;
          }
          cert.issuer.hash = null;
        };
        cert.setExtensions = function(exts) {
          for (var i = 0; i < exts.length; ++i) {
            _fillMissingExtensionFields(exts[i], { cert });
          }
          cert.extensions = exts;
        };
        cert.getExtension = function(options) {
          if (typeof options === "string") {
            options = { name: options };
          }
          var rval = null;
          var ext;
          for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
            ext = cert.extensions[i];
            if (options.id && ext.id === options.id) {
              rval = ext;
            } else if (options.name && ext.name === options.name) {
              rval = ext;
            }
          }
          return rval;
        };
        cert.sign = function(key, md) {
          cert.md = md || forge.md.sha1.create();
          var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
          if (!algorithmOid) {
            var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
            error.algorithm = cert.md.algorithm;
            throw error;
          }
          cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
          cert.tbsCertificate = pki.getTBSCertificate(cert);
          var bytes = asn1.toDer(cert.tbsCertificate);
          cert.md.update(bytes.getBytes());
          cert.signature = key.sign(cert.md);
        };
        cert.verify = function(child) {
          var rval = false;
          if (!cert.issued(child)) {
            var issuer = child.issuer;
            var subject = cert.subject;
            var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
            error.expectedIssuer = issuer.attributes;
            error.actualIssuer = subject.attributes;
            throw error;
          }
          var md = child.md;
          if (md === null) {
            if (child.signatureOid in oids) {
              var oid = oids[child.signatureOid];
              switch (oid) {
                case "sha1WithRSAEncryption":
                  md = forge.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  md = forge.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  md = forge.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  md = forge.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  md = forge.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  md = forge.md.sha256.create();
                  break;
              }
            }
            if (md === null) {
              var error = new Error("Could not compute certificate digest. Unknown signature OID.");
              error.signatureOid = child.signatureOid;
              throw error;
            }
            var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
            var bytes = asn1.toDer(tbsCertificate);
            md.update(bytes.getBytes());
          }
          if (md !== null) {
            var scheme;
            switch (child.signatureOid) {
              case oids.sha1WithRSAEncryption:
                scheme = void 0;
                break;
              case oids["RSASSA-PSS"]:
                var hash, mgf;
                hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported MGF hash function.");
                  error.oid = child.signatureParameters.mgf.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                mgf = oids[child.signatureParameters.mgf.algorithmOid];
                if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                  var error = new Error("Unsupported MGF function.");
                  error.oid = child.signatureParameters.mgf.algorithmOid;
                  error.name = mgf;
                  throw error;
                }
                mgf = forge.mgf[mgf].create(forge.md[hash].create());
                hash = oids[child.signatureParameters.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  throw {
                    message: "Unsupported RSASSA-PSS hash function.",
                    oid: child.signatureParameters.hash.algorithmOid,
                    name: hash
                  };
                }
                scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
                break;
            }
            rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
          }
          return rval;
        };
        cert.isIssuer = function(parent) {
          var rval = false;
          var i = cert.issuer;
          var s = parent.subject;
          if (i.hash && s.hash) {
            rval = i.hash === s.hash;
          } else if (i.attributes.length === s.attributes.length) {
            rval = true;
            var iattr, sattr;
            for (var n = 0; rval && n < i.attributes.length; ++n) {
              iattr = i.attributes[n];
              sattr = s.attributes[n];
              if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
                rval = false;
              }
            }
          }
          return rval;
        };
        cert.issued = function(child) {
          return child.isIssuer(cert);
        };
        cert.generateSubjectKeyIdentifier = function() {
          return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
        };
        cert.verifySubjectKeyIdentifier = function() {
          var oid = oids["subjectKeyIdentifier"];
          for (var i = 0; i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.id === oid) {
              var ski = cert.generateSubjectKeyIdentifier().getBytes();
              return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
            }
          }
          return false;
        };
        return cert;
      };
      pki.certificateFromAsn1 = function(obj, computeHash) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
          var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          throw new Error("Cannot read public key. OID is not RSA.");
        }
        var cert = pki.createCertificate();
        cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
        var serial = forge.util.createBuffer(capture.certSerialNumber);
        cert.serialNumber = serial.toHex();
        cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
        cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
        cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
        cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
        cert.signature = capture.certSignature;
        var validity = [];
        if (capture.certValidity1UTCTime !== void 0) {
          validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
        }
        if (capture.certValidity2GeneralizedTime !== void 0) {
          validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
        }
        if (capture.certValidity3UTCTime !== void 0) {
          validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
        }
        if (capture.certValidity4GeneralizedTime !== void 0) {
          validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
        }
        if (validity.length > 2) {
          throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
        }
        if (validity.length < 2) {
          throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
        }
        cert.validity.notBefore = validity[0];
        cert.validity.notAfter = validity[1];
        cert.tbsCertificate = capture.tbsCertificate;
        if (computeHash) {
          cert.md = null;
          if (cert.signatureOid in oids) {
            var oid = oids[cert.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                cert.md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                cert.md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                cert.md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                cert.md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                cert.md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                cert.md = forge.md.sha256.create();
                break;
            }
          }
          if (cert.md === null) {
            var error = new Error("Could not compute certificate digest. Unknown signature OID.");
            error.signatureOid = cert.signatureOid;
            throw error;
          }
          var bytes = asn1.toDer(cert.tbsCertificate);
          cert.md.update(bytes.getBytes());
        }
        var imd = forge.md.sha1.create();
        cert.issuer.getField = function(sn) {
          return _getAttribute(cert.issuer, sn);
        };
        cert.issuer.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.issuer.attributes.push(attr);
        };
        cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
        if (capture.certIssuerUniqueId) {
          cert.issuer.uniqueId = capture.certIssuerUniqueId;
        }
        cert.issuer.hash = imd.digest().toHex();
        var smd = forge.md.sha1.create();
        cert.subject.getField = function(sn) {
          return _getAttribute(cert.subject, sn);
        };
        cert.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.subject.attributes.push(attr);
        };
        cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
        if (capture.certSubjectUniqueId) {
          cert.subject.uniqueId = capture.certSubjectUniqueId;
        }
        cert.subject.hash = smd.digest().toHex();
        if (capture.certExtensions) {
          cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
        } else {
          cert.extensions = [];
        }
        cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
        return cert;
      };
      pki.certificateExtensionsFromAsn1 = function(exts) {
        var rval = [];
        for (var i = 0; i < exts.value.length; ++i) {
          var extseq = exts.value[i];
          for (var ei = 0; ei < extseq.value.length; ++ei) {
            rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
          }
        }
        return rval;
      };
      pki.certificateExtensionFromAsn1 = function(ext) {
        var e = {};
        e.id = asn1.derToOid(ext.value[0].value);
        e.critical = false;
        if (ext.value[1].type === asn1.Type.BOOLEAN) {
          e.critical = ext.value[1].value.charCodeAt(0) !== 0;
          e.value = ext.value[2].value;
        } else {
          e.value = ext.value[1].value;
        }
        if (e.id in oids) {
          e.name = oids[e.id];
          if (e.name === "keyUsage") {
            var ev = asn1.fromDer(e.value);
            var b2 = 0;
            var b3 = 0;
            if (ev.value.length > 1) {
              b2 = ev.value.charCodeAt(1);
              b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
            }
            e.digitalSignature = (b2 & 128) === 128;
            e.nonRepudiation = (b2 & 64) === 64;
            e.keyEncipherment = (b2 & 32) === 32;
            e.dataEncipherment = (b2 & 16) === 16;
            e.keyAgreement = (b2 & 8) === 8;
            e.keyCertSign = (b2 & 4) === 4;
            e.cRLSign = (b2 & 2) === 2;
            e.encipherOnly = (b2 & 1) === 1;
            e.decipherOnly = (b3 & 128) === 128;
          } else if (e.name === "basicConstraints") {
            var ev = asn1.fromDer(e.value);
            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
              e.cA = ev.value[0].value.charCodeAt(0) !== 0;
            } else {
              e.cA = false;
            }
            var value = null;
            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
              value = ev.value[0].value;
            } else if (ev.value.length > 1) {
              value = ev.value[1].value;
            }
            if (value !== null) {
              e.pathLenConstraint = asn1.derToInteger(value);
            }
          } else if (e.name === "extKeyUsage") {
            var ev = asn1.fromDer(e.value);
            for (var vi = 0; vi < ev.value.length; ++vi) {
              var oid = asn1.derToOid(ev.value[vi].value);
              if (oid in oids) {
                e[oids[oid]] = true;
              } else {
                e[oid] = true;
              }
            }
          } else if (e.name === "nsCertType") {
            var ev = asn1.fromDer(e.value);
            var b2 = 0;
            if (ev.value.length > 1) {
              b2 = ev.value.charCodeAt(1);
            }
            e.client = (b2 & 128) === 128;
            e.server = (b2 & 64) === 64;
            e.email = (b2 & 32) === 32;
            e.objsign = (b2 & 16) === 16;
            e.reserved = (b2 & 8) === 8;
            e.sslCA = (b2 & 4) === 4;
            e.emailCA = (b2 & 2) === 2;
            e.objCA = (b2 & 1) === 1;
          } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
            e.altNames = [];
            var gn;
            var ev = asn1.fromDer(e.value);
            for (var n = 0; n < ev.value.length; ++n) {
              gn = ev.value[n];
              var altName = {
                type: gn.type,
                value: gn.value
              };
              e.altNames.push(altName);
              switch (gn.type) {
                case 1:
                case 2:
                case 6:
                  break;
                case 7:
                  altName.ip = forge.util.bytesToIP(gn.value);
                  break;
                case 8:
                  altName.oid = asn1.derToOid(gn.value);
                  break;
                default:
              }
            }
          } else if (e.name === "subjectKeyIdentifier") {
            var ev = asn1.fromDer(e.value);
            e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
          }
        }
        return e;
      };
      pki.certificationRequestFromAsn1 = function(obj, computeHash) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          throw new Error("Cannot read public key. OID is not RSA.");
        }
        var csr = pki.createCertificationRequest();
        csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
        csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
        csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
        csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
        csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
        csr.signature = capture.csrSignature;
        csr.certificationRequestInfo = capture.certificationRequestInfo;
        if (computeHash) {
          csr.md = null;
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                csr.md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                csr.md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                csr.md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                csr.md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                csr.md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                csr.md = forge.md.sha256.create();
                break;
            }
          }
          if (csr.md === null) {
            var error = new Error("Could not compute certification request digest. Unknown signature OID.");
            error.signatureOid = csr.signatureOid;
            throw error;
          }
          var bytes = asn1.toDer(csr.certificationRequestInfo);
          csr.md.update(bytes.getBytes());
        }
        var smd = forge.md.sha1.create();
        csr.subject.getField = function(sn) {
          return _getAttribute(csr.subject, sn);
        };
        csr.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          csr.subject.attributes.push(attr);
        };
        csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
        csr.subject.hash = smd.digest().toHex();
        csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
        csr.getAttribute = function(sn) {
          return _getAttribute(csr, sn);
        };
        csr.addAttribute = function(attr) {
          _fillMissingFields([attr]);
          csr.attributes.push(attr);
        };
        csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
        return csr;
      };
      pki.createCertificationRequest = function() {
        var csr = {};
        csr.version = 0;
        csr.signatureOid = null;
        csr.signature = null;
        csr.siginfo = {};
        csr.siginfo.algorithmOid = null;
        csr.subject = {};
        csr.subject.getField = function(sn) {
          return _getAttribute(csr.subject, sn);
        };
        csr.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          csr.subject.attributes.push(attr);
        };
        csr.subject.attributes = [];
        csr.subject.hash = null;
        csr.publicKey = null;
        csr.attributes = [];
        csr.getAttribute = function(sn) {
          return _getAttribute(csr, sn);
        };
        csr.addAttribute = function(attr) {
          _fillMissingFields([attr]);
          csr.attributes.push(attr);
        };
        csr.md = null;
        csr.setSubject = function(attrs) {
          _fillMissingFields(attrs);
          csr.subject.attributes = attrs;
          csr.subject.hash = null;
        };
        csr.setAttributes = function(attrs) {
          _fillMissingFields(attrs);
          csr.attributes = attrs;
        };
        csr.sign = function(key, md) {
          csr.md = md || forge.md.sha1.create();
          var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
          if (!algorithmOid) {
            var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
            error.algorithm = csr.md.algorithm;
            throw error;
          }
          csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
          csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(csr.certificationRequestInfo);
          csr.md.update(bytes.getBytes());
          csr.signature = key.sign(csr.md);
        };
        csr.verify = function() {
          var rval = false;
          var md = csr.md;
          if (md === null) {
            if (csr.signatureOid in oids) {
              var oid = oids[csr.signatureOid];
              switch (oid) {
                case "sha1WithRSAEncryption":
                  md = forge.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  md = forge.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  md = forge.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  md = forge.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  md = forge.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  md = forge.md.sha256.create();
                  break;
              }
            }
            if (md === null) {
              var error = new Error("Could not compute certification request digest. Unknown signature OID.");
              error.signatureOid = csr.signatureOid;
              throw error;
            }
            var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
            var bytes = asn1.toDer(cri);
            md.update(bytes.getBytes());
          }
          if (md !== null) {
            var scheme;
            switch (csr.signatureOid) {
              case oids.sha1WithRSAEncryption:
                break;
              case oids["RSASSA-PSS"]:
                var hash, mgf;
                hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported MGF hash function.");
                  error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                mgf = oids[csr.signatureParameters.mgf.algorithmOid];
                if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                  var error = new Error("Unsupported MGF function.");
                  error.oid = csr.signatureParameters.mgf.algorithmOid;
                  error.name = mgf;
                  throw error;
                }
                mgf = forge.mgf[mgf].create(forge.md[hash].create());
                hash = oids[csr.signatureParameters.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported RSASSA-PSS hash function.");
                  error.oid = csr.signatureParameters.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
                break;
            }
            rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
          }
          return rval;
        };
        return csr;
      };
      function _dnToAsn1(obj) {
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var attr, set;
        var attrs = obj.attributes;
        for (var i = 0; i < attrs.length; ++i) {
          attr = attrs[i];
          var value = attr.value;
          var valueTagClass = asn1.Type.PRINTABLESTRING;
          if ("valueTagClass" in attr) {
            valueTagClass = attr.valueTagClass;
            if (valueTagClass === asn1.Type.UTF8) {
              value = forge.util.encodeUtf8(value);
            }
          }
          set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
            ])
          ]);
          rval.value.push(set);
        }
        return rval;
      }
      function _fillMissingFields(attrs) {
        var attr;
        for (var i = 0; i < attrs.length; ++i) {
          attr = attrs[i];
          if (typeof attr.name === "undefined") {
            if (attr.type && attr.type in pki.oids) {
              attr.name = pki.oids[attr.type];
            } else if (attr.shortName && attr.shortName in _shortNames) {
              attr.name = pki.oids[_shortNames[attr.shortName]];
            }
          }
          if (typeof attr.type === "undefined") {
            if (attr.name && attr.name in pki.oids) {
              attr.type = pki.oids[attr.name];
            } else {
              var error = new Error("Attribute type not specified.");
              error.attribute = attr;
              throw error;
            }
          }
          if (typeof attr.shortName === "undefined") {
            if (attr.name && attr.name in _shortNames) {
              attr.shortName = _shortNames[attr.name];
            }
          }
          if (attr.type === oids.extensionRequest) {
            attr.valueConstructed = true;
            attr.valueTagClass = asn1.Type.SEQUENCE;
            if (!attr.value && attr.extensions) {
              attr.value = [];
              for (var ei = 0; ei < attr.extensions.length; ++ei) {
                attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
              }
            }
          }
          if (typeof attr.value === "undefined") {
            var error = new Error("Attribute value not specified.");
            error.attribute = attr;
            throw error;
          }
        }
      }
      function _fillMissingExtensionFields(e, options) {
        options = options || {};
        if (typeof e.name === "undefined") {
          if (e.id && e.id in pki.oids) {
            e.name = pki.oids[e.id];
          }
        }
        if (typeof e.id === "undefined") {
          if (e.name && e.name in pki.oids) {
            e.id = pki.oids[e.name];
          } else {
            var error = new Error("Extension ID not specified.");
            error.extension = e;
            throw error;
          }
        }
        if (typeof e.value !== "undefined") {
          return e;
        }
        if (e.name === "keyUsage") {
          var unused = 0;
          var b2 = 0;
          var b3 = 0;
          if (e.digitalSignature) {
            b2 |= 128;
            unused = 7;
          }
          if (e.nonRepudiation) {
            b2 |= 64;
            unused = 6;
          }
          if (e.keyEncipherment) {
            b2 |= 32;
            unused = 5;
          }
          if (e.dataEncipherment) {
            b2 |= 16;
            unused = 4;
          }
          if (e.keyAgreement) {
            b2 |= 8;
            unused = 3;
          }
          if (e.keyCertSign) {
            b2 |= 4;
            unused = 2;
          }
          if (e.cRLSign) {
            b2 |= 2;
            unused = 1;
          }
          if (e.encipherOnly) {
            b2 |= 1;
            unused = 0;
          }
          if (e.decipherOnly) {
            b3 |= 128;
            unused = 7;
          }
          var value = String.fromCharCode(unused);
          if (b3 !== 0) {
            value += String.fromCharCode(b2) + String.fromCharCode(b3);
          } else if (b2 !== 0) {
            value += String.fromCharCode(b2);
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
        } else if (e.name === "basicConstraints") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          if (e.cA) {
            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
          }
          if ("pathLenConstraint" in e) {
            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
          }
        } else if (e.name === "extKeyUsage") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          for (var key in e) {
            if (e[key] !== true) {
              continue;
            }
            if (key in oids) {
              seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
            } else if (key.indexOf(".") !== -1) {
              seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
            }
          }
        } else if (e.name === "nsCertType") {
          var unused = 0;
          var b2 = 0;
          if (e.client) {
            b2 |= 128;
            unused = 7;
          }
          if (e.server) {
            b2 |= 64;
            unused = 6;
          }
          if (e.email) {
            b2 |= 32;
            unused = 5;
          }
          if (e.objsign) {
            b2 |= 16;
            unused = 4;
          }
          if (e.reserved) {
            b2 |= 8;
            unused = 3;
          }
          if (e.sslCA) {
            b2 |= 4;
            unused = 2;
          }
          if (e.emailCA) {
            b2 |= 2;
            unused = 1;
          }
          if (e.objCA) {
            b2 |= 1;
            unused = 0;
          }
          var value = String.fromCharCode(unused);
          if (b2 !== 0) {
            value += String.fromCharCode(b2);
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var altName;
          for (var n = 0; n < e.altNames.length; ++n) {
            altName = e.altNames[n];
            var value = altName.value;
            if (altName.type === 7 && altName.ip) {
              value = forge.util.bytesFromIP(altName.ip);
              if (value === null) {
                var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                error.extension = e;
                throw error;
              }
            } else if (altName.type === 8) {
              if (altName.oid) {
                value = asn1.oidToDer(asn1.oidToDer(altName.oid));
              } else {
                value = asn1.oidToDer(value);
              }
            }
            e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
          }
        } else if (e.name === "nsComment" && options.cert) {
          if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
            throw new Error('Invalid "nsComment" content.');
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
        } else if (e.name === "subjectKeyIdentifier" && options.cert) {
          var ski = options.cert.generateSubjectKeyIdentifier();
          e.subjectKeyIdentifier = ski.toHex();
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
        } else if (e.name === "authorityKeyIdentifier" && options.cert) {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          if (e.keyIdentifier) {
            var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
          }
          if (e.authorityCertIssuer) {
            var authorityCertIssuer = [
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
                _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
              ])
            ];
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
          }
          if (e.serialNumber) {
            var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
          }
        } else if (e.name === "cRLDistributionPoints") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
          var altName;
          for (var n = 0; n < e.altNames.length; ++n) {
            altName = e.altNames[n];
            var value = altName.value;
            if (altName.type === 7 && altName.ip) {
              value = forge.util.bytesFromIP(altName.ip);
              if (value === null) {
                var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                error.extension = e;
                throw error;
              }
            } else if (altName.type === 8) {
              if (altName.oid) {
                value = asn1.oidToDer(asn1.oidToDer(altName.oid));
              } else {
                value = asn1.oidToDer(value);
              }
            }
            fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
          }
          subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
          seq.push(subSeq);
        }
        if (typeof e.value === "undefined") {
          var error = new Error("Extension value not specified.");
          error.extension = e;
          throw error;
        }
        return e;
      }
      function _signatureParametersToAsn1(oid, params) {
        switch (oid) {
          case oids["RSASSA-PSS"]:
            var parts = [];
            if (params.hash.algorithmOid !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ]));
            }
            if (params.mgf.algorithmOid !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                  ])
                ])
              ]));
            }
            if (params.saltLength !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
              ]));
            }
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
          default:
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
        }
      }
      function _CRIAttributesToAsn1(csr) {
        var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
        if (csr.attributes.length === 0) {
          return rval;
        }
        var attrs = csr.attributes;
        for (var i = 0; i < attrs.length; ++i) {
          var attr = attrs[i];
          var value = attr.value;
          var valueTagClass = asn1.Type.UTF8;
          if ("valueTagClass" in attr) {
            valueTagClass = attr.valueTagClass;
          }
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
          var valueConstructed = false;
          if ("valueConstructed" in attr) {
            valueConstructed = attr.valueConstructed;
          }
          var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
            ])
          ]);
          rval.value.push(seq);
        }
        return rval;
      }
      var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
      var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
      function _dateToAsn1(date) {
        if (date >= jan_1_1950 && date < jan_1_2050) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      pki.getTBSCertificate = function(cert) {
        var notBefore = _dateToAsn1(cert.validity.notBefore);
        var notAfter = _dateToAsn1(cert.validity.notAfter);
        var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
            _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
          ]),
          _dnToAsn1(cert.issuer),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            notBefore,
            notAfter
          ]),
          _dnToAsn1(cert.subject),
          pki.publicKeyToAsn1(cert.publicKey)
        ]);
        if (cert.issuer.uniqueId) {
          tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
          ]));
        }
        if (cert.subject.uniqueId) {
          tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
          ]));
        }
        if (cert.extensions.length > 0) {
          tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
        }
        return tbs;
      };
      pki.getCertificationRequestInfo = function(csr) {
        var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
          _dnToAsn1(csr.subject),
          pki.publicKeyToAsn1(csr.publicKey),
          _CRIAttributesToAsn1(csr)
        ]);
        return cri;
      };
      pki.distinguishedNameToAsn1 = function(dn) {
        return _dnToAsn1(dn);
      };
      pki.certificateToAsn1 = function(cert) {
        var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          tbsCertificate,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
            _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
        ]);
      };
      pki.certificateExtensionsToAsn1 = function(exts) {
        var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        rval.value.push(seq);
        for (var i = 0; i < exts.length; ++i) {
          seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
        }
        return rval;
      };
      pki.certificateExtensionToAsn1 = function(ext) {
        var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
        if (ext.critical) {
          extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        var value = ext.value;
        if (typeof ext.value !== "string") {
          value = asn1.toDer(value).getBytes();
        }
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
        return extseq;
      };
      pki.certificationRequestToAsn1 = function(csr) {
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          cri,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
            _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
        ]);
      };
      pki.createCaStore = function(certs) {
        var caStore = {
          certs: {}
        };
        caStore.getIssuer = function(cert2) {
          var rval = getBySubject(cert2.issuer);
          return rval;
        };
        caStore.addCertificate = function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          ensureSubjectHasHash(cert2.subject);
          if (!caStore.hasCertificate(cert2)) {
            if (cert2.subject.hash in caStore.certs) {
              var tmp = caStore.certs[cert2.subject.hash];
              if (!forge.util.isArray(tmp)) {
                tmp = [tmp];
              }
              tmp.push(cert2);
              caStore.certs[cert2.subject.hash] = tmp;
            } else {
              caStore.certs[cert2.subject.hash] = cert2;
            }
          }
        };
        caStore.hasCertificate = function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          var match = getBySubject(cert2.subject);
          if (!match) {
            return false;
          }
          if (!forge.util.isArray(match)) {
            match = [match];
          }
          var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
          for (var i2 = 0; i2 < match.length; ++i2) {
            var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
            if (der1 === der2) {
              return true;
            }
          }
          return false;
        };
        caStore.listAllCertificates = function() {
          var certList = [];
          for (var hash in caStore.certs) {
            if (caStore.certs.hasOwnProperty(hash)) {
              var value = caStore.certs[hash];
              if (!forge.util.isArray(value)) {
                certList.push(value);
              } else {
                for (var i2 = 0; i2 < value.length; ++i2) {
                  certList.push(value[i2]);
                }
              }
            }
          }
          return certList;
        };
        caStore.removeCertificate = function(cert2) {
          var result;
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          ensureSubjectHasHash(cert2.subject);
          if (!caStore.hasCertificate(cert2)) {
            return null;
          }
          var match = getBySubject(cert2.subject);
          if (!forge.util.isArray(match)) {
            result = caStore.certs[cert2.subject.hash];
            delete caStore.certs[cert2.subject.hash];
            return result;
          }
          var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
          for (var i2 = 0; i2 < match.length; ++i2) {
            var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
            if (der1 === der2) {
              result = match[i2];
              match.splice(i2, 1);
            }
          }
          if (match.length === 0) {
            delete caStore.certs[cert2.subject.hash];
          }
          return result;
        };
        function getBySubject(subject) {
          ensureSubjectHasHash(subject);
          return caStore.certs[subject.hash] || null;
        }
        function ensureSubjectHasHash(subject) {
          if (!subject.hash) {
            var md = forge.md.sha1.create();
            subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
            subject.hash = md.digest().toHex();
          }
        }
        if (certs) {
          for (var i = 0; i < certs.length; ++i) {
            var cert = certs[i];
            caStore.addCertificate(cert);
          }
        }
        return caStore;
      };
      pki.certificateError = {
        bad_certificate: "forge.pki.BadCertificate",
        unsupported_certificate: "forge.pki.UnsupportedCertificate",
        certificate_revoked: "forge.pki.CertificateRevoked",
        certificate_expired: "forge.pki.CertificateExpired",
        certificate_unknown: "forge.pki.CertificateUnknown",
        unknown_ca: "forge.pki.UnknownCertificateAuthority"
      };
      pki.verifyCertificateChain = function(caStore, chain, options) {
        if (typeof options === "function") {
          options = { verify: options };
        }
        options = options || {};
        chain = chain.slice(0);
        var certs = chain.slice(0);
        var validityCheckDate = options.validityCheckDate;
        if (typeof validityCheckDate === "undefined") {
          validityCheckDate = new Date();
        }
        var first = true;
        var error = null;
        var depth = 0;
        do {
          var cert = chain.shift();
          var parent = null;
          var selfSigned = false;
          if (validityCheckDate) {
            if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
              error = {
                message: "Certificate is not valid yet or has expired.",
                error: pki.certificateError.certificate_expired,
                notBefore: cert.validity.notBefore,
                notAfter: cert.validity.notAfter,
                now: validityCheckDate
              };
            }
          }
          if (error === null) {
            parent = chain[0] || caStore.getIssuer(cert);
            if (parent === null) {
              if (cert.isIssuer(cert)) {
                selfSigned = true;
                parent = cert;
              }
            }
            if (parent) {
              var parents = parent;
              if (!forge.util.isArray(parents)) {
                parents = [parents];
              }
              var verified = false;
              while (!verified && parents.length > 0) {
                parent = parents.shift();
                try {
                  verified = parent.verify(cert);
                } catch (ex) {
                }
              }
              if (!verified) {
                error = {
                  message: "Certificate signature is invalid.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
            if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
              error = {
                message: "Certificate is not trusted.",
                error: pki.certificateError.unknown_ca
              };
            }
          }
          if (error === null && parent && !cert.isIssuer(parent)) {
            error = {
              message: "Certificate issuer is invalid.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null) {
            var se = {
              keyUsage: true,
              basicConstraints: true
            };
            for (var i = 0; error === null && i < cert.extensions.length; ++i) {
              var ext = cert.extensions[i];
              if (ext.critical && !(ext.name in se)) {
                error = {
                  message: "Certificate has an unsupported critical extension.",
                  error: pki.certificateError.unsupported_certificate
                };
              }
            }
          }
          if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
            var bcExt = cert.getExtension("basicConstraints");
            var keyUsageExt = cert.getExtension("keyUsage");
            if (keyUsageExt !== null) {
              if (!keyUsageExt.keyCertSign || bcExt === null) {
                error = {
                  message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
            if (error === null && bcExt !== null && !bcExt.cA) {
              error = {
                message: "Certificate basicConstraints indicates the certificate is not a CA.",
                error: pki.certificateError.bad_certificate
              };
            }
            if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
              var pathLen = depth - 1;
              if (pathLen > bcExt.pathLenConstraint) {
                error = {
                  message: "Certificate basicConstraints pathLenConstraint violated.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
          }
          var vfd = error === null ? true : error.error;
          var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
          if (ret === true) {
            error = null;
          } else {
            if (vfd === true) {
              error = {
                message: "The application rejected the certificate.",
                error: pki.certificateError.bad_certificate
              };
            }
            if (ret || ret === 0) {
              if (typeof ret === "object" && !forge.util.isArray(ret)) {
                if (ret.message) {
                  error.message = ret.message;
                }
                if (ret.error) {
                  error.error = ret.error;
                }
              } else if (typeof ret === "string") {
                error.error = ret;
              }
            }
            throw error;
          }
          first = false;
          ++depth;
        } while (chain.length > 0);
        return true;
      };
    }
  });

  // node_modules/node-forge/lib/pkcs7.js
  var require_pkcs7 = __commonJS({
    "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_oids();
      require_pem();
      require_pkcs7asn1();
      require_random2();
      require_util();
      require_x509();
      var asn1 = forge.asn1;
      var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
      p7.messageFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "PKCS7") {
          var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body);
        return p7.messageFromAsn1(obj);
      };
      p7.messageToPem = function(msg, maxline) {
        var pemObj = {
          type: "PKCS7",
          body: asn1.toDer(msg.toAsn1()).getBytes()
        };
        return forge.pem.encode(pemObj, { maxline });
      };
      p7.messageFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var contentType = asn1.derToOid(capture.contentType);
        var msg;
        switch (contentType) {
          case forge.pki.oids.envelopedData:
            msg = p7.createEnvelopedData();
            break;
          case forge.pki.oids.encryptedData:
            msg = p7.createEncryptedData();
            break;
          case forge.pki.oids.signedData:
            msg = p7.createSignedData();
            break;
          default:
            throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
        }
        msg.fromAsn1(capture.content.value[0]);
        return msg;
      };
      p7.createSignedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.signedData,
          version: 1,
          certificates: [],
          crls: [],
          signers: [],
          digestAlgorithmIdentifiers: [],
          contentInfo: null,
          signerInfos: [],
          fromAsn1: function(obj) {
            _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
            msg.certificates = [];
            msg.crls = [];
            msg.digestAlgorithmIdentifiers = [];
            msg.contentInfo = null;
            msg.signerInfos = [];
            if (msg.rawCapture.certificates) {
              var certs = msg.rawCapture.certificates.value;
              for (var i = 0; i < certs.length; ++i) {
                msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
              }
            }
          },
          toAsn1: function() {
            if (!msg.contentInfo) {
              msg.sign();
            }
            var certs = [];
            for (var i = 0; i < msg.certificates.length; ++i) {
              certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
            }
            var crls = [];
            var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
                msg.contentInfo
              ])
            ]);
            if (certs.length > 0) {
              signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
            }
            if (crls.length > 0) {
              signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
            }
            signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
              signedData
            ]);
          },
          addSigner: function(signer) {
            var issuer = signer.issuer;
            var serialNumber = signer.serialNumber;
            if (signer.certificate) {
              var cert = signer.certificate;
              if (typeof cert === "string") {
                cert = forge.pki.certificateFromPem(cert);
              }
              issuer = cert.issuer.attributes;
              serialNumber = cert.serialNumber;
            }
            var key = signer.key;
            if (!key) {
              throw new Error("Could not add PKCS#7 signer; no private key specified.");
            }
            if (typeof key === "string") {
              key = forge.pki.privateKeyFromPem(key);
            }
            var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
            switch (digestAlgorithm) {
              case forge.pki.oids.sha1:
              case forge.pki.oids.sha256:
              case forge.pki.oids.sha384:
              case forge.pki.oids.sha512:
              case forge.pki.oids.md5:
                break;
              default:
                throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
            }
            var authenticatedAttributes = signer.authenticatedAttributes || [];
            if (authenticatedAttributes.length > 0) {
              var contentType = false;
              var messageDigest = false;
              for (var i = 0; i < authenticatedAttributes.length; ++i) {
                var attr = authenticatedAttributes[i];
                if (!contentType && attr.type === forge.pki.oids.contentType) {
                  contentType = true;
                  if (messageDigest) {
                    break;
                  }
                  continue;
                }
                if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                  messageDigest = true;
                  if (contentType) {
                    break;
                  }
                  continue;
                }
              }
              if (!contentType || !messageDigest) {
                throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
              }
            }
            msg.signers.push({
              key,
              version: 1,
              issuer,
              serialNumber,
              digestAlgorithm,
              signatureAlgorithm: forge.pki.oids.rsaEncryption,
              signature: null,
              authenticatedAttributes,
              unauthenticatedAttributes: []
            });
          },
          sign: function(options) {
            options = options || {};
            if (typeof msg.content !== "object" || msg.contentInfo === null) {
              msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
              ]);
              if ("content" in msg) {
                var content;
                if (msg.content instanceof forge.util.ByteBuffer) {
                  content = msg.content.bytes();
                } else if (typeof msg.content === "string") {
                  content = forge.util.encodeUtf8(msg.content);
                }
                if (options.detached) {
                  msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
                } else {
                  msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
                  ]));
                }
              }
            }
            if (msg.signers.length === 0) {
              return;
            }
            var mds = addDigestAlgorithmIds();
            addSignerInfos(mds);
          },
          verify: function() {
            throw new Error("PKCS#7 signature verification not yet implemented.");
          },
          addCertificate: function(cert) {
            if (typeof cert === "string") {
              cert = forge.pki.certificateFromPem(cert);
            }
            msg.certificates.push(cert);
          },
          addCertificateRevokationList: function(crl) {
            throw new Error("PKCS#7 CRL support not yet implemented.");
          }
        };
        return msg;
        function addDigestAlgorithmIds() {
          var mds = {};
          for (var i = 0; i < msg.signers.length; ++i) {
            var signer = msg.signers[i];
            var oid = signer.digestAlgorithm;
            if (!(oid in mds)) {
              mds[oid] = forge.md[forge.pki.oids[oid]].create();
            }
            if (signer.authenticatedAttributes.length === 0) {
              signer.md = mds[oid];
            } else {
              signer.md = forge.md[forge.pki.oids[oid]].create();
            }
          }
          msg.digestAlgorithmIdentifiers = [];
          for (var oid in mds) {
            msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]));
          }
          return mds;
        }
        function addSignerInfos(mds) {
          var content;
          if (msg.detachedContent) {
            content = msg.detachedContent;
          } else {
            content = msg.contentInfo.value[1];
            content = content.value[0];
          }
          if (!content) {
            throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
          }
          var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
          var bytes = asn1.toDer(content);
          bytes.getByte();
          asn1.getBerValueLength(bytes);
          bytes = bytes.getBytes();
          for (var oid in mds) {
            mds[oid].start().update(bytes);
          }
          var signingTime = new Date();
          for (var i = 0; i < msg.signers.length; ++i) {
            var signer = msg.signers[i];
            if (signer.authenticatedAttributes.length === 0) {
              if (contentType !== forge.pki.oids.data) {
                throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
              }
            } else {
              signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
              var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
              for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
                var attr = signer.authenticatedAttributes[ai];
                if (attr.type === forge.pki.oids.messageDigest) {
                  attr.value = mds[signer.digestAlgorithm].digest();
                } else if (attr.type === forge.pki.oids.signingTime) {
                  if (!attr.value) {
                    attr.value = signingTime;
                  }
                }
                attrsAsn1.value.push(_attributeToAsn1(attr));
                signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
              }
              bytes = asn1.toDer(attrsAsn1).getBytes();
              signer.md.start().update(bytes);
            }
            signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
          }
          msg.signerInfos = _signersToAsn1(msg.signers);
        }
      };
      p7.createEncryptedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.encryptedData,
          version: 0,
          encryptedContent: {
            algorithm: forge.pki.oids["aes256-CBC"]
          },
          fromAsn1: function(obj) {
            _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
          },
          decrypt: function(key) {
            if (key !== void 0) {
              msg.encryptedContent.key = key;
            }
            _decryptContent(msg);
          }
        };
        return msg;
      };
      p7.createEnvelopedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.envelopedData,
          version: 0,
          recipients: [],
          encryptedContent: {
            algorithm: forge.pki.oids["aes256-CBC"]
          },
          fromAsn1: function(obj) {
            var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
            msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
          },
          toAsn1: function() {
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
                ])
              ])
            ]);
          },
          findRecipient: function(cert) {
            var sAttr = cert.issuer.attributes;
            for (var i = 0; i < msg.recipients.length; ++i) {
              var r = msg.recipients[i];
              var rAttr = r.issuer;
              if (r.serialNumber !== cert.serialNumber) {
                continue;
              }
              if (rAttr.length !== sAttr.length) {
                continue;
              }
              var match = true;
              for (var j = 0; j < sAttr.length; ++j) {
                if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                  match = false;
                  break;
                }
              }
              if (match) {
                return r;
              }
            }
            return null;
          },
          decrypt: function(recipient, privKey) {
            if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
              switch (recipient.encryptedContent.algorithm) {
                case forge.pki.oids.rsaEncryption:
                case forge.pki.oids.desCBC:
                  var key = privKey.decrypt(recipient.encryptedContent.content);
                  msg.encryptedContent.key = forge.util.createBuffer(key);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
              }
            }
            _decryptContent(msg);
          },
          addRecipient: function(cert) {
            msg.recipients.push({
              version: 0,
              issuer: cert.issuer.attributes,
              serialNumber: cert.serialNumber,
              encryptedContent: {
                algorithm: forge.pki.oids.rsaEncryption,
                key: cert.publicKey
              }
            });
          },
          encrypt: function(key, cipher) {
            if (msg.encryptedContent.content === void 0) {
              cipher = cipher || msg.encryptedContent.algorithm;
              key = key || msg.encryptedContent.key;
              var keyLen, ivLen, ciphFn;
              switch (cipher) {
                case forge.pki.oids["aes128-CBC"]:
                  keyLen = 16;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["aes192-CBC"]:
                  keyLen = 24;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["aes256-CBC"]:
                  keyLen = 32;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["des-EDE3-CBC"]:
                  keyLen = 24;
                  ivLen = 8;
                  ciphFn = forge.des.createEncryptionCipher;
                  break;
                default:
                  throw new Error("Unsupported symmetric cipher, OID " + cipher);
              }
              if (key === void 0) {
                key = forge.util.createBuffer(forge.random.getBytes(keyLen));
              } else if (key.length() != keyLen) {
                throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
              }
              msg.encryptedContent.algorithm = cipher;
              msg.encryptedContent.key = key;
              msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
              var ciph = ciphFn(key);
              ciph.start(msg.encryptedContent.parameter.copy());
              ciph.update(msg.content);
              if (!ciph.finish()) {
                throw new Error("Symmetric encryption failed.");
              }
              msg.encryptedContent.content = ciph.output;
            }
            for (var i = 0; i < msg.recipients.length; ++i) {
              var recipient = msg.recipients[i];
              if (recipient.encryptedContent.content !== void 0) {
                continue;
              }
              switch (recipient.encryptedContent.algorithm) {
                case forge.pki.oids.rsaEncryption:
                  recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
              }
            }
          }
        };
        return msg;
      };
      function _recipientFromAsn1(obj) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
          error.errors = errors;
          throw error;
        }
        return {
          version: capture.version.charCodeAt(0),
          issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
          serialNumber: forge.util.createBuffer(capture.serial).toHex(),
          encryptedContent: {
            algorithm: asn1.derToOid(capture.encAlgorithm),
            parameter: capture.encParameter.value,
            content: capture.encKey
          }
        };
      }
      function _recipientToAsn1(obj) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
        ]);
      }
      function _recipientsFromAsn1(infos) {
        var ret = [];
        for (var i = 0; i < infos.length; ++i) {
          ret.push(_recipientFromAsn1(infos[i]));
        }
        return ret;
      }
      function _recipientsToAsn1(recipients) {
        var ret = [];
        for (var i = 0; i < recipients.length; ++i) {
          ret.push(_recipientToAsn1(recipients[i]));
        }
        return ret;
      }
      function _signerToAsn1(obj) {
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        ]);
        if (obj.authenticatedAttributesAsn1) {
          rval.value.push(obj.authenticatedAttributesAsn1);
        }
        rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
        rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
        if (obj.unauthenticatedAttributes.length > 0) {
          var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
          for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
            var attr = obj.unauthenticatedAttributes[i];
            attrsAsn1.values.push(_attributeToAsn1(attr));
          }
          rval.value.push(attrsAsn1);
        }
        return rval;
      }
      function _signersToAsn1(signers) {
        var ret = [];
        for (var i = 0; i < signers.length; ++i) {
          ret.push(_signerToAsn1(signers[i]));
        }
        return ret;
      }
      function _attributeToAsn1(attr) {
        var value;
        if (attr.type === forge.pki.oids.contentType) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
        } else if (attr.type === forge.pki.oids.messageDigest) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
        } else if (attr.type === forge.pki.oids.signingTime) {
          var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
          var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
          var date = attr.value;
          if (typeof date === "string") {
            var timestamp = Date.parse(date);
            if (!isNaN(timestamp)) {
              date = new Date(timestamp);
            } else if (date.length === 13) {
              date = asn1.utcTimeToDate(date);
            } else {
              date = asn1.generalizedTimeToDate(date);
            }
          }
          if (date >= jan_1_1950 && date < jan_1_2050) {
            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
          } else {
            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
          }
        }
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            value
          ])
        ]);
      }
      function _encryptedContentToAsn1(ec) {
        return [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
          ]),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
          ])
        ];
      }
      function _fromAsn1(msg, obj, validator) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
          error.errors = error;
          throw error;
        }
        var contentType = asn1.derToOid(capture.contentType);
        if (contentType !== forge.pki.oids.data) {
          throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
        }
        if (capture.encryptedContent) {
          var content = "";
          if (forge.util.isArray(capture.encryptedContent)) {
            for (var i = 0; i < capture.encryptedContent.length; ++i) {
              if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
                throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
              }
              content += capture.encryptedContent[i].value;
            }
          } else {
            content = capture.encryptedContent;
          }
          msg.encryptedContent = {
            algorithm: asn1.derToOid(capture.encAlgorithm),
            parameter: forge.util.createBuffer(capture.encParameter.value),
            content: forge.util.createBuffer(content)
          };
        }
        if (capture.content) {
          var content = "";
          if (forge.util.isArray(capture.content)) {
            for (var i = 0; i < capture.content.length; ++i) {
              if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
                throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
              }
              content += capture.content[i].value;
            }
          } else {
            content = capture.content;
          }
          msg.content = forge.util.createBuffer(content);
        }
        msg.version = capture.version.charCodeAt(0);
        msg.rawCapture = capture;
        return capture;
      }
      function _decryptContent(msg) {
        if (msg.encryptedContent.key === void 0) {
          throw new Error("Symmetric key not available.");
        }
        if (msg.content === void 0) {
          var ciph;
          switch (msg.encryptedContent.algorithm) {
            case forge.pki.oids["aes128-CBC"]:
            case forge.pki.oids["aes192-CBC"]:
            case forge.pki.oids["aes256-CBC"]:
              ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
              break;
            case forge.pki.oids["desCBC"]:
            case forge.pki.oids["des-EDE3-CBC"]:
              ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
          }
          ciph.start(msg.encryptedContent.parameter);
          ciph.update(msg.encryptedContent.content);
          if (!ciph.finish()) {
            throw new Error("Symmetric decryption failed.");
          }
          msg.content = ciph.output;
        }
      }
    }
  });

  // node_modules/libp2p/src/keychain/util.js
  var require_util4 = __commonJS({
    "node_modules/libp2p/src/keychain/util.js"(exports2, module2) {
      "use strict";
      require_x509();
      var forge = require_forge();
      var pki = forge.pki;
      var certificateForKey = (key, privateKey) => {
        const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
        const cert = pki.createCertificate();
        cert.publicKey = publicKey;
        cert.serialNumber = "01";
        cert.validity.notBefore = new Date();
        cert.validity.notAfter = new Date();
        cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
        const attrs = [{
          name: "organizationName",
          value: "ipfs"
        }, {
          shortName: "OU",
          value: "keystore"
        }, {
          name: "commonName",
          value: key.id
        }];
        cert.setSubject(attrs);
        cert.setIssuer(attrs);
        cert.setExtensions([{
          name: "basicConstraints",
          cA: true
        }, {
          name: "keyUsage",
          keyCertSign: true,
          digitalSignature: true,
          nonRepudiation: true,
          keyEncipherment: true,
          dataEncipherment: true
        }, {
          name: "extKeyUsage",
          serverAuth: true,
          clientAuth: true,
          codeSigning: true,
          emailProtection: true,
          timeStamping: true
        }, {
          name: "nsCertType",
          client: true,
          server: true,
          email: true,
          objsign: true,
          sslCA: true,
          emailCA: true,
          objCA: true
        }]);
        cert.sign(privateKey);
        return cert;
      };
      async function findAsync(array, asyncCompare) {
        const promises = array.map(asyncCompare);
        const results = await Promise.all(promises);
        const index = results.findIndex((result) => result);
        return array[index];
      }
      module2.exports = {
        certificateForKey,
        findAsync
      };
    }
  });

  // node_modules/libp2p/src/keychain/cms.js
  var require_cms = __commonJS({
    "node_modules/libp2p/src/keychain/cms.js"(exports2, module2) {
      "use strict";
      require_pkcs7();
      require_pbe();
      var forge = require_forge();
      var { certificateForKey, findAsync } = require_util4();
      var errcode = require_err_code();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var privates = new WeakMap();
      var CMS = class {
        constructor(keychain, dek) {
          if (!keychain) {
            throw errcode(new Error("keychain is required"), "ERR_KEYCHAIN_REQUIRED");
          }
          this.keychain = keychain;
          privates.set(this, { dek });
        }
        async encrypt(name, plain) {
          if (!(plain instanceof Uint8Array)) {
            throw errcode(new Error("Plain data must be a Uint8Array"), "ERR_INVALID_PARAMS");
          }
          const key = await this.keychain.findKeyByName(name);
          const pem = await this.keychain._getPrivateKey(name);
          const dek = privates.get(this).dek;
          const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
          const certificate = await certificateForKey(key, privateKey);
          const p7 = forge.pkcs7.createEnvelopedData();
          p7.addRecipient(certificate);
          p7.content = forge.util.createBuffer(plain);
          p7.encrypt();
          const der = forge.asn1.toDer(p7.toAsn1()).getBytes();
          return uint8ArrayFromString(der, "ascii");
        }
        async decrypt(cmsData) {
          if (!(cmsData instanceof Uint8Array)) {
            throw errcode(new Error("CMS data is required"), "ERR_INVALID_PARAMS");
          }
          let cms;
          try {
            const buf = forge.util.createBuffer(uint8ArrayToString(cmsData, "ascii"));
            const obj = forge.asn1.fromDer(buf);
            cms = forge.pkcs7.messageFromAsn1(obj);
          } catch (err) {
            throw errcode(new Error("Invalid CMS: " + err.message), "ERR_INVALID_CMS");
          }
          const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
            return {
              recipient: r2,
              keyId: r2.issuer.find((a) => a.shortName === "CN").value
            };
          });
          const r = await findAsync(recipients, async (recipient) => {
            try {
              const key2 = await this.keychain.findKeyById(recipient.keyId);
              if (key2)
                return true;
            } catch (err) {
              return false;
            }
            return false;
          });
          if (!r) {
            const missingKeys = recipients.map((r2) => r2.keyId);
            throw errcode(new Error("Decryption needs one of the key(s): " + missingKeys.join(", ")), "ERR_MISSING_KEYS", {
              missingKeys
            });
          }
          const key = await this.keychain.findKeyById(r.keyId);
          if (!key) {
            throw errcode(new Error("No key available to decrypto"), "ERR_NO_KEY");
          }
          const pem = await this.keychain._getPrivateKey(key.name);
          const dek = privates.get(this).dek;
          const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
          cms.decrypt(r.recipient, privateKey);
          return uint8ArrayFromString(cms.content.getBytes(), "ascii");
        }
      };
      module2.exports = CMS;
    }
  });

  // node_modules/libp2p/src/keychain/index.js
  var require_keychain = __commonJS({
    "node_modules/libp2p/src/keychain/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:keychain"), {
        error: debug("libp2p:keychain:err")
      });
      var sanitize = require_sanitize_filename();
      var mergeOptions = require_merge_options();
      var crypto2 = require_src9();
      var { Key: Key2 } = (init_key(), key_exports);
      var CMS = require_cms();
      var errcode = require_err_code();
      var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      require_sha512();
      var keyPrefix = "/pkcs8/";
      var infoPrefix = "/info/";
      var privates = new WeakMap();
      var NIST = {
        minKeyLength: 112 / 8,
        minSaltLength: 128 / 8,
        minIterationCount: 1e3
      };
      var defaultOptions = {
        dek: {
          keyLength: 512 / 8,
          iterationCount: 1e4,
          salt: "you should override this value with a crypto secure random number",
          hash: "sha2-512"
        }
      };
      function validateKeyName(name) {
        if (!name)
          return false;
        if (typeof name !== "string")
          return false;
        return name === sanitize(name.trim());
      }
      async function throwDelayed(err) {
        const min = 200;
        const max = 1e3;
        const delay = Math.random() * (max - min) + min;
        await new Promise((resolve) => setTimeout(resolve, delay));
        throw err;
      }
      function DsName(name) {
        return new Key2(keyPrefix + name);
      }
      function DsInfoName(name) {
        return new Key2(infoPrefix + name);
      }
      var Keychain = class {
        constructor(store, options) {
          if (!store) {
            throw new Error("store is required");
          }
          this.store = store;
          this.opts = mergeOptions(defaultOptions, options);
          if (this.opts.pass && this.opts.pass.length < 20) {
            throw new Error("pass must be least 20 characters");
          }
          if (this.opts.dek.keyLength < NIST.minKeyLength) {
            throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
          }
          if (this.opts.dek.salt.length < NIST.minSaltLength) {
            throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
          }
          if (this.opts.dek.iterationCount < NIST.minIterationCount) {
            throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
          }
          const dek = this.opts.pass ? crypto2.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
          privates.set(this, { dek });
        }
        get cms() {
          return new CMS(this, privates.get(this).dek);
        }
        static generateOptions() {
          const options = Object.assign({}, defaultOptions);
          const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
          options.dek.salt = uint8ArrayToString(crypto2.randomBytes(saltLength), "base64");
          return options;
        }
        static get options() {
          return defaultOptions;
        }
        async createKey(name, type, size = 2048) {
          const self2 = this;
          if (!validateKeyName(name) || name === "self") {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          if (typeof type !== "string") {
            return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), "ERR_INVALID_KEY_TYPE"));
          }
          const dsname = DsName(name);
          const exists = await self2.store.has(dsname);
          if (exists)
            return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          switch (type.toLowerCase()) {
            case "rsa":
              if (!Number.isSafeInteger(size) || size < 2048) {
                return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), "ERR_INVALID_KEY_SIZE"));
              }
              break;
            default:
              break;
          }
          let keyInfo;
          try {
            const keypair = await crypto2.keys.generateKeyPair(type, size);
            const kid = await keypair.id();
            const dek = privates.get(this).dek;
            const pem = await keypair.export(dek);
            keyInfo = {
              name,
              id: kid
            };
            const batch = self2.store.batch();
            batch.put(dsname, uint8ArrayFromString(pem));
            batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
            await batch.commit();
          } catch (err) {
            return throwDelayed(err);
          }
          return keyInfo;
        }
        async listKeys() {
          const self2 = this;
          const query = {
            prefix: infoPrefix
          };
          const info = [];
          for await (const value of self2.store.query(query)) {
            info.push(JSON.parse(uint8ArrayToString(value.value)));
          }
          return info;
        }
        async findKeyById(id) {
          try {
            const keys = await this.listKeys();
            return keys.find((k) => k.id === id);
          } catch (err) {
            return throwDelayed(err);
          }
        }
        async findKeyByName(name) {
          if (!validateKeyName(name)) {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          const dsname = DsInfoName(name);
          try {
            const res = await this.store.get(dsname);
            return JSON.parse(uint8ArrayToString(res));
          } catch (err) {
            return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
          }
        }
        async removeKey(name) {
          const self2 = this;
          if (!validateKeyName(name) || name === "self") {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          const dsname = DsName(name);
          const keyInfo = await self2.findKeyByName(name);
          const batch = self2.store.batch();
          batch.delete(dsname);
          batch.delete(DsInfoName(name));
          await batch.commit();
          return keyInfo;
        }
        async renameKey(oldName, newName) {
          const self2 = this;
          if (!validateKeyName(oldName) || oldName === "self") {
            return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), "ERR_OLD_KEY_NAME_INVALID"));
          }
          if (!validateKeyName(newName) || newName === "self") {
            return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), "ERR_NEW_KEY_NAME_INVALID"));
          }
          const oldDsname = DsName(oldName);
          const newDsname = DsName(newName);
          const oldInfoName = DsInfoName(oldName);
          const newInfoName = DsInfoName(newName);
          const exists = await self2.store.has(newDsname);
          if (exists)
            return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          try {
            const pem = await self2.store.get(oldDsname);
            const res = await self2.store.get(oldInfoName);
            const keyInfo = JSON.parse(uint8ArrayToString(res));
            keyInfo.name = newName;
            const batch = self2.store.batch();
            batch.put(newDsname, pem);
            batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));
            batch.delete(oldDsname);
            batch.delete(oldInfoName);
            await batch.commit();
            return keyInfo;
          } catch (err) {
            return throwDelayed(err);
          }
        }
        async exportKey(name, password) {
          if (!validateKeyName(name)) {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          if (!password) {
            return throwDelayed(errcode(new Error("Password is required"), "ERR_PASSWORD_REQUIRED"));
          }
          const dsname = DsName(name);
          try {
            const res = await this.store.get(dsname);
            const pem = uint8ArrayToString(res);
            const dek = privates.get(this).dek;
            const privateKey = await crypto2.keys.import(pem, dek);
            return privateKey.export(password);
          } catch (err) {
            return throwDelayed(err);
          }
        }
        async importKey(name, pem, password) {
          const self2 = this;
          if (!validateKeyName(name) || name === "self") {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          if (!pem) {
            return throwDelayed(errcode(new Error("PEM encoded key is required"), "ERR_PEM_REQUIRED"));
          }
          const dsname = DsName(name);
          const exists = await self2.store.has(dsname);
          if (exists)
            return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          let privateKey;
          try {
            privateKey = await crypto2.keys.import(pem, password);
          } catch (err) {
            return throwDelayed(errcode(new Error("Cannot read the key, most likely the password is wrong"), "ERR_CANNOT_READ_KEY"));
          }
          let kid;
          try {
            kid = await privateKey.id();
            const dek = privates.get(this).dek;
            pem = await privateKey.export(dek);
          } catch (err) {
            return throwDelayed(err);
          }
          const keyInfo = {
            name,
            id: kid
          };
          const batch = self2.store.batch();
          batch.put(dsname, uint8ArrayFromString(pem));
          batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch.commit();
          return keyInfo;
        }
        async importPeer(name, peer) {
          const self2 = this;
          if (!validateKeyName(name)) {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          if (!peer || !peer.privKey) {
            return throwDelayed(errcode(new Error("Peer.privKey is required"), "ERR_MISSING_PRIVATE_KEY"));
          }
          const privateKey = peer.privKey;
          const dsname = DsName(name);
          const exists = await self2.store.has(dsname);
          if (exists)
            return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
          try {
            const kid = await privateKey.id();
            const dek = privates.get(this).dek;
            const pem = await privateKey.export(dek);
            const keyInfo = {
              name,
              id: kid
            };
            const batch = self2.store.batch();
            batch.put(dsname, uint8ArrayFromString(pem));
            batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
            await batch.commit();
            return keyInfo;
          } catch (err) {
            return throwDelayed(err);
          }
        }
        async _getPrivateKey(name) {
          if (!validateKeyName(name)) {
            return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
          }
          try {
            const dsname = DsName(name);
            const res = await this.store.get(dsname);
            return uint8ArrayToString(res);
          } catch (err) {
            return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
          }
        }
        async rotateKeychainPass(oldPass, newPass) {
          if (typeof oldPass !== "string") {
            return throwDelayed(errcode(new Error(`Invalid old pass type '${typeof oldPass}'`), "ERR_INVALID_OLD_PASS_TYPE"));
          }
          if (typeof newPass !== "string") {
            return throwDelayed(errcode(new Error(`Invalid new pass type '${typeof newPass}'`), "ERR_INVALID_NEW_PASS_TYPE"));
          }
          if (newPass.length < 20) {
            return throwDelayed(errcode(new Error(`Invalid pass length ${newPass.length}`), "ERR_INVALID_PASS_LENGTH"));
          }
          log("recreating keychain");
          const oldDek = privates.get(this).dek;
          this.opts.pass = newPass;
          const newDek = newPass ? crypto2.pbkdf2(newPass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
          privates.set(this, { dek: newDek });
          const keys = await this.listKeys();
          for (const key of keys) {
            const res = await this.store.get(DsName(key.name));
            const pem = uint8ArrayToString(res);
            const privateKey = await crypto2.keys.import(pem, oldDek);
            const password = newDek.toString();
            const keyAsPEM = await privateKey.export(password);
            const batch = this.store.batch();
            const keyInfo = {
              name: key.name,
              id: key.id
            };
            batch.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));
            batch.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));
            await batch.commit();
          }
          log("keychain reconstructed");
        }
      };
      module2.exports = Keychain;
    }
  });

  // node_modules/streaming-iterables/dist/index.js
  var require_dist = __commonJS({
    "node_modules/streaming-iterables/dist/index.js"(exports2, module2) {
      (function(global2, factory) {
        typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.streamingIterables = {}));
      })(exports2, function(exports3) {
        "use strict";
        async function* _batch(size, iterable) {
          let dataBatch = [];
          for await (const data of iterable) {
            dataBatch.push(data);
            if (dataBatch.length === size) {
              yield dataBatch;
              dataBatch = [];
            }
          }
          if (dataBatch.length > 0) {
            yield dataBatch;
          }
        }
        function* _syncBatch(size, iterable) {
          let dataBatch = [];
          for (const data of iterable) {
            dataBatch.push(data);
            if (dataBatch.length === size) {
              yield dataBatch;
              dataBatch = [];
            }
          }
          if (dataBatch.length > 0) {
            yield dataBatch;
          }
        }
        function batch(size, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => batch(size, curriedIterable);
          }
          if (iterable[Symbol.asyncIterator]) {
            return _batch(size, iterable);
          }
          return _syncBatch(size, iterable);
        }
        function getIterator(iterable) {
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (typeof iterable[Symbol.iterator] === "function") {
            return iterable[Symbol.iterator]();
          }
          if (typeof iterable[Symbol.asyncIterator] === "function") {
            return iterable[Symbol.asyncIterator]();
          }
          throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
        }
        function defer() {
          let reject;
          let resolve;
          const promise = new Promise((resolveFunc, rejectFunc) => {
            resolve = resolveFunc;
            reject = rejectFunc;
          });
          return {
            promise,
            reject,
            resolve
          };
        }
        function _buffer(size, iterable) {
          const iterator = getIterator(iterable);
          const resultQueue = [];
          const readQueue = [];
          let reading = false;
          let ended = false;
          function fulfillReadQueue() {
            while (readQueue.length > 0 && resultQueue.length > 0) {
              const readDeferred = readQueue.shift();
              const { error, value } = resultQueue.shift();
              if (error) {
                readDeferred.reject(error);
              } else {
                readDeferred.resolve({ done: false, value });
              }
            }
            while (readQueue.length > 0 && ended) {
              const { resolve } = readQueue.shift();
              resolve({ done: true, value: void 0 });
            }
          }
          async function fillQueue() {
            if (ended) {
              return;
            }
            if (reading) {
              return;
            }
            if (resultQueue.length >= size) {
              return;
            }
            reading = true;
            try {
              const { done, value } = await iterator.next();
              if (done) {
                ended = true;
              } else {
                resultQueue.push({ value });
              }
            } catch (error) {
              ended = true;
              resultQueue.push({ error });
            }
            fulfillReadQueue();
            reading = false;
            fillQueue();
          }
          async function next() {
            if (resultQueue.length > 0) {
              const { error, value } = resultQueue.shift();
              if (error) {
                throw error;
              }
              fillQueue();
              return { done: false, value };
            }
            if (ended) {
              return { done: true, value: void 0 };
            }
            const deferred = defer();
            readQueue.push(deferred);
            fillQueue();
            return deferred.promise;
          }
          const asyncIterableIterator = {
            next,
            [Symbol.asyncIterator]: () => asyncIterableIterator
          };
          return asyncIterableIterator;
        }
        function* syncBuffer(size, iterable) {
          const valueQueue = [];
          let e;
          try {
            for (const value of iterable) {
              valueQueue.push(value);
              if (valueQueue.length <= size) {
                continue;
              }
              yield valueQueue.shift();
            }
          } catch (error) {
            e = error;
          }
          for (const value of valueQueue) {
            yield value;
          }
          if (e) {
            throw e;
          }
        }
        function buffer(size, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => buffer(size, curriedIterable);
          }
          if (size === 0) {
            return iterable;
          }
          if (iterable[Symbol.asyncIterator]) {
            return _buffer(size, iterable);
          }
          return syncBuffer(size, iterable);
        }
        async function _collect(iterable) {
          const values = [];
          for await (const value of iterable) {
            values.push(value);
          }
          return values;
        }
        function collect(iterable) {
          if (iterable[Symbol.asyncIterator]) {
            return _collect(iterable);
          }
          return Array.from(iterable);
        }
        async function* _concat(iterables) {
          for await (const iterable of iterables) {
            yield* iterable;
          }
        }
        function* _syncConcat(iterables) {
          for (const iterable of iterables) {
            yield* iterable;
          }
        }
        function concat2(...iterables) {
          const hasAnyAsync = iterables.find((itr) => itr[Symbol.asyncIterator] !== void 0);
          if (hasAnyAsync) {
            return _concat(iterables);
          } else {
            return _syncConcat(iterables);
          }
        }
        async function _consume(iterable) {
          for await (const val of iterable) {
          }
        }
        function consume(iterable) {
          if (iterable[Symbol.asyncIterator]) {
            return _consume(iterable);
          }
          for (const val of iterable) {
          }
        }
        async function* _filter(filterFunc, iterable) {
          for await (const data of iterable) {
            if (await filterFunc(data)) {
              yield data;
            }
          }
        }
        function filter(filterFunc, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => _filter(filterFunc, curriedIterable);
          }
          return _filter(filterFunc, iterable);
        }
        async function* flatten2(iterable) {
          for await (const maybeItr of iterable) {
            if (maybeItr && typeof maybeItr !== "string" && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {
              yield* flatten2(maybeItr);
            } else {
              yield maybeItr;
            }
          }
        }
        async function* _map(func, iterable) {
          for await (const val of iterable) {
            yield await func(val);
          }
        }
        function map(func, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => _map(func, curriedIterable);
          }
          return _map(func, iterable);
        }
        function flatMap(func, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => flatMap(func, curriedIterable);
          }
          return filter((i) => i !== void 0 && i !== null, flatten2(map(func, iterable)));
        }
        function _flatTransform(concurrency, func, iterable) {
          const iterator = getIterator(iterable);
          const resultQueue = [];
          const readQueue = [];
          let ended = false;
          let reading = false;
          let inflightCount = 0;
          let lastError = null;
          function fulfillReadQueue() {
            while (readQueue.length > 0 && resultQueue.length > 0) {
              const { resolve } = readQueue.shift();
              const value = resultQueue.shift();
              resolve({ done: false, value });
            }
            while (readQueue.length > 0 && inflightCount === 0 && ended) {
              const { resolve, reject } = readQueue.shift();
              if (lastError) {
                reject(lastError);
                lastError = null;
              } else {
                resolve({ done: true, value: void 0 });
              }
            }
          }
          async function fillQueue() {
            if (ended) {
              fulfillReadQueue();
              return;
            }
            if (reading) {
              return;
            }
            if (inflightCount + resultQueue.length >= concurrency) {
              return;
            }
            reading = true;
            inflightCount++;
            try {
              const { done, value } = await iterator.next();
              if (done) {
                ended = true;
                inflightCount--;
                fulfillReadQueue();
              } else {
                mapAndQueue(value);
              }
            } catch (error) {
              ended = true;
              inflightCount--;
              lastError = error;
              fulfillReadQueue();
            }
            reading = false;
            fillQueue();
          }
          async function mapAndQueue(itrValue) {
            try {
              const value = await func(itrValue);
              if (value && value[Symbol.asyncIterator]) {
                for await (const asyncVal of value) {
                  resultQueue.push(asyncVal);
                }
              } else {
                resultQueue.push(value);
              }
            } catch (error) {
              ended = true;
              lastError = error;
            }
            inflightCount--;
            fulfillReadQueue();
            fillQueue();
          }
          async function next() {
            if (resultQueue.length === 0) {
              const deferred = defer();
              readQueue.push(deferred);
              fillQueue();
              return deferred.promise;
            }
            const value = resultQueue.shift();
            fillQueue();
            return { done: false, value };
          }
          const asyncIterableIterator = {
            next,
            [Symbol.asyncIterator]: () => asyncIterableIterator
          };
          return asyncIterableIterator;
        }
        function flatTransform(concurrency, func, iterable) {
          if (func === void 0) {
            return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);
          }
          if (iterable === void 0) {
            return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);
          }
          return filter((i) => i !== void 0 && i !== null, flatten2(_flatTransform(concurrency, func, iterable)));
        }
        async function onceReadable(stream) {
          return new Promise((resolve) => {
            stream.once("readable", () => {
              resolve();
            });
          });
        }
        async function* _fromStream(stream) {
          while (true) {
            const data = stream.read();
            if (data !== null) {
              yield data;
              continue;
            }
            if (stream._readableState.ended) {
              break;
            }
            await onceReadable(stream);
          }
        }
        function fromStream(stream) {
          if (typeof stream[Symbol.asyncIterator] === "function") {
            return stream;
          }
          return _fromStream(stream);
        }
        async function* merge(...iterables) {
          const sources = new Set(iterables.map(getIterator));
          while (sources.size > 0) {
            for (const iterator of sources) {
              const nextVal = await iterator.next();
              if (nextVal.done) {
                sources.delete(iterator);
              } else {
                yield nextVal.value;
              }
            }
          }
        }
        function pipeline(firstFn, ...fns) {
          let previousFn = firstFn();
          for (const func of fns) {
            previousFn = func(previousFn);
          }
          return previousFn;
        }
        async function* _parallelMap(concurrency, func, iterable) {
          let transformError = null;
          const wrapFunc = (value) => ({
            value: func(value)
          });
          const stopOnError = async function* (source) {
            for await (const value of source) {
              if (transformError) {
                return;
              }
              yield value;
            }
          };
          const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));
          const itr = getIterator(output);
          while (true) {
            const { value, done } = await itr.next();
            if (done) {
              break;
            }
            try {
              const val = await value.value;
              if (!transformError) {
                yield val;
              }
            } catch (error) {
              transformError = error;
            }
          }
          if (transformError) {
            throw transformError;
          }
        }
        function parallelMap(concurrency, func, iterable) {
          if (func === void 0) {
            return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);
          }
          if (iterable === void 0) {
            return (curriedIterable) => parallelMap(concurrency, func, curriedIterable);
          }
          if (concurrency === 1) {
            return map(func, iterable);
          }
          return _parallelMap(concurrency, func, iterable);
        }
        function parallelFlatMap(concurrency, func, iterable) {
          if (func === void 0) {
            return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);
          }
          if (iterable === void 0) {
            return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);
          }
          return filter((i) => i !== void 0 && i !== null, flatten2(parallelMap(concurrency, func, iterable)));
        }
        async function* parallelMerge(...iterables) {
          const inputs = iterables.map(getIterator);
          const concurrentWork = /* @__PURE__ */ new Set();
          const values = /* @__PURE__ */ new Map();
          let lastError = null;
          let errCb = null;
          let valueCb = null;
          const notifyError = (err) => {
            lastError = err;
            if (errCb) {
              errCb(err);
            }
          };
          const notifyDone = (value) => {
            if (valueCb) {
              valueCb(value);
            }
          };
          const waitForQueue = () => new Promise((resolve, reject) => {
            if (lastError) {
              reject(lastError);
            }
            if (values.size > 0) {
              return resolve();
            }
            valueCb = resolve;
            errCb = reject;
          });
          const queueNext = (input) => {
            const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {
              if (!done) {
                values.set(input, value);
              }
              concurrentWork.delete(nextVal);
            });
            concurrentWork.add(nextVal);
            nextVal.then(notifyDone, notifyError);
          };
          for (const input of inputs) {
            queueNext(input);
          }
          while (true) {
            if (concurrentWork.size === 0 && values.size === 0) {
              return;
            }
            await waitForQueue();
            for (const [input, value] of values) {
              values.delete(input);
              yield value;
              queueNext(input);
            }
          }
        }
        async function _reduce(func, start, iterable) {
          let value = start;
          for await (const nextItem of iterable) {
            value = await func(value, nextItem);
          }
          return value;
        }
        function reduce(func, start, iterable) {
          if (start === void 0) {
            return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);
          }
          if (iterable === void 0) {
            return (curriedIterable) => reduce(func, start, curriedIterable);
          }
          return _reduce(func, start, iterable);
        }
        async function* _take(count, iterable) {
          let taken = 0;
          for await (const val of iterable) {
            yield await val;
            taken++;
            if (taken >= count) {
              break;
            }
          }
        }
        function* _syncTake(count, iterable) {
          let taken = 0;
          for (const val of iterable) {
            yield val;
            taken++;
            if (taken >= count) {
              break;
            }
          }
        }
        function take(count, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => take(count, curriedIterable);
          }
          if (iterable[Symbol.asyncIterator]) {
            return _take(count, iterable);
          }
          return _syncTake(count, iterable);
        }
        async function* _asyncTap(func, iterable) {
          for await (const val of iterable) {
            await func(val);
            yield val;
          }
        }
        function tap(func, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => _asyncTap(func, curriedIterable);
          }
          return _asyncTap(func, iterable);
        }
        function addTime(a, b) {
          let seconds = a[0] + b[0];
          let nanoseconds = a[1] + b[1];
          if (nanoseconds >= 1e9) {
            const remainder = nanoseconds % 1e9;
            seconds += (nanoseconds - remainder) / 1e9;
            nanoseconds = remainder;
          }
          return [seconds, nanoseconds];
        }
        async function* _asyncTime(config, iterable) {
          const itr = iterable[Symbol.asyncIterator]();
          let total = [0, 0];
          while (true) {
            const start = process.hrtime();
            const { value, done } = await itr.next();
            const delta = process.hrtime(start);
            total = addTime(total, delta);
            if (config.progress) {
              config.progress(delta, total);
            }
            if (done) {
              if (config.total) {
                config.total(total);
              }
              return value;
            }
            yield value;
          }
        }
        function* _syncTime(config, iterable) {
          const itr = iterable[Symbol.iterator]();
          let total = [0, 0];
          while (true) {
            const start = process.hrtime();
            const { value, done } = itr.next();
            const delta = process.hrtime(start);
            total = addTime(total, delta);
            if (config.progress) {
              config.progress(delta, total);
            }
            if (done) {
              if (config.total) {
                config.total(total);
              }
              return value;
            }
            yield value;
          }
        }
        function time(config = {}, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => time(config, curriedIterable);
          }
          if (iterable[Symbol.asyncIterator] !== void 0) {
            return _asyncTime(config, iterable);
          } else {
            return _syncTime(config, iterable);
          }
        }
        function _transform(concurrency, func, iterable) {
          const iterator = getIterator(iterable);
          const resultQueue = [];
          const readQueue = [];
          let ended = false;
          let reading = false;
          let inflightCount = 0;
          let lastError = null;
          function fulfillReadQueue() {
            while (readQueue.length > 0 && resultQueue.length > 0) {
              const { resolve } = readQueue.shift();
              const value = resultQueue.shift();
              resolve({ done: false, value });
            }
            while (readQueue.length > 0 && inflightCount === 0 && ended) {
              const { resolve, reject } = readQueue.shift();
              if (lastError) {
                reject(lastError);
                lastError = null;
              } else {
                resolve({ done: true, value: void 0 });
              }
            }
          }
          async function fillQueue() {
            if (ended) {
              fulfillReadQueue();
              return;
            }
            if (reading) {
              return;
            }
            if (inflightCount + resultQueue.length >= concurrency) {
              return;
            }
            reading = true;
            inflightCount++;
            try {
              const { done, value } = await iterator.next();
              if (done) {
                ended = true;
                inflightCount--;
                fulfillReadQueue();
              } else {
                mapAndQueue(value);
              }
            } catch (error) {
              ended = true;
              inflightCount--;
              lastError = error;
              fulfillReadQueue();
            }
            reading = false;
            fillQueue();
          }
          async function mapAndQueue(itrValue) {
            try {
              const value = await func(itrValue);
              resultQueue.push(value);
            } catch (error) {
              ended = true;
              lastError = error;
            }
            inflightCount--;
            fulfillReadQueue();
            fillQueue();
          }
          async function next() {
            if (resultQueue.length === 0) {
              const deferred = defer();
              readQueue.push(deferred);
              fillQueue();
              return deferred.promise;
            }
            const value = resultQueue.shift();
            fillQueue();
            return { done: false, value };
          }
          const asyncIterableIterator = {
            next,
            [Symbol.asyncIterator]: () => asyncIterableIterator
          };
          return asyncIterableIterator;
        }
        function transform(concurrency, func, iterable) {
          if (func === void 0) {
            return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
          }
          if (iterable === void 0) {
            return (curriedIterable) => transform(concurrency, func, curriedIterable);
          }
          return _transform(concurrency, func, iterable);
        }
        async function _writeToStream(stream, iterable) {
          let lastError = null;
          let errCb = null;
          let drainCb = null;
          const notifyError = (err) => {
            lastError = err;
            if (errCb) {
              errCb(err);
            }
          };
          const notifyDrain = () => {
            if (drainCb) {
              drainCb();
            }
          };
          const cleanup = () => {
            stream.removeListener("error", notifyError);
            stream.removeListener("drain", notifyDrain);
          };
          stream.once("error", notifyError);
          const waitForDrain = () => new Promise((resolve, reject) => {
            if (lastError) {
              return reject(lastError);
            }
            stream.once("drain", notifyDrain);
            drainCb = resolve;
            errCb = reject;
          });
          for await (const value of iterable) {
            if (stream.write(value) === false) {
              await waitForDrain();
            }
            if (lastError) {
              break;
            }
          }
          cleanup();
          if (lastError) {
            throw lastError;
          }
        }
        function writeToStream(stream, iterable) {
          if (iterable === void 0) {
            return (curriedIterable) => _writeToStream(stream, curriedIterable);
          }
          return _writeToStream(stream, iterable);
        }
        exports3.batch = batch;
        exports3.buffer = buffer;
        exports3.collect = collect;
        exports3.concat = concat2;
        exports3.consume = consume;
        exports3.filter = filter;
        exports3.flatMap = flatMap;
        exports3.flatTransform = flatTransform;
        exports3.flatten = flatten2;
        exports3.fromStream = fromStream;
        exports3.getIterator = getIterator;
        exports3.map = map;
        exports3.merge = merge;
        exports3.parallelFlatMap = parallelFlatMap;
        exports3.parallelMap = parallelMap;
        exports3.parallelMerge = parallelMerge;
        exports3.pipeline = pipeline;
        exports3.reduce = reduce;
        exports3.take = take;
        exports3.tap = tap;
        exports3.time = time;
        exports3.transform = transform;
        exports3.writeToStream = writeToStream;
        Object.defineProperty(exports3, "__esModule", { value: true });
      });
    }
  });

  // node_modules/hashlru/index.js
  var require_hashlru = __commonJS({
    "node_modules/hashlru/index.js"(exports2, module2) {
      module2.exports = function(max) {
        if (!max)
          throw Error("hashlru must have a max value, of type number, greater than 0");
        var size = 0, cache = Object.create(null), _cache = Object.create(null);
        function update(key, value) {
          cache[key] = value;
          size++;
          if (size >= max) {
            size = 0;
            _cache = cache;
            cache = Object.create(null);
          }
        }
        return {
          has: function(key) {
            return cache[key] !== void 0 || _cache[key] !== void 0;
          },
          remove: function(key) {
            if (cache[key] !== void 0)
              cache[key] = void 0;
            if (_cache[key] !== void 0)
              _cache[key] = void 0;
          },
          get: function(key) {
            var v = cache[key];
            if (v !== void 0)
              return v;
            if ((v = _cache[key]) !== void 0) {
              update(key, v);
              return v;
            }
          },
          set: function(key, value) {
            if (cache[key] !== void 0)
              cache[key] = value;
            else
              update(key, value);
          },
          clear: function() {
            cache = Object.create(null);
            _cache = Object.create(null);
          }
        };
      };
    }
  });

  // node_modules/libp2p/src/metrics/old-peers.js
  var require_old_peers = __commonJS({
    "node_modules/libp2p/src/metrics/old-peers.js"(exports2, module2) {
      "use strict";
      var LRU = require_hashlru();
      module2.exports = (maxSize) => {
        const patched = LRU(maxSize);
        patched.delete = patched.remove;
        return patched;
      };
    }
  });

  // node_modules/bignumber.js/bignumber.js
  var require_bignumber = __commonJS({
    "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
      (function(globalObject) {
        "use strict";
        var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
        function clone(configObject) {
          var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
            prefix: "",
            groupSize: 3,
            secondaryGroupSize: 0,
            groupSeparator: ",",
            decimalSeparator: ".",
            fractionGroupSize: 0,
            fractionGroupSeparator: "\xA0",
            suffix: ""
          }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
          function BigNumber2(v, b) {
            var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
            if (!(x instanceof BigNumber2))
              return new BigNumber2(v, b);
            if (b == null) {
              if (v && v._isBigNumber === true) {
                x.s = v.s;
                if (!v.c || v.e > MAX_EXP) {
                  x.c = x.e = null;
                } else if (v.e < MIN_EXP) {
                  x.c = [x.e = 0];
                } else {
                  x.e = v.e;
                  x.c = v.c.slice();
                }
                return;
              }
              if ((isNum = typeof v == "number") && v * 0 == 0) {
                x.s = 1 / v < 0 ? (v = -v, -1) : 1;
                if (v === ~~v) {
                  for (e = 0, i = v; i >= 10; i /= 10, e++)
                    ;
                  if (e > MAX_EXP) {
                    x.c = x.e = null;
                  } else {
                    x.e = e;
                    x.c = [v];
                  }
                  return;
                }
                str = String(v);
              } else {
                if (!isNumeric.test(str = String(v)))
                  return parseNumeric(x, str, isNum);
                x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
              }
              if ((e = str.indexOf(".")) > -1)
                str = str.replace(".", "");
              if ((i = str.search(/e/i)) > 0) {
                if (e < 0)
                  e = i;
                e += +str.slice(i + 1);
                str = str.substring(0, i);
              } else if (e < 0) {
                e = str.length;
              }
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              if (b == 10) {
                x = new BigNumber2(v);
                return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
              }
              str = String(v);
              if (isNum = typeof v == "number") {
                if (v * 0 != 0)
                  return parseNumeric(x, str, isNum, b);
                x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
                if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                  throw Error(tooManyDigits + v);
                }
              } else {
                x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
              }
              alphabet = ALPHABET.slice(0, b);
              e = i = 0;
              for (len = str.length; i < len; i++) {
                if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                  if (c == ".") {
                    if (i > e) {
                      e = len;
                      continue;
                    }
                  } else if (!caseChanged) {
                    if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                      caseChanged = true;
                      i = -1;
                      e = 0;
                      continue;
                    }
                  }
                  return parseNumeric(x, String(v), isNum, b);
                }
              }
              isNum = false;
              str = convertBase(str, b, 10, x.s);
              if ((e = str.indexOf(".")) > -1)
                str = str.replace(".", "");
              else
                e = str.length;
            }
            for (i = 0; str.charCodeAt(i) === 48; i++)
              ;
            for (len = str.length; str.charCodeAt(--len) === 48; )
              ;
            if (str = str.slice(i, ++len)) {
              len -= i;
              if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
                throw Error(tooManyDigits + x.s * v);
              }
              if ((e = e - i - 1) > MAX_EXP) {
                x.c = x.e = null;
              } else if (e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = e;
                x.c = [];
                i = (e + 1) % LOG_BASE;
                if (e < 0)
                  i += LOG_BASE;
                if (i < len) {
                  if (i)
                    x.c.push(+str.slice(0, i));
                  for (len -= LOG_BASE; i < len; ) {
                    x.c.push(+str.slice(i, i += LOG_BASE));
                  }
                  i = LOG_BASE - (str = str.slice(i)).length;
                } else {
                  i -= len;
                }
                for (; i--; str += "0")
                  ;
                x.c.push(+str);
              }
            } else {
              x.c = [x.e = 0];
            }
          }
          BigNumber2.clone = clone;
          BigNumber2.ROUND_UP = 0;
          BigNumber2.ROUND_DOWN = 1;
          BigNumber2.ROUND_CEIL = 2;
          BigNumber2.ROUND_FLOOR = 3;
          BigNumber2.ROUND_HALF_UP = 4;
          BigNumber2.ROUND_HALF_DOWN = 5;
          BigNumber2.ROUND_HALF_EVEN = 6;
          BigNumber2.ROUND_HALF_CEIL = 7;
          BigNumber2.ROUND_HALF_FLOOR = 8;
          BigNumber2.EUCLID = 9;
          BigNumber2.config = BigNumber2.set = function(obj) {
            var p, v;
            if (obj != null) {
              if (typeof obj == "object") {
                if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  DECIMAL_PLACES = v;
                }
                if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 8, p);
                  ROUNDING_MODE = v;
                }
                if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                  v = obj[p];
                  if (v && v.pop) {
                    intCheck(v[0], -MAX, 0, p);
                    intCheck(v[1], 0, MAX, p);
                    TO_EXP_NEG = v[0];
                    TO_EXP_POS = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);
                    TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                  }
                }
                if (obj.hasOwnProperty(p = "RANGE")) {
                  v = obj[p];
                  if (v && v.pop) {
                    intCheck(v[0], -MAX, -1, p);
                    intCheck(v[1], 1, MAX, p);
                    MIN_EXP = v[0];
                    MAX_EXP = v[1];
                  } else {
                    intCheck(v, -MAX, MAX, p);
                    if (v) {
                      MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                    } else {
                      throw Error(bignumberError + p + " cannot be zero: " + v);
                    }
                  }
                }
                if (obj.hasOwnProperty(p = "CRYPTO")) {
                  v = obj[p];
                  if (v === !!v) {
                    if (v) {
                      if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                        CRYPTO = v;
                      } else {
                        CRYPTO = !v;
                        throw Error(bignumberError + "crypto unavailable");
                      }
                    } else {
                      CRYPTO = v;
                    }
                  } else {
                    throw Error(bignumberError + p + " not true or false: " + v);
                  }
                }
                if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                  v = obj[p];
                  intCheck(v, 0, 9, p);
                  MODULO_MODE = v;
                }
                if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                  v = obj[p];
                  intCheck(v, 0, MAX, p);
                  POW_PRECISION = v;
                }
                if (obj.hasOwnProperty(p = "FORMAT")) {
                  v = obj[p];
                  if (typeof v == "object")
                    FORMAT = v;
                  else
                    throw Error(bignumberError + p + " not an object: " + v);
                }
                if (obj.hasOwnProperty(p = "ALPHABET")) {
                  v = obj[p];
                  if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                    ALPHABET = v;
                  } else {
                    throw Error(bignumberError + p + " invalid: " + v);
                  }
                }
              } else {
                throw Error(bignumberError + "Object expected: " + obj);
              }
            }
            return {
              DECIMAL_PLACES,
              ROUNDING_MODE,
              EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
              RANGE: [MIN_EXP, MAX_EXP],
              CRYPTO,
              MODULO_MODE,
              POW_PRECISION,
              FORMAT,
              ALPHABET
            };
          };
          BigNumber2.isBigNumber = function(v) {
            if (!v || v._isBigNumber !== true)
              return false;
            if (!BigNumber2.DEBUG)
              return true;
            var i, n, c = v.c, e = v.e, s = v.s;
            out:
              if ({}.toString.call(c) == "[object Array]") {
                if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                  if (c[0] === 0) {
                    if (e === 0 && c.length === 1)
                      return true;
                    break out;
                  }
                  i = (e + 1) % LOG_BASE;
                  if (i < 1)
                    i += LOG_BASE;
                  if (String(c[0]).length == i) {
                    for (i = 0; i < c.length; i++) {
                      n = c[i];
                      if (n < 0 || n >= BASE || n !== mathfloor(n))
                        break out;
                    }
                    if (n !== 0)
                      return true;
                  }
                }
              } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
                return true;
              }
            throw Error(bignumberError + "Invalid BigNumber: " + v);
          };
          BigNumber2.maximum = BigNumber2.max = function() {
            return maxOrMin(arguments, P.lt);
          };
          BigNumber2.minimum = BigNumber2.min = function() {
            return maxOrMin(arguments, P.gt);
          };
          BigNumber2.random = function() {
            var pow2_53 = 9007199254740992;
            var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
              return mathfloor(Math.random() * pow2_53);
            } : function() {
              return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
            };
            return function(dp) {
              var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
              if (dp == null)
                dp = DECIMAL_PLACES;
              else
                intCheck(dp, 0, MAX);
              k = mathceil(dp / LOG_BASE);
              if (CRYPTO) {
                if (crypto.getRandomValues) {
                  a = crypto.getRandomValues(new Uint32Array(k *= 2));
                  for (; i < k; ) {
                    v = a[i] * 131072 + (a[i + 1] >>> 11);
                    if (v >= 9e15) {
                      b = crypto.getRandomValues(new Uint32Array(2));
                      a[i] = b[0];
                      a[i + 1] = b[1];
                    } else {
                      c.push(v % 1e14);
                      i += 2;
                    }
                  }
                  i = k / 2;
                } else if (crypto.randomBytes) {
                  a = crypto.randomBytes(k *= 7);
                  for (; i < k; ) {
                    v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                    if (v >= 9e15) {
                      crypto.randomBytes(7).copy(a, i);
                    } else {
                      c.push(v % 1e14);
                      i += 7;
                    }
                  }
                  i = k / 7;
                } else {
                  CRYPTO = false;
                  throw Error(bignumberError + "crypto unavailable");
                }
              }
              if (!CRYPTO) {
                for (; i < k; ) {
                  v = random53bitInt();
                  if (v < 9e15)
                    c[i++] = v % 1e14;
                }
              }
              k = c[--i];
              dp %= LOG_BASE;
              if (k && dp) {
                v = POWS_TEN[LOG_BASE - dp];
                c[i] = mathfloor(k / v) * v;
              }
              for (; c[i] === 0; c.pop(), i--)
                ;
              if (i < 0) {
                c = [e = 0];
              } else {
                for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                  ;
                for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                  ;
                if (i < LOG_BASE)
                  e -= LOG_BASE - i;
              }
              rand.e = e;
              rand.c = c;
              return rand;
            };
          }();
          BigNumber2.sum = function() {
            var i = 1, args = arguments, sum = new BigNumber2(args[0]);
            for (; i < args.length; )
              sum = sum.plus(args[i++]);
            return sum;
          };
          convertBase = function() {
            var decimal = "0123456789";
            function toBaseOut(str, baseIn, baseOut, alphabet) {
              var j, arr = [0], arrL, i = 0, len = str.length;
              for (; i < len; ) {
                for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                  ;
                arr[0] += alphabet.indexOf(str.charAt(i++));
                for (j = 0; j < arr.length; j++) {
                  if (arr[j] > baseOut - 1) {
                    if (arr[j + 1] == null)
                      arr[j + 1] = 0;
                    arr[j + 1] += arr[j] / baseOut | 0;
                    arr[j] %= baseOut;
                  }
                }
              }
              return arr.reverse();
            }
            return function(str, baseIn, baseOut, sign, callerIsToString) {
              var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
              if (i >= 0) {
                k = POW_PRECISION;
                POW_PRECISION = 0;
                str = str.replace(".", "");
                y = new BigNumber2(baseIn);
                x = y.pow(str.length - i);
                POW_PRECISION = k;
                y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
                y.e = y.c.length;
              }
              xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
              e = k = xc.length;
              for (; xc[--k] == 0; xc.pop())
                ;
              if (!xc[0])
                return alphabet.charAt(0);
              if (i < 0) {
                --e;
              } else {
                x.c = xc;
                x.e = e;
                x.s = sign;
                x = div(x, y, dp, rm, baseOut);
                xc = x.c;
                r = x.r;
                e = x.e;
              }
              d = e + dp + 1;
              i = xc[d];
              k = baseOut / 2;
              r = r || d < 0 || xc[d + 1] != null;
              r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
              if (d < 1 || !xc[0]) {
                str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
              } else {
                xc.length = d;
                if (r) {
                  for (--baseOut; ++xc[--d] > baseOut; ) {
                    xc[d] = 0;
                    if (!d) {
                      ++e;
                      xc = [1].concat(xc);
                    }
                  }
                }
                for (k = xc.length; !xc[--k]; )
                  ;
                for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                  ;
                str = toFixedPoint(str, e, alphabet.charAt(0));
              }
              return str;
            };
          }();
          div = function() {
            function multiply(x, k, base3) {
              var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
              for (x = x.slice(); i--; ) {
                xlo = x[i] % SQRT_BASE;
                xhi = x[i] / SQRT_BASE | 0;
                m = khi * xlo + xhi * klo;
                temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
                carry = (temp / base3 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
                x[i] = temp % base3;
              }
              if (carry)
                x = [carry].concat(x);
              return x;
            }
            function compare2(a, b, aL, bL) {
              var i, cmp;
              if (aL != bL) {
                cmp = aL > bL ? 1 : -1;
              } else {
                for (i = cmp = 0; i < aL; i++) {
                  if (a[i] != b[i]) {
                    cmp = a[i] > b[i] ? 1 : -1;
                    break;
                  }
                }
              }
              return cmp;
            }
            function subtract(a, b, aL, base3) {
              var i = 0;
              for (; aL--; ) {
                a[aL] -= i;
                i = a[aL] < b[aL] ? 1 : 0;
                a[aL] = i * base3 + a[aL] - b[aL];
              }
              for (; !a[0] && a.length > 1; a.splice(0, 1))
                ;
            }
            return function(x, y, dp, rm, base3) {
              var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
              if (!xc || !xc[0] || !yc || !yc[0]) {
                return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
              }
              q = new BigNumber2(s);
              qc = q.c = [];
              e = x.e - y.e;
              s = dp + e + 1;
              if (!base3) {
                base3 = BASE;
                e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
                s = s / LOG_BASE | 0;
              }
              for (i = 0; yc[i] == (xc[i] || 0); i++)
                ;
              if (yc[i] > (xc[i] || 0))
                e--;
              if (s < 0) {
                qc.push(1);
                more = true;
              } else {
                xL = xc.length;
                yL = yc.length;
                i = 0;
                s += 2;
                n = mathfloor(base3 / (yc[0] + 1));
                if (n > 1) {
                  yc = multiply(yc, n, base3);
                  xc = multiply(xc, n, base3);
                  yL = yc.length;
                  xL = xc.length;
                }
                xi = yL;
                rem = xc.slice(0, yL);
                remL = rem.length;
                for (; remL < yL; rem[remL++] = 0)
                  ;
                yz = yc.slice();
                yz = [0].concat(yz);
                yc0 = yc[0];
                if (yc[1] >= base3 / 2)
                  yc0++;
                do {
                  n = 0;
                  cmp = compare2(yc, rem, yL, remL);
                  if (cmp < 0) {
                    rem0 = rem[0];
                    if (yL != remL)
                      rem0 = rem0 * base3 + (rem[1] || 0);
                    n = mathfloor(rem0 / yc0);
                    if (n > 1) {
                      if (n >= base3)
                        n = base3 - 1;
                      prod = multiply(yc, n, base3);
                      prodL = prod.length;
                      remL = rem.length;
                      while (compare2(prod, rem, prodL, remL) == 1) {
                        n--;
                        subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                        prodL = prod.length;
                        cmp = 1;
                      }
                    } else {
                      if (n == 0) {
                        cmp = n = 1;
                      }
                      prod = yc.slice();
                      prodL = prod.length;
                    }
                    if (prodL < remL)
                      prod = [0].concat(prod);
                    subtract(rem, prod, remL, base3);
                    remL = rem.length;
                    if (cmp == -1) {
                      while (compare2(yc, rem, yL, remL) < 1) {
                        n++;
                        subtract(rem, yL < remL ? yz : yc, remL, base3);
                        remL = rem.length;
                      }
                    }
                  } else if (cmp === 0) {
                    n++;
                    rem = [0];
                  }
                  qc[i++] = n;
                  if (rem[0]) {
                    rem[remL++] = xc[xi] || 0;
                  } else {
                    rem = [xc[xi]];
                    remL = 1;
                  }
                } while ((xi++ < xL || rem[0] != null) && s--);
                more = rem[0] != null;
                if (!qc[0])
                  qc.splice(0, 1);
              }
              if (base3 == BASE) {
                for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                  ;
                round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
              } else {
                q.e = e;
                q.r = +more;
              }
              return q;
            };
          }();
          function format(n, i, rm, id) {
            var c0, e, ne, len, str;
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            if (!n.c)
              return n.toString();
            c0 = n.c[0];
            ne = n.e;
            if (i == null) {
              str = coeffToString(n.c);
              str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
            } else {
              n = round(new BigNumber2(n), i, rm);
              e = n.e;
              str = coeffToString(n.c);
              len = str.length;
              if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
                for (; len < i; str += "0", len++)
                  ;
                str = toExponential(str, e);
              } else {
                i -= ne;
                str = toFixedPoint(str, e, "0");
                if (e + 1 > len) {
                  if (--i > 0)
                    for (str += "."; i--; str += "0")
                      ;
                } else {
                  i += e - len;
                  if (i > 0) {
                    if (e + 1 == len)
                      str += ".";
                    for (; i--; str += "0")
                      ;
                  }
                }
              }
            }
            return n.s < 0 && c0 ? "-" + str : str;
          }
          function maxOrMin(args, method) {
            var n, i = 1, m = new BigNumber2(args[0]);
            for (; i < args.length; i++) {
              n = new BigNumber2(args[i]);
              if (!n.s) {
                m = n;
                break;
              } else if (method.call(m, n)) {
                m = n;
              }
            }
            return m;
          }
          function normalise(n, c, e) {
            var i = 1, j = c.length;
            for (; !c[--j]; c.pop())
              ;
            for (j = c[0]; j >= 10; j /= 10, i++)
              ;
            if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
              n.c = n.e = null;
            } else if (e < MIN_EXP) {
              n.c = [n.e = 0];
            } else {
              n.e = e;
              n.c = c;
            }
            return n;
          }
          parseNumeric = function() {
            var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
            return function(x, str, isNum, b) {
              var base3, s = isNum ? str : str.replace(whitespaceOrPlus, "");
              if (isInfinityOrNaN.test(s)) {
                x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
              } else {
                if (!isNum) {
                  s = s.replace(basePrefix, function(m, p1, p2) {
                    base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                    return !b || b == base3 ? p1 : m;
                  });
                  if (b) {
                    base3 = b;
                    s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                  }
                  if (str != s)
                    return new BigNumber2(s, base3);
                }
                if (BigNumber2.DEBUG) {
                  throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
                }
                x.s = null;
              }
              x.c = x.e = null;
            };
          }();
          function round(x, sd, rm, r) {
            var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
            if (xc) {
              out: {
                for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                  ;
                i = sd - d;
                if (i < 0) {
                  i += LOG_BASE;
                  j = sd;
                  n = xc[ni = 0];
                  rd = n / pows10[d - j - 1] % 10 | 0;
                } else {
                  ni = mathceil((i + 1) / LOG_BASE);
                  if (ni >= xc.length) {
                    if (r) {
                      for (; xc.length <= ni; xc.push(0))
                        ;
                      n = rd = 0;
                      d = 1;
                      i %= LOG_BASE;
                      j = i - LOG_BASE + 1;
                    } else {
                      break out;
                    }
                  } else {
                    n = k = xc[ni];
                    for (d = 1; k >= 10; k /= 10, d++)
                      ;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + d;
                    rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                  }
                }
                r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
                r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
                if (sd < 1 || !xc[0]) {
                  xc.length = 0;
                  if (r) {
                    sd -= x.e + 1;
                    xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                    x.e = -sd || 0;
                  } else {
                    xc[0] = x.e = 0;
                  }
                  return x;
                }
                if (i == 0) {
                  xc.length = ni;
                  k = 1;
                  ni--;
                } else {
                  xc.length = ni + 1;
                  k = pows10[LOG_BASE - i];
                  xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
                }
                if (r) {
                  for (; ; ) {
                    if (ni == 0) {
                      for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                        ;
                      j = xc[0] += k;
                      for (k = 1; j >= 10; j /= 10, k++)
                        ;
                      if (i != k) {
                        x.e++;
                        if (xc[0] == BASE)
                          xc[0] = 1;
                      }
                      break;
                    } else {
                      xc[ni] += k;
                      if (xc[ni] != BASE)
                        break;
                      xc[ni--] = 0;
                      k = 1;
                    }
                  }
                }
                for (i = xc.length; xc[--i] === 0; xc.pop())
                  ;
              }
              if (x.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (x.e < MIN_EXP) {
                x.c = [x.e = 0];
              }
            }
            return x;
          }
          function valueOf(n) {
            var str, e = n.e;
            if (e === null)
              return n.toString();
            str = coeffToString(n.c);
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
            return n.s < 0 ? "-" + str : str;
          }
          P.absoluteValue = P.abs = function() {
            var x = new BigNumber2(this);
            if (x.s < 0)
              x.s = 1;
            return x;
          };
          P.comparedTo = function(y, b) {
            return compare(this, new BigNumber2(y, b));
          };
          P.decimalPlaces = P.dp = function(dp, rm) {
            var c, n, v, x = this;
            if (dp != null) {
              intCheck(dp, 0, MAX);
              if (rm == null)
                rm = ROUNDING_MODE;
              else
                intCheck(rm, 0, 8);
              return round(new BigNumber2(x), dp + x.e + 1, rm);
            }
            if (!(c = x.c))
              return null;
            n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
            if (v = c[v])
              for (; v % 10 == 0; v /= 10, n--)
                ;
            if (n < 0)
              n = 0;
            return n;
          };
          P.dividedBy = P.div = function(y, b) {
            return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
          };
          P.dividedToIntegerBy = P.idiv = function(y, b) {
            return div(this, new BigNumber2(y, b), 0, 1);
          };
          P.exponentiatedBy = P.pow = function(n, m) {
            var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
            n = new BigNumber2(n);
            if (n.c && !n.isInteger()) {
              throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
            }
            if (m != null)
              m = new BigNumber2(m);
            nIsBig = n.e > 14;
            if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
              y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
              return m ? y.mod(m) : y;
            }
            nIsNeg = n.s < 0;
            if (m) {
              if (m.c ? !m.c[0] : !m.s)
                return new BigNumber2(NaN);
              isModExp = !nIsNeg && x.isInteger() && m.isInteger();
              if (isModExp)
                x = x.mod(m);
            } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
              k = x.s < 0 && isOdd(n) ? -0 : 0;
              if (x.e > -1)
                k = 1 / k;
              return new BigNumber2(nIsNeg ? 1 / k : k);
            } else if (POW_PRECISION) {
              k = mathceil(POW_PRECISION / LOG_BASE + 2);
            }
            if (nIsBig) {
              half = new BigNumber2(0.5);
              if (nIsNeg)
                n.s = 1;
              nIsOdd = isOdd(n);
            } else {
              i = Math.abs(+valueOf(n));
              nIsOdd = i % 2;
            }
            y = new BigNumber2(ONE);
            for (; ; ) {
              if (nIsOdd) {
                y = y.times(x);
                if (!y.c)
                  break;
                if (k) {
                  if (y.c.length > k)
                    y.c.length = k;
                } else if (isModExp) {
                  y = y.mod(m);
                }
              }
              if (i) {
                i = mathfloor(i / 2);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              } else {
                n = n.times(half);
                round(n, n.e + 1, 1);
                if (n.e > 14) {
                  nIsOdd = isOdd(n);
                } else {
                  i = +valueOf(n);
                  if (i === 0)
                    break;
                  nIsOdd = i % 2;
                }
              }
              x = x.times(x);
              if (k) {
                if (x.c && x.c.length > k)
                  x.c.length = k;
              } else if (isModExp) {
                x = x.mod(m);
              }
            }
            if (isModExp)
              return y;
            if (nIsNeg)
              y = ONE.div(y);
            return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
          };
          P.integerValue = function(rm) {
            var n = new BigNumber2(this);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(n, n.e + 1, rm);
          };
          P.isEqualTo = P.eq = function(y, b) {
            return compare(this, new BigNumber2(y, b)) === 0;
          };
          P.isFinite = function() {
            return !!this.c;
          };
          P.isGreaterThan = P.gt = function(y, b) {
            return compare(this, new BigNumber2(y, b)) > 0;
          };
          P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
            return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
          };
          P.isInteger = function() {
            return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
          };
          P.isLessThan = P.lt = function(y, b) {
            return compare(this, new BigNumber2(y, b)) < 0;
          };
          P.isLessThanOrEqualTo = P.lte = function(y, b) {
            return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
          };
          P.isNaN = function() {
            return !this.s;
          };
          P.isNegative = function() {
            return this.s < 0;
          };
          P.isPositive = function() {
            return this.s > 0;
          };
          P.isZero = function() {
            return !!this.c && this.c[0] == 0;
          };
          P.minus = function(y, b) {
            var i, j, t, xLTy, x = this, a = x.s;
            y = new BigNumber2(y, b);
            b = y.s;
            if (!a || !b)
              return new BigNumber2(NaN);
            if (a != b) {
              y.s = -b;
              return x.plus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
              if (!xc || !yc)
                return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
              if (!xc[0] || !yc[0]) {
                return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
              }
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a = xe - ye) {
              if (xLTy = a < 0) {
                a = -a;
                t = xc;
              } else {
                ye = xe;
                t = yc;
              }
              t.reverse();
              for (b = a; b--; t.push(0))
                ;
              t.reverse();
            } else {
              j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
              for (a = b = 0; b < j; b++) {
                if (xc[b] != yc[b]) {
                  xLTy = xc[b] < yc[b];
                  break;
                }
              }
            }
            if (xLTy)
              t = xc, xc = yc, yc = t, y.s = -y.s;
            b = (j = yc.length) - (i = xc.length);
            if (b > 0)
              for (; b--; xc[i++] = 0)
                ;
            b = BASE - 1;
            for (; j > a; ) {
              if (xc[--j] < yc[j]) {
                for (i = j; i && !xc[--i]; xc[i] = b)
                  ;
                --xc[i];
                xc[j] += BASE;
              }
              xc[j] -= yc[j];
            }
            for (; xc[0] == 0; xc.splice(0, 1), --ye)
              ;
            if (!xc[0]) {
              y.s = ROUNDING_MODE == 3 ? -1 : 1;
              y.c = [y.e = 0];
              return y;
            }
            return normalise(y, xc, ye);
          };
          P.modulo = P.mod = function(y, b) {
            var q, s, x = this;
            y = new BigNumber2(y, b);
            if (!x.c || !y.s || y.c && !y.c[0]) {
              return new BigNumber2(NaN);
            } else if (!y.c || x.c && !x.c[0]) {
              return new BigNumber2(x);
            }
            if (MODULO_MODE == 9) {
              s = y.s;
              y.s = 1;
              q = div(x, y, 0, 3);
              y.s = s;
              q.s *= s;
            } else {
              q = div(x, y, 0, MODULO_MODE);
            }
            y = x.minus(q.times(y));
            if (!y.c[0] && MODULO_MODE == 1)
              y.s = x.s;
            return y;
          };
          P.multipliedBy = P.times = function(y, b) {
            var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
            if (!xc || !yc || !xc[0] || !yc[0]) {
              if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
                y.c = y.e = y.s = null;
              } else {
                y.s *= x.s;
                if (!xc || !yc) {
                  y.c = y.e = null;
                } else {
                  y.c = [0];
                  y.e = 0;
                }
              }
              return y;
            }
            e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
            y.s *= x.s;
            xcL = xc.length;
            ycL = yc.length;
            if (xcL < ycL)
              zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
            for (i = xcL + ycL, zc = []; i--; zc.push(0))
              ;
            base3 = BASE;
            sqrtBase = SQRT_BASE;
            for (i = ycL; --i >= 0; ) {
              c = 0;
              ylo = yc[i] % sqrtBase;
              yhi = yc[i] / sqrtBase | 0;
              for (k = xcL, j = i + k; j > i; ) {
                xlo = xc[--k] % sqrtBase;
                xhi = xc[k] / sqrtBase | 0;
                m = yhi * xlo + xhi * ylo;
                xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
                c = (xlo / base3 | 0) + (m / sqrtBase | 0) + yhi * xhi;
                zc[j--] = xlo % base3;
              }
              zc[j] = c;
            }
            if (c) {
              ++e;
            } else {
              zc.splice(0, 1);
            }
            return normalise(y, zc, e);
          };
          P.negated = function() {
            var x = new BigNumber2(this);
            x.s = -x.s || null;
            return x;
          };
          P.plus = function(y, b) {
            var t, x = this, a = x.s;
            y = new BigNumber2(y, b);
            b = y.s;
            if (!a || !b)
              return new BigNumber2(NaN);
            if (a != b) {
              y.s = -b;
              return x.minus(y);
            }
            var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
            if (!xe || !ye) {
              if (!xc || !yc)
                return new BigNumber2(a / 0);
              if (!xc[0] || !yc[0])
                return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
            }
            xe = bitFloor(xe);
            ye = bitFloor(ye);
            xc = xc.slice();
            if (a = xe - ye) {
              if (a > 0) {
                ye = xe;
                t = yc;
              } else {
                a = -a;
                t = xc;
              }
              t.reverse();
              for (; a--; t.push(0))
                ;
              t.reverse();
            }
            a = xc.length;
            b = yc.length;
            if (a - b < 0)
              t = yc, yc = xc, xc = t, b = a;
            for (a = 0; b; ) {
              a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
              xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
            }
            if (a) {
              xc = [a].concat(xc);
              ++ye;
            }
            return normalise(y, xc, ye);
          };
          P.precision = P.sd = function(sd, rm) {
            var c, n, v, x = this;
            if (sd != null && sd !== !!sd) {
              intCheck(sd, 1, MAX);
              if (rm == null)
                rm = ROUNDING_MODE;
              else
                intCheck(rm, 0, 8);
              return round(new BigNumber2(x), sd, rm);
            }
            if (!(c = x.c))
              return null;
            v = c.length - 1;
            n = v * LOG_BASE + 1;
            if (v = c[v]) {
              for (; v % 10 == 0; v /= 10, n--)
                ;
              for (v = c[0]; v >= 10; v /= 10, n++)
                ;
            }
            if (sd && x.e + 1 > n)
              n = x.e + 1;
            return n;
          };
          P.shiftedBy = function(k) {
            intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
            return this.times("1e" + k);
          };
          P.squareRoot = P.sqrt = function() {
            var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
            if (s !== 1 || !c || !c[0]) {
              return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
            }
            s = Math.sqrt(+valueOf(x));
            if (s == 0 || s == 1 / 0) {
              n = coeffToString(c);
              if ((n.length + e) % 2 == 0)
                n += "0";
              s = Math.sqrt(+n);
              e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
              if (s == 1 / 0) {
                n = "5e" + e;
              } else {
                n = s.toExponential();
                n = n.slice(0, n.indexOf("e") + 1) + e;
              }
              r = new BigNumber2(n);
            } else {
              r = new BigNumber2(s + "");
            }
            if (r.c[0]) {
              e = r.e;
              s = e + dp;
              if (s < 3)
                s = 0;
              for (; ; ) {
                t = r;
                r = half.times(t.plus(div(x, t, dp, 1)));
                if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                  if (r.e < e)
                    --s;
                  n = n.slice(s - 3, s + 1);
                  if (n == "9999" || !rep && n == "4999") {
                    if (!rep) {
                      round(t, t.e + DECIMAL_PLACES + 2, 0);
                      if (t.times(t).eq(x)) {
                        r = t;
                        break;
                      }
                    }
                    dp += 4;
                    s += 4;
                    rep = 1;
                  } else {
                    if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                      round(r, r.e + DECIMAL_PLACES + 2, 1);
                      m = !r.times(r).eq(x);
                    }
                    break;
                  }
                }
              }
            }
            return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
          };
          P.toExponential = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp++;
            }
            return format(this, dp, rm, 1);
          };
          P.toFixed = function(dp, rm) {
            if (dp != null) {
              intCheck(dp, 0, MAX);
              dp = dp + this.e + 1;
            }
            return format(this, dp, rm);
          };
          P.toFormat = function(dp, rm, format2) {
            var str, x = this;
            if (format2 == null) {
              if (dp != null && rm && typeof rm == "object") {
                format2 = rm;
                rm = null;
              } else if (dp && typeof dp == "object") {
                format2 = dp;
                dp = rm = null;
              } else {
                format2 = FORMAT;
              }
            } else if (typeof format2 != "object") {
              throw Error(bignumberError + "Argument not an object: " + format2);
            }
            str = x.toFixed(dp, rm);
            if (x.c) {
              var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
              if (g2)
                i = g1, g1 = g2, g2 = i, len -= i;
              if (g1 > 0 && len > 0) {
                i = len % g1 || g1;
                intPart = intDigits.substr(0, i);
                for (; i < len; i += g1)
                  intPart += groupSeparator + intDigits.substr(i, g1);
                if (g2 > 0)
                  intPart += groupSeparator + intDigits.slice(i);
                if (isNeg)
                  intPart = "-" + intPart;
              }
              str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
            }
            return (format2.prefix || "") + str + (format2.suffix || "");
          };
          P.toFraction = function(md) {
            var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
            if (md != null) {
              n = new BigNumber2(md);
              if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
                throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
              }
            }
            if (!xc)
              return new BigNumber2(x);
            d = new BigNumber2(ONE);
            n1 = d0 = new BigNumber2(ONE);
            d1 = n0 = new BigNumber2(ONE);
            s = coeffToString(xc);
            e = d.e = s.length - x.e - 1;
            d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
            md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
            exp = MAX_EXP;
            MAX_EXP = 1 / 0;
            n = new BigNumber2(s);
            n0.c[0] = 0;
            for (; ; ) {
              q = div(n, d, 0, 1);
              d2 = d0.plus(q.times(d1));
              if (d2.comparedTo(md) == 1)
                break;
              d0 = d1;
              d1 = d2;
              n1 = n0.plus(q.times(d2 = n1));
              n0 = d2;
              d = n.minus(q.times(d2 = d));
              n = d2;
            }
            d2 = div(md.minus(d0), d1, 0, 1);
            n0 = n0.plus(d2.times(n1));
            d0 = d0.plus(d2.times(d1));
            n0.s = n1.s = x.s;
            e = e * 2;
            r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
            MAX_EXP = exp;
            return r;
          };
          P.toNumber = function() {
            return +valueOf(this);
          };
          P.toPrecision = function(sd, rm) {
            if (sd != null)
              intCheck(sd, 1, MAX);
            return format(this, sd, rm, 2);
          };
          P.toString = function(b) {
            var str, n = this, s = n.s, e = n.e;
            if (e === null) {
              if (s) {
                str = "Infinity";
                if (s < 0)
                  str = "-" + str;
              } else {
                str = "NaN";
              }
            } else {
              if (b == null) {
                str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
              } else if (b === 10) {
                n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
                str = toFixedPoint(coeffToString(n.c), n.e, "0");
              } else {
                intCheck(b, 2, ALPHABET.length, "Base");
                str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
              }
              if (s < 0 && n.c[0])
                str = "-" + str;
            }
            return str;
          };
          P.valueOf = P.toJSON = function() {
            return valueOf(this);
          };
          P._isBigNumber = true;
          if (configObject != null)
            BigNumber2.set(configObject);
          return BigNumber2;
        }
        function bitFloor(n) {
          var i = n | 0;
          return n > 0 || n === i ? i : i - 1;
        }
        function coeffToString(a) {
          var s, z, i = 1, j = a.length, r = a[0] + "";
          for (; i < j; ) {
            s = a[i++] + "";
            z = LOG_BASE - s.length;
            for (; z--; s = "0" + s)
              ;
            r += s;
          }
          for (j = r.length; r.charCodeAt(--j) === 48; )
            ;
          return r.slice(0, j + 1 || 1);
        }
        function compare(x, y) {
          var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
          if (!i || !j)
            return null;
          a = xc && !xc[0];
          b = yc && !yc[0];
          if (a || b)
            return a ? b ? 0 : -j : i;
          if (i != j)
            return i;
          a = i < 0;
          b = k == l;
          if (!xc || !yc)
            return b ? 0 : !xc ^ a ? 1 : -1;
          if (!b)
            return k > l ^ a ? 1 : -1;
          j = (k = xc.length) < (l = yc.length) ? k : l;
          for (i = 0; i < j; i++)
            if (xc[i] != yc[i])
              return xc[i] > yc[i] ^ a ? 1 : -1;
          return k == l ? 0 : k > l ^ a ? 1 : -1;
        }
        function intCheck(n, min, max, name) {
          if (n < min || n > max || n !== mathfloor(n)) {
            throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
          }
        }
        function isOdd(n) {
          var k = n.c.length - 1;
          return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
        }
        function toExponential(str, e) {
          return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
        }
        function toFixedPoint(str, e, z) {
          var len, zs;
          if (e < 0) {
            for (zs = z + "."; ++e; zs += z)
              ;
            str = zs + str;
          } else {
            len = str.length;
            if (++e > len) {
              for (zs = z, e -= len; --e; zs += z)
                ;
              str += zs;
            } else if (e < len) {
              str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          return str;
        }
        BigNumber = clone();
        BigNumber["default"] = BigNumber.BigNumber = BigNumber;
        if (typeof define == "function" && define.amd) {
          define(function() {
            return BigNumber;
          });
        } else if (typeof module2 != "undefined" && module2.exports) {
          module2.exports = BigNumber;
        } else {
          if (!globalObject) {
            globalObject = typeof self != "undefined" && self ? self : window;
          }
          globalObject.BigNumber = BigNumber;
        }
      })(exports2);
    }
  });

  // node_modules/@vascosantos/moving-average/index.js
  var require_moving_average = __commonJS({
    "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
      "use strict";
      var exp = Math.exp;
      exports2 = module2.exports = function MovingAverage(timespan) {
        if (typeof timespan !== "number") {
          throw new Error("must provide a timespan to the moving average constructor");
        }
        if (timespan <= 0) {
          throw new Error("must provide a timespan > 0 to the moving average constructor");
        }
        let ma;
        let v = 0;
        let d = 0;
        let f = 0;
        let previousTime;
        let ret = {};
        function alpha(t, pt) {
          return 1 - exp(-(t - pt) / timespan);
        }
        ret.push = function push(time, value) {
          if (previousTime) {
            const a = alpha(time, previousTime);
            const diff = value - ma;
            const incr = a * diff;
            ma = a * value + (1 - a) * ma;
            v = (1 - a) * (v + diff * incr);
            d = Math.sqrt(v);
            f = ma + a * diff;
          } else {
            ma = value;
          }
          previousTime = time;
        };
        ret.movingAverage = function movingAverage() {
          return ma;
        };
        ret.variance = function variance() {
          return v;
        };
        ret.deviation = function deviation() {
          return d;
        };
        ret.forecast = function forecast() {
          return f;
        };
        return ret;
      };
    }
  });

  // node_modules/libp2p/src/metrics/stats.js
  var require_stats = __commonJS({
    "node_modules/libp2p/src/metrics/stats.js"(exports2, module2) {
      "use strict";
      var { EventEmitter } = require_events();
      var { BigNumber: Big } = require_bignumber();
      var MovingAverage = require_moving_average();
      var retimer = require_retimer();
      var Stats = class extends EventEmitter {
        constructor(initialCounters, options) {
          super();
          this._options = options;
          this._queue = [];
          this._stats = {
            dataReceived: Big(0),
            dataSent: Big(0)
          };
          this._frequencyLastTime = Date.now();
          this._frequencyAccumulators = {};
          this._movingAverages = {};
          this._update = this._update.bind(this);
          const intervals = this._options.movingAverageIntervals;
          for (let i = 0; i < initialCounters.length; i++) {
            const key = initialCounters[i];
            this._stats[key] = Big(0);
            this._movingAverages[key] = {};
            for (let k = 0; k < intervals.length; k++) {
              const interval = intervals[k];
              const ma = this._movingAverages[key][interval] = MovingAverage(interval);
              ma.push(this._frequencyLastTime, 0);
            }
          }
        }
        start() {
          if (this._queue.length) {
            this._resetComputeTimeout();
          }
        }
        stop() {
          if (this._timeout) {
            this._timeout.clear();
            this._timeout = null;
          }
        }
        get snapshot() {
          return Object.assign({}, this._stats);
        }
        get movingAverages() {
          return Object.assign({}, this._movingAverages);
        }
        toJSON() {
          const snapshot = this.snapshot;
          const movingAverages = this.movingAverages;
          const data = {
            dataReceived: snapshot.dataReceived.toString(),
            dataSent: snapshot.dataSent.toString(),
            movingAverages: {}
          };
          const counters = Object.keys(movingAverages);
          for (const key of counters) {
            data.movingAverages[key] = {};
            for (const interval of Object.keys(movingAverages[key])) {
              data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();
            }
          }
          return data;
        }
        push(counter, inc) {
          this._queue.push([counter, inc, Date.now()]);
          this._resetComputeTimeout();
        }
        _resetComputeTimeout() {
          this._timeout = retimer(this._update, this._nextTimeout());
        }
        _nextTimeout() {
          const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
          const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
          return timeout;
        }
        _update() {
          this._timeout = null;
          if (this._queue.length) {
            let last;
            for (last of this._queue) {
              this._applyOp(last);
            }
            this._queue = [];
            this._updateFrequency(last[2]);
            this.emit("update", this._stats);
          }
        }
        _updateFrequency(latestTime) {
          const timeDiff = latestTime - this._frequencyLastTime;
          Object.keys(this._stats).forEach((key) => {
            this._updateFrequencyFor(key, timeDiff, latestTime);
          });
          this._frequencyLastTime = latestTime;
        }
        _updateFrequencyFor(key, timeDiffMS, latestTime) {
          const count = this._frequencyAccumulators[key] || 0;
          this._frequencyAccumulators[key] = 0;
          const safeTimeDiff = timeDiffMS || 1;
          const hz = count / safeTimeDiff * 1e3;
          let movingAverages = this._movingAverages[key];
          if (!movingAverages) {
            movingAverages = this._movingAverages[key] = {};
          }
          const intervals = this._options.movingAverageIntervals;
          for (let i = 0; i < intervals.length; i++) {
            const movingAverageInterval = intervals[i];
            let movingAverage = movingAverages[movingAverageInterval];
            if (!movingAverage) {
              movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);
            }
            movingAverage.push(latestTime, hz);
          }
        }
        _applyOp(op) {
          const key = op[0];
          const inc = op[1];
          if (typeof inc !== "number") {
            throw new Error(`invalid increment number: ${inc}`);
          }
          let n;
          if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
            n = this._stats[key] = Big(0);
          } else {
            n = this._stats[key];
          }
          this._stats[key] = n.plus(inc);
          if (!this._frequencyAccumulators[key]) {
            this._frequencyAccumulators[key] = 0;
          }
          this._frequencyAccumulators[key] += inc;
        }
      };
      module2.exports = Stats;
    }
  });

  // node_modules/libp2p/src/metrics/index.js
  var require_metrics = __commonJS({
    "node_modules/libp2p/src/metrics/index.js"(exports2, module2) {
      "use strict";
      var mergeOptions = require_merge_options();
      var { pipe } = require_it_pipe2();
      var { tap } = require_dist();
      var oldPeerLRU = require_old_peers();
      var { METRICS: defaultOptions } = require_constants5();
      var Stats = require_stats();
      var initialCounters = [
        "dataReceived",
        "dataSent"
      ];
      var directionToEvent = {
        in: "dataReceived",
        out: "dataSent"
      };
      var Metrics = class {
        constructor(options) {
          this._options = mergeOptions(defaultOptions, options);
          this._globalStats = new Stats(initialCounters, this._options);
          this._peerStats = /* @__PURE__ */ new Map();
          this._protocolStats = /* @__PURE__ */ new Map();
          this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);
          this._running = false;
          this._onMessage = this._onMessage.bind(this);
          this._connectionManager = options.connectionManager;
          this._connectionManager.on("peer:disconnect", (connection) => {
            this.onPeerDisconnected(connection.remotePeer);
          });
        }
        start() {
          this._running = true;
        }
        stop() {
          this._running = false;
          this._globalStats.stop();
          for (const stats of this._peerStats.values()) {
            stats.stop();
          }
          for (const stats of this._protocolStats.values()) {
            stats.stop();
          }
        }
        get global() {
          return this._globalStats;
        }
        get peers() {
          return Array.from(this._peerStats.keys());
        }
        forPeer(peerId) {
          const idString = peerId.toB58String();
          return this._peerStats.get(idString) || this._oldPeers.get(idString);
        }
        get protocols() {
          return Array.from(this._protocolStats.keys());
        }
        forProtocol(protocol) {
          return this._protocolStats.get(protocol);
        }
        onPeerDisconnected(peerId) {
          const idString = peerId.toB58String();
          const peerStats = this._peerStats.get(idString);
          if (peerStats) {
            peerStats.stop();
            this._peerStats.delete(idString);
            this._oldPeers.set(idString, peerStats);
          }
        }
        _onMessage({ remotePeer, protocol, direction, dataLength }) {
          if (!this._running)
            return;
          const key = directionToEvent[direction];
          let peerStats = this.forPeer(remotePeer);
          if (!peerStats) {
            peerStats = new Stats(initialCounters, this._options);
            this._peerStats.set(remotePeer.toB58String(), peerStats);
          }
          peerStats.push(key, dataLength);
          this._globalStats.push(key, dataLength);
          if (protocol) {
            let protocolStats = this.forProtocol(protocol);
            if (!protocolStats) {
              protocolStats = new Stats(initialCounters, this._options);
              this._protocolStats.set(protocol, protocolStats);
            }
            protocolStats.push(key, dataLength);
          }
        }
        updatePlaceholder(placeholder, peerId) {
          if (!this._running)
            return;
          const placeholderStats = this.forPeer(placeholder);
          const peerIdString = peerId.toB58String();
          const existingStats = this.forPeer(peerId);
          let mergedStats = placeholderStats;
          if (existingStats) {
            mergedStats = Metrics.mergeStats(existingStats, mergedStats);
            this._oldPeers.delete(peerIdString);
          }
          this._peerStats.delete(placeholder.toB58String());
          this._peerStats.set(peerIdString, mergedStats);
          mergedStats.start();
        }
        trackStream({ stream, remotePeer, protocol }) {
          const metrics = this;
          const _source = stream.source;
          stream.source = tap((chunk) => metrics._onMessage({
            remotePeer,
            protocol,
            direction: "in",
            dataLength: chunk.length
          }))(_source);
          const _sink = stream.sink;
          stream.sink = (source) => {
            return pipe(source, tap((chunk) => metrics._onMessage({
              remotePeer,
              protocol,
              direction: "out",
              dataLength: chunk.length
            })), _sink);
          };
          return stream;
        }
        static mergeStats(target, other) {
          target.stop();
          other.stop();
          target._queue = [...target._queue, ...other._queue];
          return target;
        }
      };
      module2.exports = Metrics;
    }
  });

  // node_modules/multistream-select/src/multistream.js
  var require_multistream = __commonJS({
    "node_modules/multistream-select/src/multistream.js"(exports2) {
      "use strict";
      var BufferList = require_BufferList();
      var lp = require_src14();
      var pipe = require_it_pipe2();
      var errCode = require_err_code();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var first = require_it_first();
      var NewLine = uint8ArrayFromString("\n");
      exports2.encode = (buffer) => lp.encode.single(new BufferList([buffer, NewLine]));
      exports2.write = (writer, buffer) => writer.push(exports2.encode(buffer));
      exports2.writeAll = (writer, buffers) => {
        writer.push(buffers.reduce((bl, buffer) => bl.append(exports2.encode(buffer)), new BufferList()));
      };
      exports2.read = async (reader) => {
        let byteLength = 1;
        const varByteSource = {
          [Symbol.asyncIterator]() {
            return this;
          },
          next: () => reader.next(byteLength)
        };
        const onLength = (l) => {
          byteLength = l;
        };
        const buf = await pipe(varByteSource, lp.decode({ onLength }), first);
        if (buf.get(buf.length - 1) !== NewLine[0]) {
          throw errCode(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
        }
        return buf.shallowSlice(0, -1);
      };
    }
  });

  // node_modules/multistream-select/src/select.js
  var require_select = __commonJS({
    "node_modules/multistream-select/src/select.js"(exports2, module2) {
      "use strict";
      var log = require_browser2()("mss:select");
      var errCode = require_err_code();
      var multistream = require_multistream();
      var handshake = require_src15();
      module2.exports = async (stream, protocols, protocolId) => {
        protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
        const { reader, writer, rest, stream: shakeStream } = handshake(stream);
        const protocol = protocols.shift();
        if (protocolId) {
          log('select: write ["%s", "%s"]', protocolId, protocol);
          multistream.writeAll(writer, [protocolId, protocol]);
        } else {
          log('select: write "%s"', protocol);
          multistream.write(writer, protocol);
        }
        let response = (await multistream.read(reader)).toString();
        log('select: read "%s"', response);
        if (response === protocolId) {
          response = (await multistream.read(reader)).toString();
          log('select: read "%s"', response);
        }
        if (response === protocol) {
          rest();
          return { stream: shakeStream, protocol };
        }
        for (const protocol2 of protocols) {
          log('select: write "%s"', protocol2);
          multistream.write(writer, protocol2);
          const response2 = (await multistream.read(reader)).toString();
          log('select: read "%s" for "%s"', response2, protocol2);
          if (response2 === protocol2) {
            rest();
            return { stream: shakeStream, protocol: protocol2 };
          }
        }
        rest();
        throw errCode(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
      };
    }
  });

  // node_modules/multistream-select/src/constants.js
  var require_constants7 = __commonJS({
    "node_modules/multistream-select/src/constants.js"(exports2) {
      "use strict";
      exports2.PROTOCOL_ID = "/multistream/1.0.0";
    }
  });

  // node_modules/multistream-select/src/handle.js
  var require_handle = __commonJS({
    "node_modules/multistream-select/src/handle.js"(exports2, module2) {
      "use strict";
      var log = require_browser2()("mss:handle");
      var BufferList = require_BufferList();
      var multistream = require_multistream();
      var handshake = require_src15();
      var { PROTOCOL_ID } = require_constants7();
      module2.exports = async (stream, protocols) => {
        protocols = Array.isArray(protocols) ? protocols : [protocols];
        const { writer, reader, rest, stream: shakeStream } = handshake(stream);
        while (true) {
          const protocol = (await multistream.read(reader)).toString();
          log('read "%s"', protocol);
          if (protocol === PROTOCOL_ID) {
            log('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
            multistream.write(writer, PROTOCOL_ID);
            continue;
          }
          if (protocols.includes(protocol)) {
            multistream.write(writer, protocol);
            log('respond with "%s" for "%s"', protocol, protocol);
            rest();
            return { stream: shakeStream, protocol };
          }
          if (protocol === "ls") {
            multistream.write(writer, new BufferList(protocols.map((p) => multistream.encode(p))));
            log('respond with "%s" for %s', protocols, protocol);
            continue;
          }
          multistream.write(writer, "na");
          log('respond with "na" for "%s"', protocol);
        }
      };
    }
  });

  // node_modules/multistream-select/src/ls.js
  var require_ls = __commonJS({
    "node_modules/multistream-select/src/ls.js"(exports2, module2) {
      "use strict";
      var Reader = require_it_reader2();
      var log = require_browser2()("it-multistream-select:ls");
      var multistream = require_multistream();
      var handshake = require_src15();
      var lp = require_src14();
      var pipe = require_it_pipe2();
      module2.exports = async (stream) => {
        const { reader, writer, rest, stream: shakeStream } = handshake(stream);
        log('write "ls"');
        multistream.write(writer, "ls");
        rest();
        const res = await multistream.read(reader);
        const protocolsReader = Reader([res]);
        const protocols = [];
        await pipe(protocolsReader, lp.decode(), async (source) => {
          for await (const protocol of source) {
            protocols.push(protocol.shallowSlice(0, -1).toString());
          }
        });
        return { stream: shakeStream, protocols };
      };
    }
  });

  // node_modules/multistream-select/src/index.js
  var require_src17 = __commonJS({
    "node_modules/multistream-select/src/index.js"(exports2) {
      "use strict";
      var select = require_select();
      var handle = require_handle();
      var ls = require_ls();
      var { PROTOCOL_ID } = require_constants7();
      exports2.PROTOCOL_ID = PROTOCOL_ID;
      var MultistreamSelect = class {
        constructor(stream) {
          this._stream = stream;
          this._shaken = false;
        }
        async _handshake() {
          if (this._shaken)
            return;
          const { stream } = await select(this._stream, PROTOCOL_ID);
          this._stream = stream;
          this._shaken = true;
        }
      };
      var Dialer = class extends MultistreamSelect {
        select(protocols) {
          return select(this._stream, protocols, this._shaken ? null : PROTOCOL_ID);
        }
        async ls() {
          await this._handshake();
          const { stream, protocols } = await ls(this._stream);
          this._stream = stream;
          return protocols;
        }
      };
      exports2.Dialer = Dialer;
      var Listener = class extends MultistreamSelect {
        handle(protocols) {
          return handle(this._stream, protocols);
        }
      };
      exports2.Listener = Listener;
    }
  });

  // node_modules/libp2p-interfaces/src/connection/status.js
  var require_status = __commonJS({
    "node_modules/libp2p-interfaces/src/connection/status.js"(exports2, module2) {
      "use strict";
      var STATUS = {
        OPEN: "open",
        CLOSING: "closing",
        CLOSED: "closed"
      };
      module2.exports = STATUS;
    }
  });

  // node_modules/libp2p-interfaces/src/connection/connection.js
  var require_connection = __commonJS({
    "node_modules/libp2p-interfaces/src/connection/connection.js"(exports2, module2) {
      "use strict";
      var PeerId2 = require_src8();
      var { Multiaddr: Multiaddr2 } = require_src();
      var errCode = require_err_code();
      var { OPEN, CLOSING, CLOSED } = require_status();
      var connectionSymbol = Symbol.for("@libp2p/interface-connection/connection");
      var Connection = class {
        constructor({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {
          validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);
          this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now();
          this.localAddr = localAddr;
          this.remoteAddr = remoteAddr;
          this.localPeer = localPeer;
          this.remotePeer = remotePeer;
          this._stat = {
            ...stat,
            status: OPEN
          };
          this._newStream = newStream;
          this._close = close;
          this._getStreams = getStreams;
          this.registry = /* @__PURE__ */ new Map();
          this.tags = [];
        }
        get [Symbol.toStringTag]() {
          return "Connection";
        }
        get [connectionSymbol]() {
          return true;
        }
        static isConnection(other) {
          return Boolean(other && other[connectionSymbol]);
        }
        get stat() {
          return this._stat;
        }
        get streams() {
          return this._getStreams();
        }
        async newStream(protocols) {
          if (this.stat.status === CLOSING) {
            throw errCode(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
          }
          if (this.stat.status === CLOSED) {
            throw errCode(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
          }
          if (!Array.isArray(protocols))
            protocols = [protocols];
          const { stream, protocol } = await this._newStream(protocols);
          this.addStream(stream, { protocol });
          return {
            stream,
            protocol
          };
        }
        addStream(muxedStream, { protocol, metadata = {} }) {
          this.registry.set(muxedStream.id, {
            protocol,
            ...metadata
          });
        }
        removeStream(id) {
          this.registry.delete(id);
        }
        async close() {
          if (this.stat.status === CLOSED) {
            return;
          }
          if (this._closing) {
            return this._closing;
          }
          this.stat.status = CLOSING;
          this._closing = await this._close();
          this._stat.timeline.close = Date.now();
          this.stat.status = CLOSED;
        }
      };
      module2.exports = Connection;
      function validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {
        if (localAddr && !Multiaddr2.isMultiaddr(localAddr)) {
          throw errCode(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS");
        }
        if (!PeerId2.isPeerId(localPeer)) {
          throw errCode(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
        }
        if (!PeerId2.isPeerId(remotePeer)) {
          throw errCode(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
        }
        if (typeof newStream !== "function") {
          throw errCode(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS");
        }
        if (typeof close !== "function") {
          throw errCode(new Error("close must be a function"), "ERR_INVALID_PARAMETERS");
        }
        if (typeof getStreams !== "function") {
          throw errCode(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS");
        }
        if (!stat) {
          throw errCode(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS");
        }
        if (stat.direction !== "inbound" && stat.direction !== "outbound") {
          throw errCode(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS");
        }
        if (!stat.timeline) {
          throw errCode(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS");
        }
        if (!stat.timeline.open) {
          throw errCode(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS");
        }
        if (!stat.timeline.upgraded) {
          throw errCode(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS");
        }
      }
    }
  });

  // node_modules/libp2p-interfaces/src/connection/index.js
  var require_connection2 = __commonJS({
    "node_modules/libp2p-interfaces/src/connection/index.js"(exports2) {
      "use strict";
      exports2.Connection = require_connection();
    }
  });

  // node_modules/mutable-proxy/build/index.js
  var require_build = __commonJS({
    "node_modules/mutable-proxy/build/index.js"(exports2, module2) {
      "use strict";
      function _toConsumableArray(arr) {
        if (Array.isArray(arr)) {
          for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
          }
          return arr2;
        } else {
          return Array.from(arr);
        }
      }
      module2.exports = function mutableProxyFactory(defaultTarget) {
        var mutableHandler = void 0;
        var mutableTarget = void 0;
        function setTarget(target) {
          if (!(target instanceof Object)) {
            throw new Error('Target "' + target + '" is not an object');
          }
          mutableTarget = target;
        }
        function setHandler(handler2) {
          Object.keys(handler2).forEach(function(key) {
            var value = handler2[key];
            if (typeof value !== "function") {
              throw new Error('Trap "' + key + ": " + value + '" is not a function');
            }
            if (!Reflect[key]) {
              throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
            }
          });
          mutableHandler = handler2;
        }
        setTarget(function() {
        });
        if (defaultTarget) {
          setTarget(defaultTarget);
        }
        setHandler(Reflect);
        var handler = new Proxy({}, {
          get: function get(target, property) {
            return function() {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
            };
          }
        });
        return {
          setTarget,
          setHandler,
          getTarget: function getTarget() {
            return mutableTarget;
          },
          getHandler: function getHandler() {
            return mutableHandler;
          },
          proxy: new Proxy(mutableTarget, handler)
        };
      };
    }
  });

  // node_modules/libp2p/src/upgrader.js
  var require_upgrader = __commonJS({
    "node_modules/libp2p/src/upgrader.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:upgrader"), {
        error: debug("libp2p:upgrader:err")
      });
      var errCode = require_err_code();
      var Multistream = require_src17();
      var { Connection } = require_connection2();
      var PeerId2 = require_src8();
      var { pipe } = require_it_pipe2();
      var mutableProxy = require_build();
      var { codes } = require_errors2();
      var Upgrader = class {
        constructor({
          localPeer,
          metrics,
          cryptos = /* @__PURE__ */ new Map(),
          muxers = /* @__PURE__ */ new Map(),
          onConnectionEnd = () => {
          },
          onConnection = () => {
          }
        }) {
          this.localPeer = localPeer;
          this.metrics = metrics;
          this.cryptos = cryptos;
          this.muxers = muxers;
          this.protector = null;
          this.protocols = /* @__PURE__ */ new Map();
          this.onConnection = onConnection;
          this.onConnectionEnd = onConnectionEnd;
        }
        async upgradeInbound(maConn) {
          let encryptedConn;
          let remotePeer;
          let upgradedConn;
          let Muxer;
          let cryptoProtocol;
          let setPeer;
          let proxyPeer;
          if (this.metrics) {
            ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
            const idString = (Math.random() * 1e9).toString(36) + Date.now();
            setPeer({ toB58String: () => idString });
            maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
          }
          log("Starting the inbound connection upgrade");
          let protectedConn = maConn;
          if (this.protector) {
            protectedConn = await this.protector.protect(maConn);
          }
          try {
            ({
              conn: encryptedConn,
              remotePeer,
              protocol: cryptoProtocol
            } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));
            if (this.muxers.size) {
              ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers));
            } else {
              upgradedConn = encryptedConn;
            }
          } catch (err) {
            log.error("Failed to upgrade inbound connection", err);
            await maConn.close(err);
            throw err;
          }
          if (this.metrics) {
            this.metrics.updatePlaceholder(proxyPeer, remotePeer);
            setPeer(remotePeer);
          }
          log("Successfully upgraded inbound connection");
          return this._createConnection({
            cryptoProtocol,
            direction: "inbound",
            maConn,
            upgradedConn,
            Muxer,
            remotePeer
          });
        }
        async upgradeOutbound(maConn) {
          const idStr = maConn.remoteAddr.getPeerId();
          if (!idStr) {
            throw errCode(new Error("outbound connection must have a peer id"), codes.ERR_INVALID_MULTIADDR);
          }
          const remotePeerId = PeerId2.createFromB58String(idStr);
          let encryptedConn;
          let remotePeer;
          let upgradedConn;
          let cryptoProtocol;
          let Muxer;
          let setPeer;
          let proxyPeer;
          if (this.metrics) {
            ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
            const idString = (Math.random() * 1e9).toString(36) + Date.now();
            setPeer({ toB58String: () => idString });
            maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
          }
          log("Starting the outbound connection upgrade");
          let protectedConn = maConn;
          if (this.protector) {
            protectedConn = await this.protector.protect(maConn);
          }
          try {
            ({
              conn: encryptedConn,
              remotePeer,
              protocol: cryptoProtocol
            } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));
            if (this.muxers.size) {
              ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers));
            } else {
              upgradedConn = encryptedConn;
            }
          } catch (err) {
            log.error("Failed to upgrade outbound connection", err);
            await maConn.close(err);
            throw err;
          }
          if (this.metrics) {
            this.metrics.updatePlaceholder(proxyPeer, remotePeer);
            setPeer(remotePeer);
          }
          log("Successfully upgraded outbound connection");
          return this._createConnection({
            cryptoProtocol,
            direction: "outbound",
            maConn,
            upgradedConn,
            Muxer,
            remotePeer
          });
        }
        _createConnection({
          cryptoProtocol,
          direction,
          maConn,
          upgradedConn,
          Muxer,
          remotePeer
        }) {
          let muxer;
          let newStream;
          let connection;
          if (Muxer) {
            muxer = new Muxer({
              onStream: async (muxedStream) => {
                if (!connection)
                  return;
                const mss = new Multistream.Listener(muxedStream);
                try {
                  const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()));
                  log("%s: incoming stream opened on %s", direction, protocol);
                  if (this.metrics)
                    this.metrics.trackStream({ stream, remotePeer, protocol });
                  connection.addStream(muxedStream, { protocol });
                  this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol });
                } catch (err) {
                  log.error(err);
                }
              },
              onStreamEnd: (muxedStream) => {
                connection.removeStream(muxedStream.id);
              }
            });
            newStream = async (protocols) => {
              log("%s: starting new stream on %s", direction, protocols);
              const muxedStream = muxer.newStream();
              const mss = new Multistream.Dialer(muxedStream);
              try {
                const { stream, protocol } = await mss.select(protocols);
                if (this.metrics)
                  this.metrics.trackStream({ stream, remotePeer, protocol });
                return { stream: { ...muxedStream, ...stream }, protocol };
              } catch (err) {
                log.error("could not create new stream", err);
                throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);
              }
            };
            pipe(upgradedConn, muxer, upgradedConn).catch(log.error);
          }
          const _timeline = maConn.timeline;
          maConn.timeline = new Proxy(_timeline, {
            set: (...args) => {
              if (connection && args[1] === "close" && args[2] && !_timeline.close) {
                (async () => {
                  try {
                    if (connection.stat.status === "open") {
                      await connection.close();
                    }
                  } catch (err) {
                    log.error(err);
                  } finally {
                    this.onConnectionEnd(connection);
                  }
                })();
              }
              return Reflect.set(...args);
            }
          });
          maConn.timeline.upgraded = Date.now();
          const errConnectionNotMultiplexed = () => {
            throw errCode(new Error("connection is not multiplexed"), "ERR_CONNECTION_NOT_MULTIPLEXED");
          };
          connection = new Connection({
            localAddr: maConn.localAddr,
            remoteAddr: maConn.remoteAddr,
            localPeer: this.localPeer,
            remotePeer,
            stat: {
              direction,
              timeline: maConn.timeline,
              multiplexer: Muxer && Muxer.multicodec,
              encryption: cryptoProtocol
            },
            newStream: newStream || errConnectionNotMultiplexed,
            getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),
            close: async () => {
              await maConn.close();
              if (muxer) {
                muxer.streams.map((stream) => stream.abort());
              }
            }
          });
          this.onConnection(connection);
          return connection;
        }
        _onStream({ connection, stream, protocol }) {
          const handler = this.protocols.get(protocol);
          handler({ connection, stream, protocol });
        }
        async _encryptInbound(localPeer, connection, cryptos) {
          const mss = new Multistream.Listener(connection);
          const protocols = Array.from(cryptos.keys());
          log("handling inbound crypto protocol selection", protocols);
          try {
            const { stream, protocol } = await mss.handle(protocols);
            const crypto2 = cryptos.get(protocol);
            log("encrypting inbound connection...");
            if (!crypto2) {
              throw new Error(`no crypto module found for ${protocol}`);
            }
            return {
              ...await crypto2.secureInbound(localPeer, stream),
              protocol
            };
          } catch (err) {
            throw errCode(err, codes.ERR_ENCRYPTION_FAILED);
          }
        }
        async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {
          const mss = new Multistream.Dialer(connection);
          const protocols = Array.from(cryptos.keys());
          log("selecting outbound crypto protocol", protocols);
          try {
            const { stream, protocol } = await mss.select(protocols);
            const crypto2 = cryptos.get(protocol);
            log("encrypting outbound connection to %j", remotePeerId);
            if (!crypto2) {
              throw new Error(`no crypto module found for ${protocol}`);
            }
            return {
              ...await crypto2.secureOutbound(localPeer, stream, remotePeerId),
              protocol
            };
          } catch (err) {
            throw errCode(err, codes.ERR_ENCRYPTION_FAILED);
          }
        }
        async _multiplexOutbound(connection, muxers) {
          const dialer = new Multistream.Dialer(connection);
          const protocols = Array.from(muxers.keys());
          log("outbound selecting muxer %s", protocols);
          try {
            const { stream, protocol } = await dialer.select(protocols);
            log("%s selected as muxer protocol", protocol);
            const Muxer = muxers.get(protocol);
            return { stream, Muxer };
          } catch (err) {
            throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);
          }
        }
        async _multiplexInbound(connection, muxers) {
          const listener = new Multistream.Listener(connection);
          const protocols = Array.from(muxers.keys());
          log("inbound handling muxers %s", protocols);
          try {
            const { stream, protocol } = await listener.handle(protocols);
            const Muxer = muxers.get(protocol);
            return { stream, Muxer };
          } catch (err) {
            throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);
          }
        }
      };
      module2.exports = Upgrader;
    }
  });

  // node_modules/libp2p/src/peer-store/book.js
  var require_book = __commonJS({
    "node_modules/libp2p/src/peer-store/book.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var PeerId2 = require_src8();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var passthrough = (data) => data;
      var Book = class {
        constructor({ peerStore, eventName, eventProperty, eventTransformer = passthrough }) {
          this._ps = peerStore;
          this.eventName = eventName;
          this.eventProperty = eventProperty;
          this.eventTransformer = eventTransformer;
          this.data = /* @__PURE__ */ new Map();
        }
        set(peerId, data) {
          throw errcode(new Error("set must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
        }
        _setData(peerId, data, { emit = true } = {}) {
          const b58key = peerId.toB58String();
          this.data.set(b58key, data);
          emit && this._emit(peerId, data);
        }
        _emit(peerId, data) {
          this._ps.emit(this.eventName, {
            peerId,
            [this.eventProperty]: this.eventTransformer(data)
          });
        }
        get(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const rec = this.data.get(peerId.toB58String());
          return rec ? [...rec] : void 0;
        }
        delete(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (!this.data.delete(peerId.toB58String())) {
            return false;
          }
          this._emit(peerId, []);
          return true;
        }
      };
      module2.exports = Book;
    }
  });

  // node_modules/libp2p/src/peer-store/address-book.js
  var require_address_book = __commonJS({
    "node_modules/libp2p/src/peer-store/address-book.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:peer-store:address-book"), {
        error: debug("libp2p:peer-store:address-book:err")
      });
      var errcode = require_err_code();
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var Book = require_book();
      var PeerRecord = require_peer_record2();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var Envelope = require_envelope2();
      var AddressBook = class extends Book {
        constructor(peerStore) {
          super({
            peerStore,
            eventName: "change:multiaddrs",
            eventProperty: "multiaddrs",
            eventTransformer: (data) => {
              if (!data.addresses) {
                return [];
              }
              return data.addresses.map((address) => address.multiaddr);
            }
          });
          this.data = /* @__PURE__ */ new Map();
        }
        consumePeerRecord(envelope) {
          let peerRecord;
          try {
            peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
          } catch (err) {
            log.error("invalid peer record received");
            return false;
          }
          if (!peerRecord.peerId.equals(envelope.peerId)) {
            log("signing key does not match PeerId in the PeerRecord");
            return false;
          }
          if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {
            return false;
          }
          const peerId = peerRecord.peerId;
          const id = peerId.toB58String();
          const entry = this.data.get(id) || { record: void 0 };
          const storedRecord = entry.record;
          if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {
            return false;
          }
          const addresses = this._toAddresses(peerRecord.multiaddrs, true);
          this._setData(peerId, {
            addresses,
            record: {
              raw: envelope.marshal(),
              seqNumber: peerRecord.seqNumber
            }
          });
          log(`stored provided peer record for ${id}`);
          return true;
        }
        getRawEnvelope(peerId) {
          const entry = this.data.get(peerId.toB58String());
          if (!entry || !entry.record || !entry.record.raw) {
            return void 0;
          }
          return entry.record.raw;
        }
        getPeerRecord(peerId) {
          const raw = this.getRawEnvelope(peerId);
          if (!raw) {
            return void 0;
          }
          return Envelope.createFromProtobuf(raw);
        }
        set(peerId, multiaddrs) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const addresses = this._toAddresses(multiaddrs);
          if (!addresses.length) {
            return this;
          }
          const id = peerId.toB58String();
          const entry = this.data.get(id);
          if (entry && entry.addresses && entry.addresses.length === addresses.length) {
            const intersection = entry.addresses.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)));
            if (intersection.length === entry.addresses.length) {
              log(`the addresses provided to store are equal to the already stored for ${id}`);
              return this;
            }
          }
          this._setData(peerId, {
            addresses,
            record: entry && entry.record
          });
          log(`stored provided multiaddrs for ${id}`);
          if (!entry) {
            this._ps.emit("peer", peerId);
          }
          return this;
        }
        add(peerId, multiaddrs) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const addresses = this._toAddresses(multiaddrs);
          const id = peerId.toB58String();
          if (!addresses.length) {
            return this;
          }
          const entry = this.data.get(id);
          if (entry && entry.addresses) {
            entry.addresses.forEach((addr) => {
              if (!addresses.find((r) => r.multiaddr.equals(addr.multiaddr))) {
                addresses.push(addr);
              }
            });
            if (entry.addresses.length === addresses.length) {
              log(`the addresses provided to store are already stored for ${id}`);
              return this;
            }
          }
          this._setData(peerId, {
            addresses,
            record: entry && entry.record
          });
          log(`added provided multiaddrs for ${id}`);
          if (!(entry && entry.addresses)) {
            this._ps.emit("peer", peerId);
          }
          return this;
        }
        get(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const entry = this.data.get(peerId.toB58String());
          return entry && entry.addresses ? [...entry.addresses] : void 0;
        }
        _toAddresses(multiaddrs, isCertified = false) {
          if (!multiaddrs) {
            log.error("multiaddrs must be provided to store data");
            throw errcode(new Error("multiaddrs must be provided"), ERR_INVALID_PARAMETERS);
          }
          const addresses = [];
          multiaddrs.forEach((addr) => {
            if (!Multiaddr2.isMultiaddr(addr)) {
              log.error(`multiaddr ${addr} must be an instance of multiaddr`);
              throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);
            }
            if (!addresses.find((a) => a.multiaddr.equals(addr))) {
              addresses.push({
                multiaddr: addr,
                isCertified
              });
            }
          });
          return addresses;
        }
        getMultiaddrsForPeer(peerId, addressSorter = (ms) => ms) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const entry = this.data.get(peerId.toB58String());
          if (!entry || !entry.addresses) {
            return void 0;
          }
          return addressSorter(entry.addresses || []).map((address) => {
            const multiaddr = address.multiaddr;
            const idString = multiaddr.getPeerId();
            if (idString && idString === peerId.toB58String())
              return multiaddr;
            return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);
          });
        }
      };
      module2.exports = AddressBook;
    }
  });

  // node_modules/libp2p/src/peer-store/key-book.js
  var require_key_book = __commonJS({
    "node_modules/libp2p/src/peer-store/key-book.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:peer-store:key-book"), {
        error: debug("libp2p:peer-store:key-book:err")
      });
      var errcode = require_err_code();
      var PeerId2 = require_src8();
      var Book = require_book();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var KeyBook = class extends Book {
        constructor(peerStore) {
          super({
            peerStore,
            eventName: "change:pubkey",
            eventProperty: "pubkey",
            eventTransformer: (data) => data.pubKey
          });
          this.data = /* @__PURE__ */ new Map();
        }
        set(peerId, publicKey) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const id = peerId.toB58String();
          const recPeerId = this.data.get(id);
          if (!recPeerId && publicKey) {
            peerId.pubKey = publicKey;
            this._setData(peerId, peerId);
            log(`stored provided public key for ${id}`);
          }
          return this;
        }
        get(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const rec = this.data.get(peerId.toB58String());
          return rec ? rec.pubKey : void 0;
        }
      };
      module2.exports = KeyBook;
    }
  });

  // node_modules/libp2p/src/peer-store/metadata-book.js
  var require_metadata_book = __commonJS({
    "node_modules/libp2p/src/peer-store/metadata-book.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:peer-store:proto-book"), {
        error: debug("libp2p:peer-store:proto-book:err")
      });
      var errcode = require_err_code();
      var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
      var PeerId2 = require_src8();
      var Book = require_book();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var MetadataBook = class extends Book {
        constructor(peerStore) {
          super({
            peerStore,
            eventName: "change:metadata",
            eventProperty: "metadata"
          });
          this.data = /* @__PURE__ */ new Map();
        }
        set(peerId, key, value) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (typeof key !== "string" || !(value instanceof Uint8Array)) {
            log.error("valid key and value must be provided to store data");
            throw errcode(new Error("valid key and value must be provided"), ERR_INVALID_PARAMETERS);
          }
          this._setValue(peerId, key, value);
          return this;
        }
        _setValue(peerId, key, value, { emit = true } = {}) {
          const id = peerId.toB58String();
          const rec = this.data.get(id) || /* @__PURE__ */ new Map();
          const recMap = rec.get(key);
          if (recMap && uint8ArrayEquals(value, recMap)) {
            log(`the metadata provided to store is equal to the already stored for ${id} on ${key}`);
            return;
          }
          rec.set(key, value);
          this.data.set(id, rec);
          emit && this._emit(peerId, key);
        }
        get(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          return this.data.get(peerId.toB58String());
        }
        getValue(peerId, key) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const rec = this.data.get(peerId.toB58String());
          return rec && rec.get(key);
        }
        delete(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (!this.data.delete(peerId.toB58String())) {
            return false;
          }
          this._emit(peerId);
          return true;
        }
        deleteValue(peerId, key) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const rec = this.data.get(peerId.toB58String());
          if (!rec || !rec.delete(key)) {
            return false;
          }
          this._emit(peerId, key);
          return true;
        }
      };
      module2.exports = MetadataBook;
    }
  });

  // node_modules/libp2p/src/peer-store/proto-book.js
  var require_proto_book = __commonJS({
    "node_modules/libp2p/src/peer-store/proto-book.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:peer-store:proto-book"), {
        error: debug("libp2p:peer-store:proto-book:err")
      });
      var errcode = require_err_code();
      var PeerId2 = require_src8();
      var Book = require_book();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var ProtoBook = class extends Book {
        constructor(peerStore) {
          super({
            peerStore,
            eventName: "change:protocols",
            eventProperty: "protocols",
            eventTransformer: (data) => Array.from(data)
          });
          this.data = /* @__PURE__ */ new Map();
        }
        set(peerId, protocols) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (!protocols) {
            log.error("protocols must be provided to store data");
            throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
          }
          const id = peerId.toB58String();
          const recSet = this.data.get(id);
          const newSet = new Set(protocols);
          const isSetEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
          if (recSet && isSetEqual(recSet, newSet)) {
            log(`the protocols provided to store are equal to the already stored for ${id}`);
            return this;
          }
          this._setData(peerId, newSet);
          log(`stored provided protocols for ${id}`);
          return this;
        }
        add(peerId, protocols) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (!protocols) {
            log.error("protocols must be provided to store data");
            throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
          }
          const id = peerId.toB58String();
          const recSet = this.data.get(id) || /* @__PURE__ */ new Set();
          const newSet = /* @__PURE__ */ new Set([...recSet, ...protocols]);
          if (recSet.size === newSet.size) {
            log(`the protocols provided to store are already stored for ${id}`);
            return this;
          }
          this._setData(peerId, newSet);
          log(`added provided protocols for ${id}`);
          return this;
        }
        remove(peerId, protocols) {
          if (!PeerId2.isPeerId(peerId)) {
            log.error("peerId must be an instance of peer-id to store data");
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          if (!protocols) {
            log.error("protocols must be provided to store data");
            throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
          }
          const id = peerId.toB58String();
          const recSet = this.data.get(id);
          if (recSet) {
            const newSet = new Set([
              ...recSet
            ].filter((p) => !protocols.includes(p)));
            if (recSet.size === newSet.size) {
              return this;
            }
            this._setData(peerId, newSet);
            log(`removed provided protocols for ${id}`);
          }
          return this;
        }
      };
      module2.exports = ProtoBook;
    }
  });

  // node_modules/libp2p/src/peer-store/index.js
  var require_peer_store = __commonJS({
    "node_modules/libp2p/src/peer-store/index.js"(exports2, module2) {
      "use strict";
      var errcode = require_err_code();
      var { EventEmitter } = require_events();
      var PeerId2 = require_src8();
      var AddressBook = require_address_book();
      var KeyBook = require_key_book();
      var MetadataBook = require_metadata_book();
      var ProtoBook = require_proto_book();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var PeerStore = class extends EventEmitter {
        constructor({ peerId }) {
          super();
          this._peerId = peerId;
          this.addressBook = new AddressBook(this);
          this.keyBook = new KeyBook(this);
          this.metadataBook = new MetadataBook(this);
          this.protoBook = new ProtoBook(this);
        }
        start() {
        }
        stop() {
        }
        get peers() {
          const storedPeers = /* @__PURE__ */ new Set([
            ...this.addressBook.data.keys(),
            ...this.keyBook.data.keys(),
            ...this.protoBook.data.keys(),
            ...this.metadataBook.data.keys()
          ]);
          this._peerId && storedPeers.delete(this._peerId.toB58String());
          const peersData = /* @__PURE__ */ new Map();
          storedPeers.forEach((idStr) => {
            peersData.set(idStr, this.get(PeerId2.createFromB58String(idStr)));
          });
          return peersData;
        }
        delete(peerId) {
          const addressesDeleted = this.addressBook.delete(peerId);
          const keyDeleted = this.keyBook.delete(peerId);
          const protocolsDeleted = this.protoBook.delete(peerId);
          const metadataDeleted = this.metadataBook.delete(peerId);
          return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;
        }
        get(peerId) {
          if (!PeerId2.isPeerId(peerId)) {
            throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
          }
          const id = this.keyBook.data.get(peerId.toB58String());
          const addresses = this.addressBook.get(peerId);
          const metadata = this.metadataBook.get(peerId);
          const protocols = this.protoBook.get(peerId);
          if (!id && !addresses && !metadata && !protocols) {
            return void 0;
          }
          return {
            id: id || peerId,
            addresses: addresses || [],
            protocols: protocols || [],
            metadata
          };
        }
      };
      module2.exports = PeerStore;
    }
  });

  // node_modules/libp2p/src/pubsub-adapter.js
  var require_pubsub_adapter = __commonJS({
    "node_modules/libp2p/src/pubsub-adapter.js"(exports2, module2) {
      "use strict";
      function pubsubAdapter(PubsubRouter, libp2p, options) {
        const pubsub = new PubsubRouter(libp2p, options);
        pubsub._subscribeAdapter = pubsub.subscribe;
        pubsub._unsubscribeAdapter = pubsub.unsubscribe;
        function subscribe(topic, handler) {
          handler && pubsub.on(topic, handler);
          pubsub._subscribeAdapter(topic);
        }
        function unsubscribe(topic, handler) {
          if (!handler) {
            pubsub.removeAllListeners(topic);
          } else {
            pubsub.removeListener(topic, handler);
          }
          if (pubsub.listenerCount(topic) === 0) {
            pubsub._unsubscribeAdapter(topic);
          }
        }
        pubsub.subscribe = subscribe;
        pubsub.unsubscribe = unsubscribe;
        return pubsub;
      }
      module2.exports = pubsubAdapter;
    }
  });

  // node_modules/libp2p/src/peer-store/persistent/consts.js
  var require_consts3 = __commonJS({
    "node_modules/libp2p/src/peer-store/persistent/consts.js"(exports2, module2) {
      "use strict";
      module2.exports.NAMESPACE_COMMON = "/peers/";
      module2.exports.NAMESPACE_ADDRESS = "/peers/addrs/";
      module2.exports.NAMESPACE_KEYS = "/peers/keys/";
      module2.exports.NAMESPACE_METADATA = "/peers/metadata/";
      module2.exports.NAMESPACE_PROTOCOL = "/peers/protos/";
    }
  });

  // node_modules/libp2p/src/peer-store/persistent/pb/address-book.js
  var require_address_book2 = __commonJS({
    "node_modules/libp2p/src/peer-store/persistent/pb/address-book.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-address-book"] || ($protobuf.roots["libp2p-address-book"] = {});
      $root.Addresses = function() {
        function Addresses(p) {
          this.addrs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Addresses.prototype.addrs = $util.emptyArray;
        Addresses.prototype.certifiedRecord = null;
        Addresses.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.addrs != null && m.addrs.length) {
            for (var i = 0; i < m.addrs.length; ++i)
              $root.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
          }
          if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
            $root.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
          return w;
        };
        Addresses.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.Addresses();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.addrs && m.addrs.length))
                  m.addrs = [];
                m.addrs.push($root.Addresses.Address.decode(r, r.uint32()));
                break;
              case 2:
                m.certifiedRecord = $root.Addresses.CertifiedRecord.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Addresses.fromObject = function fromObject(d) {
          if (d instanceof $root.Addresses)
            return d;
          var m = new $root.Addresses();
          if (d.addrs) {
            if (!Array.isArray(d.addrs))
              throw TypeError(".Addresses.addrs: array expected");
            m.addrs = [];
            for (var i = 0; i < d.addrs.length; ++i) {
              if (typeof d.addrs[i] !== "object")
                throw TypeError(".Addresses.addrs: object expected");
              m.addrs[i] = $root.Addresses.Address.fromObject(d.addrs[i]);
            }
          }
          if (d.certifiedRecord != null) {
            if (typeof d.certifiedRecord !== "object")
              throw TypeError(".Addresses.certifiedRecord: object expected");
            m.certifiedRecord = $root.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
          }
          return m;
        };
        Addresses.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addrs = [];
          }
          if (o.defaults) {
            d.certifiedRecord = null;
          }
          if (m.addrs && m.addrs.length) {
            d.addrs = [];
            for (var j = 0; j < m.addrs.length; ++j) {
              d.addrs[j] = $root.Addresses.Address.toObject(m.addrs[j], o);
            }
          }
          if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
            d.certifiedRecord = $root.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
          }
          return d;
        };
        Addresses.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        Addresses.Address = function() {
          function Address(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Address.prototype.multiaddr = $util.newBuffer([]);
          Address.prototype.isCertified = false;
          Address.encode = function encode3(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
              w.uint32(10).bytes(m.multiaddr);
            if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
              w.uint32(16).bool(m.isCertified);
            return w;
          };
          Address.decode = function decode5(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.Addresses.Address();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.multiaddr = r.bytes();
                  break;
                case 2:
                  m.isCertified = r.bool();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          Address.fromObject = function fromObject(d) {
            if (d instanceof $root.Addresses.Address)
              return d;
            var m = new $root.Addresses.Address();
            if (d.multiaddr != null) {
              if (typeof d.multiaddr === "string")
                $util.base64.decode(d.multiaddr, m.multiaddr = $util.newBuffer($util.base64.length(d.multiaddr)), 0);
              else if (d.multiaddr.length)
                m.multiaddr = d.multiaddr;
            }
            if (d.isCertified != null) {
              m.isCertified = Boolean(d.isCertified);
            }
            return m;
          };
          Address.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              if (o.bytes === String)
                d.multiaddr = "";
              else {
                d.multiaddr = [];
                if (o.bytes !== Array)
                  d.multiaddr = $util.newBuffer(d.multiaddr);
              }
              d.isCertified = false;
            }
            if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
              d.multiaddr = o.bytes === String ? $util.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
            }
            if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
              d.isCertified = m.isCertified;
            }
            return d;
          };
          Address.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return Address;
        }();
        Addresses.CertifiedRecord = function() {
          function CertifiedRecord(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          CertifiedRecord.prototype.seq = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
          CertifiedRecord.prototype.raw = $util.newBuffer([]);
          CertifiedRecord.encode = function encode3(m, w) {
            if (!w)
              w = $Writer.create();
            if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
              w.uint32(8).uint64(m.seq);
            if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
              w.uint32(18).bytes(m.raw);
            return w;
          };
          CertifiedRecord.decode = function decode5(r, l) {
            if (!(r instanceof $Reader))
              r = $Reader.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root.Addresses.CertifiedRecord();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.seq = r.uint64();
                  break;
                case 2:
                  m.raw = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          CertifiedRecord.fromObject = function fromObject(d) {
            if (d instanceof $root.Addresses.CertifiedRecord)
              return d;
            var m = new $root.Addresses.CertifiedRecord();
            if (d.seq != null) {
              if ($util.Long)
                (m.seq = $util.Long.fromValue(d.seq)).unsigned = true;
              else if (typeof d.seq === "string")
                m.seq = parseInt(d.seq, 10);
              else if (typeof d.seq === "number")
                m.seq = d.seq;
              else if (typeof d.seq === "object")
                m.seq = new $util.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
            }
            if (d.raw != null) {
              if (typeof d.raw === "string")
                $util.base64.decode(d.raw, m.raw = $util.newBuffer($util.base64.length(d.raw)), 0);
              else if (d.raw.length)
                m.raw = d.raw;
            }
            return m;
          };
          CertifiedRecord.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              if ($util.Long) {
                var n = new $util.Long(0, 0, true);
                d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
              } else
                d.seq = o.longs === String ? "0" : 0;
              if (o.bytes === String)
                d.raw = "";
              else {
                d.raw = [];
                if (o.bytes !== Array)
                  d.raw = $util.newBuffer(d.raw);
              }
            }
            if (m.seq != null && m.hasOwnProperty("seq")) {
              if (typeof m.seq === "number")
                d.seq = o.longs === String ? String(m.seq) : m.seq;
              else
                d.seq = o.longs === String ? $util.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
            }
            if (m.raw != null && m.hasOwnProperty("raw")) {
              d.raw = o.bytes === String ? $util.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
            }
            return d;
          };
          CertifiedRecord.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
          };
          return CertifiedRecord;
        }();
        return Addresses;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js
  var require_proto_book2 = __commonJS({
    "node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-proto-book"] || ($protobuf.roots["libp2p-proto-book"] = {});
      $root.Protocols = function() {
        function Protocols(p) {
          this.protocols = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Protocols.prototype.protocols = $util.emptyArray;
        Protocols.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.protocols != null && m.protocols.length) {
            for (var i = 0; i < m.protocols.length; ++i)
              w.uint32(10).string(m.protocols[i]);
          }
          return w;
        };
        Protocols.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.Protocols();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.protocols && m.protocols.length))
                  m.protocols = [];
                m.protocols.push(r.string());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Protocols.fromObject = function fromObject(d) {
          if (d instanceof $root.Protocols)
            return d;
          var m = new $root.Protocols();
          if (d.protocols) {
            if (!Array.isArray(d.protocols))
              throw TypeError(".Protocols.protocols: array expected");
            m.protocols = [];
            for (var i = 0; i < d.protocols.length; ++i) {
              m.protocols[i] = String(d.protocols[i]);
            }
          }
          return m;
        };
        Protocols.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.protocols = [];
          }
          if (m.protocols && m.protocols.length) {
            d.protocols = [];
            for (var j = 0; j < m.protocols.length; ++j) {
              d.protocols[j] = m.protocols[j];
            }
          }
          return d;
        };
        Protocols.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Protocols;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p/src/peer-store/persistent/index.js
  var require_persistent = __commonJS({
    "node_modules/libp2p/src/peer-store/persistent/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:persistent-peer-store"), {
        error: debug("libp2p:persistent-peer-store:err")
      });
      var { Key: Key2 } = (init_key(), key_exports);
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerId2 = require_src8();
      var { base32: base322 } = (init_base32(), base32_exports);
      var PeerStore = require_peer_store();
      var {
        NAMESPACE_ADDRESS,
        NAMESPACE_COMMON,
        NAMESPACE_KEYS,
        NAMESPACE_METADATA,
        NAMESPACE_PROTOCOL
      } = require_consts3();
      var { Addresses } = require_address_book2();
      var { Protocols } = require_proto_book2();
      var PersistentPeerStore = class extends PeerStore {
        constructor({ peerId, datastore, threshold = 5 }) {
          super({ peerId });
          this._datastore = datastore;
          this._dirtyPeers = /* @__PURE__ */ new Set();
          this._dirtyMetadata = /* @__PURE__ */ new Map();
          this.threshold = threshold;
          this._addDirtyPeer = this._addDirtyPeer.bind(this);
        }
        async start() {
          log("PeerStore is starting");
          this.on("change:protocols", this._addDirtyPeer);
          this.on("change:multiaddrs", this._addDirtyPeer);
          this.on("change:pubkey", this._addDirtyPeerKey);
          this.on("change:metadata", this._addDirtyPeerMetadata);
          for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {
            await this._processDatastoreEntry(entry);
          }
          log("PeerStore started");
        }
        async stop() {
          log("PeerStore is stopping");
          this.removeAllListeners();
          await this._commitData();
          log("PeerStore stopped");
        }
        _addDirtyPeer({ peerId }) {
          const peerIdstr = peerId.toB58String();
          log("add dirty peer", peerIdstr);
          this._dirtyPeers.add(peerIdstr);
          if (this._dirtyPeers.size >= this.threshold) {
            this._commitData().catch((err) => {
              log.error("error committing data", err);
            });
          }
        }
        _addDirtyPeerKey({ peerId }) {
          if (peerId.hasInlinePublicKey()) {
            return;
          }
          const peerIdstr = peerId.toB58String();
          log("add dirty peer key", peerIdstr);
          this._dirtyPeers.add(peerIdstr);
          if (this._dirtyPeers.size >= this.threshold) {
            this._commitData().catch((err) => {
              log.error("error committing data", err);
            });
          }
        }
        _addDirtyPeerMetadata({ peerId, metadata }) {
          const peerIdstr = peerId.toB58String();
          log("add dirty metadata peer", peerIdstr);
          this._dirtyPeers.add(peerIdstr);
          const mData = this._dirtyMetadata.get(peerIdstr) || /* @__PURE__ */ new Set();
          mData.add(metadata);
          this._dirtyMetadata.set(peerIdstr, mData);
          if (this._dirtyPeers.size >= this.threshold) {
            this._commitData().catch((err) => {
              log.error("error committing data", err);
            });
          }
        }
        async _commitData() {
          const commitPeers = Array.from(this._dirtyPeers);
          if (!commitPeers.length) {
            return;
          }
          this._dirtyPeers.clear();
          log("create batch commit");
          const batch = this._datastore.batch();
          for (const peerIdStr of commitPeers) {
            const peerId = this.keyBook.data.get(peerIdStr) || PeerId2.createFromB58String(peerIdStr);
            this._batchAddressBook(peerId, batch);
            !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch);
            this._batchMetadataBook(peerId, batch);
            this._batchProtoBook(peerId, batch);
          }
          await batch.commit();
          log("batch committed");
        }
        _batchAddressBook(peerId, batch) {
          const b32key = peerId.toString();
          const key = new Key2(`${NAMESPACE_ADDRESS}${b32key}`);
          const entry = this.addressBook.data.get(peerId.toB58String());
          try {
            if (!entry) {
              batch.delete(key);
              return;
            }
            const encodedData = Addresses.encode({
              addrs: entry.addresses.map((address) => ({
                multiaddr: address.multiaddr.bytes,
                isCertified: address.isCertified
              })),
              certifiedRecord: entry.record ? {
                seq: entry.record.seqNumber,
                raw: entry.record.raw
              } : void 0
            }).finish();
            batch.put(key, encodedData);
          } catch (err) {
            log.error(err);
          }
        }
        _batchKeyBook(peerId, batch) {
          const b32key = peerId.toString();
          const key = new Key2(`${NAMESPACE_KEYS}${b32key}`);
          try {
            if (!peerId.pubKey) {
              batch.delete(key);
              return;
            }
            const encodedData = peerId.marshalPubKey();
            batch.put(key, encodedData);
          } catch (err) {
            log.error(err);
          }
        }
        _batchMetadataBook(peerId, batch) {
          const b32key = peerId.toString();
          const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];
          try {
            dirtyMetada.forEach((dirtyKey) => {
              const key = new Key2(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);
              const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);
              if (dirtyValue) {
                batch.put(key, dirtyValue);
              } else {
                batch.delete(key);
              }
            });
          } catch (err) {
            log.error(err);
          }
        }
        _batchProtoBook(peerId, batch) {
          const b32key = peerId.toString();
          const key = new Key2(`${NAMESPACE_PROTOCOL}${b32key}`);
          const protocols = this.protoBook.get(peerId);
          try {
            if (!protocols) {
              batch.delete(key);
              return;
            }
            const encodedData = Protocols.encode({ protocols }).finish();
            batch.put(key, encodedData);
          } catch (err) {
            log.error(err);
          }
        }
        async _processDatastoreEntry({ key, value }) {
          try {
            const keyParts = key.toString().split("/");
            const peerId = PeerId2.createFromBytes(base322.decode(keyParts[3]));
            let decoded;
            switch (keyParts[2]) {
              case "addrs":
                decoded = Addresses.decode(value);
                this.addressBook._setData(peerId, {
                  addresses: decoded.addrs.map((address) => ({
                    multiaddr: new Multiaddr2(address.multiaddr),
                    isCertified: Boolean(address.isCertified)
                  })),
                  record: decoded.certifiedRecord ? {
                    raw: decoded.certifiedRecord.raw,
                    seqNumber: decoded.certifiedRecord.seq
                  } : void 0
                }, { emit: false });
                break;
              case "keys":
                decoded = await PeerId2.createFromPubKey(value);
                this.keyBook._setData(decoded, decoded, { emit: false });
                break;
              case "metadata":
                this.metadataBook._setValue(peerId, keyParts[4], value, { emit: false });
                break;
              case "protos":
                decoded = Protocols.decode(value);
                this.protoBook._setData(peerId, new Set(decoded.protocols), { emit: false });
                break;
              default:
                log("invalid data persisted for: ", key.toString());
            }
          } catch (err) {
            log.error(err);
          }
        }
      };
      module2.exports = PersistentPeerStore;
    }
  });

  // node_modules/libp2p-interfaces/src/topology/index.js
  var require_topology = __commonJS({
    "node_modules/libp2p-interfaces/src/topology/index.js"(exports2, module2) {
      "use strict";
      var noop = () => {
      };
      var topologySymbol = Symbol.for("@libp2p/js-interfaces/topology");
      var Topology = class {
        constructor({
          min = 0,
          max = Infinity,
          handlers = {}
        }) {
          this.min = min;
          this.max = max;
          this._onConnect = handlers.onConnect || noop;
          this._onDisconnect = handlers.onDisconnect || noop;
          this.peers = /* @__PURE__ */ new Set();
        }
        get [Symbol.toStringTag]() {
          return "Topology";
        }
        get [topologySymbol]() {
          return true;
        }
        static isTopology(other) {
          return Boolean(other && other[topologySymbol]);
        }
        set registrar(registrar) {
          this._registrar = registrar;
        }
        disconnect(peerId) {
          this._onDisconnect(peerId);
        }
      };
      module2.exports = Topology;
    }
  });

  // node_modules/libp2p/src/registrar.js
  var require_registrar = __commonJS({
    "node_modules/libp2p/src/registrar.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:registrar"), {
        error: debug("libp2p:registrar:err")
      });
      var errcode = require_err_code();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var Topology = require_topology();
      var Registrar = class {
        constructor({ peerStore, connectionManager }) {
          this.peerStore = peerStore;
          this.connectionManager = connectionManager;
          this.topologies = /* @__PURE__ */ new Map();
          this._handle = void 0;
          this._onDisconnect = this._onDisconnect.bind(this);
          this.connectionManager.on("peer:disconnect", this._onDisconnect);
        }
        get handle() {
          return this._handle;
        }
        set handle(handle) {
          this._handle = handle;
        }
        getConnection(peerId) {
          return this.connectionManager.get(peerId);
        }
        register(topology) {
          if (!Topology.isTopology(topology)) {
            log.error("topology must be an instance of interfaces/topology");
            throw errcode(new Error("topology must be an instance of interfaces/topology"), ERR_INVALID_PARAMETERS);
          }
          const id = (Math.random() * 1e9).toString(36) + Date.now();
          this.topologies.set(id, topology);
          topology.registrar = this;
          return id;
        }
        unregister(id) {
          return this.topologies.delete(id);
        }
        _onDisconnect(connection) {
          for (const [, topology] of this.topologies) {
            topology.disconnect(connection.remotePeer);
          }
        }
      };
      module2.exports = Registrar;
    }
  });

  // node_modules/it-buffer/index.js
  var require_it_buffer2 = __commonJS({
    "node_modules/it-buffer/index.js"(exports2, module2) {
      "use strict";
      var { Buffer: Buffer2 } = require_buffer();
      var BufferList = require_BufferList();
      module2.exports = async function* (source) {
        for await (const b of source) {
          if (Buffer2.isBuffer(b)) {
            yield b;
          } else if (BufferList.isBufferList(b)) {
            yield b.slice();
          } else {
            yield Buffer2.from(b);
          }
        }
      };
      module2.exports.toBuffer = module2.exports;
      module2.exports.toList = async function* (source) {
        for await (const b of source) {
          if (Buffer2.isBuffer(b)) {
            yield new BufferList().append(b);
          } else if (BufferList.isBufferList(b)) {
            yield b;
          } else {
            yield new BufferList().append(Buffer2.from(b));
          }
        }
      };
    }
  });

  // node_modules/libp2p/src/ping/constants.js
  var require_constants8 = __commonJS({
    "node_modules/libp2p/src/ping/constants.js"(exports2, module2) {
      "use strict";
      module2.exports = {
        PROTOCOL: "/ipfs/ping/1.0.0",
        PING_LENGTH: 32,
        PROTOCOL_VERSION: "1.0.0",
        PROTOCOL_NAME: "ping"
      };
    }
  });

  // node_modules/libp2p/src/ping/index.js
  var require_ping = __commonJS({
    "node_modules/libp2p/src/ping/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:ping"), {
        error: debug("libp2p:ping:err")
      });
      var errCode = require_err_code();
      var crypto2 = require_src9();
      var { pipe } = require_it_pipe2();
      var { toBuffer } = require_it_buffer2();
      var { collect, take } = require_dist();
      var { equals: equals5 } = (init_equals(), equals_exports);
      var { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } = require_constants8();
      async function ping(node, peer) {
        const protocol = `/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
        log("dialing %s to %s", protocol, peer.toB58String ? peer.toB58String() : peer);
        const connection = await node.dial(peer);
        const { stream } = await connection.newStream(protocol);
        const start = Date.now();
        const data = crypto2.randomBytes(PING_LENGTH);
        const [result] = await pipe([data], stream, (stream2) => take(1, stream2), toBuffer, collect);
        const end = Date.now();
        if (!equals5(data, result)) {
          throw errCode(new Error("Received wrong ping ack"), "ERR_WRONG_PING_ACK");
        }
        return end - start;
      }
      function mount(node) {
        node.handle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`, ({ stream }) => pipe(stream, stream));
      }
      function unmount(node) {
        node.unhandle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`);
      }
      exports2 = module2.exports = ping;
      exports2.mount = mount;
      exports2.unmount = unmount;
    }
  });

  // node_modules/libp2p/src/identify/message.js
  var require_message = __commonJS({
    "node_modules/libp2p/src/identify/message.js"(exports2, module2) {
      "use strict";
      var $protobuf = require_minimal2();
      var $Reader = $protobuf.Reader;
      var $Writer = $protobuf.Writer;
      var $util = $protobuf.util;
      var $root = $protobuf.roots["libp2p-identify"] || ($protobuf.roots["libp2p-identify"] = {});
      $root.Identify = function() {
        function Identify(p) {
          this.listenAddrs = [];
          this.protocols = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Identify.prototype.protocolVersion = "";
        Identify.prototype.agentVersion = "";
        Identify.prototype.publicKey = $util.newBuffer([]);
        Identify.prototype.listenAddrs = $util.emptyArray;
        Identify.prototype.observedAddr = $util.newBuffer([]);
        Identify.prototype.protocols = $util.emptyArray;
        Identify.prototype.signedPeerRecord = $util.newBuffer([]);
        Identify.encode = function encode3(m, w) {
          if (!w)
            w = $Writer.create();
          if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
            w.uint32(10).bytes(m.publicKey);
          if (m.listenAddrs != null && m.listenAddrs.length) {
            for (var i = 0; i < m.listenAddrs.length; ++i)
              w.uint32(18).bytes(m.listenAddrs[i]);
          }
          if (m.protocols != null && m.protocols.length) {
            for (var i = 0; i < m.protocols.length; ++i)
              w.uint32(26).string(m.protocols[i]);
          }
          if (m.observedAddr != null && Object.hasOwnProperty.call(m, "observedAddr"))
            w.uint32(34).bytes(m.observedAddr);
          if (m.protocolVersion != null && Object.hasOwnProperty.call(m, "protocolVersion"))
            w.uint32(42).string(m.protocolVersion);
          if (m.agentVersion != null && Object.hasOwnProperty.call(m, "agentVersion"))
            w.uint32(50).string(m.agentVersion);
          if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
            w.uint32(66).bytes(m.signedPeerRecord);
          return w;
        };
        Identify.decode = function decode5(r, l) {
          if (!(r instanceof $Reader))
            r = $Reader.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root.Identify();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 5:
                m.protocolVersion = r.string();
                break;
              case 6:
                m.agentVersion = r.string();
                break;
              case 1:
                m.publicKey = r.bytes();
                break;
              case 2:
                if (!(m.listenAddrs && m.listenAddrs.length))
                  m.listenAddrs = [];
                m.listenAddrs.push(r.bytes());
                break;
              case 4:
                m.observedAddr = r.bytes();
                break;
              case 3:
                if (!(m.protocols && m.protocols.length))
                  m.protocols = [];
                m.protocols.push(r.string());
                break;
              case 8:
                m.signedPeerRecord = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Identify.fromObject = function fromObject(d) {
          if (d instanceof $root.Identify)
            return d;
          var m = new $root.Identify();
          if (d.protocolVersion != null) {
            m.protocolVersion = String(d.protocolVersion);
          }
          if (d.agentVersion != null) {
            m.agentVersion = String(d.agentVersion);
          }
          if (d.publicKey != null) {
            if (typeof d.publicKey === "string")
              $util.base64.decode(d.publicKey, m.publicKey = $util.newBuffer($util.base64.length(d.publicKey)), 0);
            else if (d.publicKey.length)
              m.publicKey = d.publicKey;
          }
          if (d.listenAddrs) {
            if (!Array.isArray(d.listenAddrs))
              throw TypeError(".Identify.listenAddrs: array expected");
            m.listenAddrs = [];
            for (var i = 0; i < d.listenAddrs.length; ++i) {
              if (typeof d.listenAddrs[i] === "string")
                $util.base64.decode(d.listenAddrs[i], m.listenAddrs[i] = $util.newBuffer($util.base64.length(d.listenAddrs[i])), 0);
              else if (d.listenAddrs[i].length)
                m.listenAddrs[i] = d.listenAddrs[i];
            }
          }
          if (d.observedAddr != null) {
            if (typeof d.observedAddr === "string")
              $util.base64.decode(d.observedAddr, m.observedAddr = $util.newBuffer($util.base64.length(d.observedAddr)), 0);
            else if (d.observedAddr.length)
              m.observedAddr = d.observedAddr;
          }
          if (d.protocols) {
            if (!Array.isArray(d.protocols))
              throw TypeError(".Identify.protocols: array expected");
            m.protocols = [];
            for (var i = 0; i < d.protocols.length; ++i) {
              m.protocols[i] = String(d.protocols[i]);
            }
          }
          if (d.signedPeerRecord != null) {
            if (typeof d.signedPeerRecord === "string")
              $util.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util.newBuffer($util.base64.length(d.signedPeerRecord)), 0);
            else if (d.signedPeerRecord.length)
              m.signedPeerRecord = d.signedPeerRecord;
          }
          return m;
        };
        Identify.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.listenAddrs = [];
            d.protocols = [];
          }
          if (o.defaults) {
            if (o.bytes === String)
              d.publicKey = "";
            else {
              d.publicKey = [];
              if (o.bytes !== Array)
                d.publicKey = $util.newBuffer(d.publicKey);
            }
            if (o.bytes === String)
              d.observedAddr = "";
            else {
              d.observedAddr = [];
              if (o.bytes !== Array)
                d.observedAddr = $util.newBuffer(d.observedAddr);
            }
            d.protocolVersion = "";
            d.agentVersion = "";
            if (o.bytes === String)
              d.signedPeerRecord = "";
            else {
              d.signedPeerRecord = [];
              if (o.bytes !== Array)
                d.signedPeerRecord = $util.newBuffer(d.signedPeerRecord);
            }
          }
          if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
            d.publicKey = o.bytes === String ? $util.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
          }
          if (m.listenAddrs && m.listenAddrs.length) {
            d.listenAddrs = [];
            for (var j = 0; j < m.listenAddrs.length; ++j) {
              d.listenAddrs[j] = o.bytes === String ? $util.base64.encode(m.listenAddrs[j], 0, m.listenAddrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.listenAddrs[j]) : m.listenAddrs[j];
            }
          }
          if (m.protocols && m.protocols.length) {
            d.protocols = [];
            for (var j = 0; j < m.protocols.length; ++j) {
              d.protocols[j] = m.protocols[j];
            }
          }
          if (m.observedAddr != null && m.hasOwnProperty("observedAddr")) {
            d.observedAddr = o.bytes === String ? $util.base64.encode(m.observedAddr, 0, m.observedAddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.observedAddr) : m.observedAddr;
          }
          if (m.protocolVersion != null && m.hasOwnProperty("protocolVersion")) {
            d.protocolVersion = m.protocolVersion;
          }
          if (m.agentVersion != null && m.hasOwnProperty("agentVersion")) {
            d.agentVersion = m.agentVersion;
          }
          if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
            d.signedPeerRecord = o.bytes === String ? $util.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
          }
          return d;
        };
        Identify.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return Identify;
      }();
      module2.exports = $root;
    }
  });

  // node_modules/libp2p/src/identify/index.js
  var require_identify = __commonJS({
    "node_modules/libp2p/src/identify/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p:identify"), {
        error: debug("libp2p:identify:err")
      });
      var errCode = require_err_code();
      var lp = require_src14();
      var { pipe } = require_it_pipe2();
      var { collect, take, consume } = require_dist();
      var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
      var PeerId2 = require_src8();
      var { Multiaddr: Multiaddr2 } = require_src();
      var { toBuffer } = require_it_buffer2();
      var Message = require_message();
      var Envelope = require_envelope2();
      var PeerRecord = require_peer_record2();
      var {
        MULTICODEC_IDENTIFY,
        MULTICODEC_IDENTIFY_PUSH,
        IDENTIFY_PROTOCOL_VERSION,
        MULTICODEC_IDENTIFY_PROTOCOL_NAME,
        MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,
        MULTICODEC_IDENTIFY_PROTOCOL_VERSION,
        MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION
      } = require_consts();
      var { codes } = require_errors2();
      var IdentifyService = class {
        static getProtocolStr(libp2p) {
          return {
            identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
            identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`
          };
        }
        constructor({ libp2p }) {
          this._libp2p = libp2p;
          this.peerStore = libp2p.peerStore;
          this.addressManager = libp2p.addressManager;
          this.connectionManager = libp2p.connectionManager;
          this.peerId = libp2p.peerId;
          this.handleMessage = this.handleMessage.bind(this);
          const protocolStr = IdentifyService.getProtocolStr(libp2p);
          this.identifyProtocolStr = protocolStr.identifyProtocolStr;
          this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr;
          this._host = {
            protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
            ...libp2p._options.host
          };
          this.peerStore.metadataBook.set(this.peerId, "AgentVersion", uint8ArrayFromString(this._host.agentVersion));
          this.peerStore.metadataBook.set(this.peerId, "ProtocolVersion", uint8ArrayFromString(this._host.protocolVersion));
          this.connectionManager.on("peer:connect", (connection) => {
            this.identify(connection).catch(log.error);
          });
          this.peerStore.on("change:multiaddrs", ({ peerId }) => {
            if (peerId.toString() === this.peerId.toString()) {
              this.pushToPeerStore();
            }
          });
          this.peerStore.on("change:protocols", ({ peerId }) => {
            if (peerId.toString() === this.peerId.toString()) {
              this.pushToPeerStore();
            }
          });
        }
        async push(connections) {
          const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
          const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes);
          const protocols = this.peerStore.protoBook.get(this.peerId) || [];
          const pushes = connections.map(async (connection) => {
            try {
              const { stream } = await connection.newStream(this.identifyPushProtocolStr);
              await pipe([Message.Identify.encode({
                listenAddrs,
                signedPeerRecord,
                protocols
              }).finish()], lp.encode(), stream, consume);
            } catch (err) {
              log.error("could not push identify update to peer", err);
            }
          });
          return Promise.all(pushes);
        }
        pushToPeerStore() {
          if (!this._libp2p.isStarted()) {
            return;
          }
          const connections = [];
          let connection;
          for (const peer of this.peerStore.peers.values()) {
            if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {
              connections.push(connection);
            }
          }
          this.push(connections);
        }
        async identify(connection) {
          const { stream } = await connection.newStream(this.identifyProtocolStr);
          const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);
          if (!data) {
            throw errCode(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
          }
          let message;
          try {
            message = Message.Identify.decode(data);
          } catch (err) {
            throw errCode(err, codes.ERR_INVALID_MESSAGE);
          }
          const {
            publicKey,
            listenAddrs,
            protocols,
            observedAddr,
            signedPeerRecord
          } = message;
          const id = await PeerId2.createFromPubKey(publicKey);
          if (connection.remotePeer.toB58String() !== id.toB58String()) {
            throw errCode(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
          }
          const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
          try {
            const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);
            if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
              this.peerStore.protoBook.set(id, protocols);
              this.peerStore.metadataBook.set(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
              this.peerStore.metadataBook.set(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
              return;
            }
          } catch (err) {
            log("received invalid envelope, discard it and fallback to listenAddrs is available", err);
          }
          try {
            this.peerStore.addressBook.set(id, listenAddrs.map((addr) => new Multiaddr2(addr)));
          } catch (err) {
            log.error("received invalid addrs", err);
          }
          this.peerStore.protoBook.set(id, protocols);
          this.peerStore.metadataBook.set(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
          this.peerStore.metadataBook.set(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
          log("received observed address of %s", cleanObservedAddr);
        }
        handleMessage({ connection, stream, protocol }) {
          switch (protocol) {
            case this.identifyProtocolStr:
              return this._handleIdentify({ connection, stream });
            case this.identifyPushProtocolStr:
              return this._handlePush({ connection, stream });
            default:
              log.error("cannot handle unknown protocol %s", protocol);
          }
        }
        async _handleIdentify({ connection, stream }) {
          let publicKey = new Uint8Array(0);
          if (this.peerId.pubKey) {
            publicKey = this.peerId.pubKey.bytes;
          }
          const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
          const protocols = this.peerStore.protoBook.get(this.peerId) || [];
          const message = Message.Identify.encode({
            protocolVersion: this._host.protocolVersion,
            agentVersion: this._host.agentVersion,
            publicKey,
            listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),
            signedPeerRecord,
            observedAddr: connection.remoteAddr.bytes,
            protocols
          }).finish();
          try {
            await pipe([message], lp.encode(), stream, consume);
          } catch (err) {
            log.error("could not respond to identify request", err);
          }
        }
        async _handlePush({ connection, stream }) {
          let message;
          try {
            const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);
            message = Message.Identify.decode(data);
          } catch (err) {
            return log.error("received invalid message", err);
          }
          const id = connection.remotePeer;
          try {
            const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);
            if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
              this.peerStore.protoBook.set(id, message.protocols);
              return;
            }
          } catch (err) {
            log("received invalid envelope, discard it and fallback to listenAddrs is available", err);
          }
          try {
            this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => new Multiaddr2(addr)));
          } catch (err) {
            log.error("received invalid addrs", err);
          }
          this.peerStore.protoBook.set(id, message.protocols);
        }
        static getCleanMultiaddr(addr) {
          if (addr && addr.length > 0) {
            try {
              return new Multiaddr2(addr);
            } catch (_) {
              return null;
            }
          }
          return null;
        }
      };
      var multicodecs = {
        IDENTIFY: MULTICODEC_IDENTIFY,
        IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
      };
      IdentifyService.multicodecs = multicodecs;
      IdentifyService.Messsage = Message;
      module2.exports = IdentifyService;
    }
  });

  // (disabled):node_modules/@motrix/nat-api/index.js
  var require_nat_api = __commonJS({
    "(disabled):node_modules/@motrix/nat-api/index.js"() {
    }
  });

  // node_modules/es6-promisify/dist/promisify.js
  var require_promisify = __commonJS({
    "node_modules/es6-promisify/dist/promisify.js"(exports2) {
      "use strict";
      Object.defineProperty(exports2, "__esModule", { value: true }), exports2.promisify = promisify;
      var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
      function promisify(a) {
        if (typeof a != "function")
          throw new TypeError("Argument to promisify must be a function");
        var b = a[customArgumentsToken], c = promisify.Promise || Promise;
        if (typeof c != "function")
          throw new Error("No Promise implementation found; do you need a polyfill?");
        return function() {
          for (var d = this, e = arguments.length, f = Array(e), g = 0; g < e; g++)
            f[g] = arguments[g];
          return new c(function(c2, e2) {
            f.push(function(a2) {
              if (a2)
                return e2(a2);
              for (var d2 = arguments.length, f2 = Array(1 < d2 ? d2 - 1 : 0), g2 = 1; g2 < d2; g2++)
                f2[g2 - 1] = arguments[g2];
              if (f2.length === 1 || !b)
                return c2(f2[0]);
              var h = {};
              f2.forEach(function(a3, c3) {
                var d3 = b[c3];
                d3 && (h[d3] = a3);
              }), c2(h);
            }), a.apply(d, f);
          });
        };
      }
      promisify.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", promisify.Promise = void 0;
    }
  });

  // node_modules/wherearewe/src/index.js
  var require_src18 = __commonJS({
    "node_modules/wherearewe/src/index.js"(exports2, module2) {
      "use strict";
      var isElectron = require_is_electron();
      var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
      var IS_ELECTRON = isElectron();
      var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
      var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
      var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
      var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
      var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
      var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
      module2.exports = {
        isTest: IS_TEST,
        isElectron: IS_ELECTRON,
        isElectronMain: IS_ELECTRON_MAIN,
        isElectronRenderer: IS_ELECTRON_RENDERER,
        isNode: IS_NODE,
        isBrowser: IS_BROWSER,
        isWebWorker: IS_WEBWORKER,
        isEnvWithDom: IS_ENV_WITH_DOM
      };
    }
  });

  // node_modules/retry/lib/retry_operation.js
  var require_retry_operation = __commonJS({
    "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = options && options.maxRetryTime || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        this._timer = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      module2.exports = RetryOperation;
      RetryOperation.prototype.reset = function() {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts.slice(0);
      };
      RetryOperation.prototype.stop = function() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (this._timer) {
          clearTimeout(this._timer);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function(err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = new Date().getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.push(err);
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === void 0) {
          if (this._cachedTimeouts) {
            this._errors.splice(0, this._errors.length - 1);
            timeout = this._cachedTimeouts.slice(-1);
          } else {
            return false;
          }
        }
        var self2 = this;
        this._timer = setTimeout(function() {
          self2._attempts++;
          if (self2._operationTimeoutCb) {
            self2._timeout = setTimeout(function() {
              self2._operationTimeoutCb(self2._attempts);
            }, self2._operationTimeout);
            if (self2._options.unref) {
              self2._timeout.unref();
            }
          }
          self2._fn(self2._attempts);
        }, timeout);
        if (this._options.unref) {
          this._timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function(fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self2 = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function() {
            self2._operationTimeoutCb();
          }, self2._operationTimeout);
        }
        this._operationStart = new Date().getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function(fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function(fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function() {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function() {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function() {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message = error.message;
          var count = (counts[message] || 0) + 1;
          counts[message] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    }
  });

  // node_modules/retry/lib/retry.js
  var require_retry = __commonJS({
    "node_modules/retry/lib/retry.js"(exports2) {
      var RetryOperation = require_retry_operation();
      exports2.operation = function(options) {
        var timeouts = exports2.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && (options.forever || options.retries === Infinity),
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime
        });
      };
      exports2.timeouts = function(options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
          timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts));
        }
        timeouts.sort(function(a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports2.createTimeout = function(attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
      };
      exports2.wrap = function(obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = function retryWrapper(original2) {
            var op = exports2.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function(err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function() {
              original2.apply(obj, args);
            });
          }.bind(obj, original);
          obj[method].options = options;
        }
      };
    }
  });

  // node_modules/retry/index.js
  var require_retry2 = __commonJS({
    "node_modules/retry/index.js"(exports2, module2) {
      module2.exports = require_retry();
    }
  });

  // node_modules/p-retry/index.js
  var require_p_retry = __commonJS({
    "node_modules/p-retry/index.js"(exports2, module2) {
      "use strict";
      var retry = require_retry2();
      var networkErrorMsgs = [
        "Failed to fetch",
        "NetworkError when attempting to fetch resource.",
        "The Internet connection appears to be offline.",
        "Network request failed"
      ];
      var AbortError = class extends Error {
        constructor(message) {
          super();
          if (message instanceof Error) {
            this.originalError = message;
            ({ message } = message);
          } else {
            this.originalError = new Error(message);
            this.originalError.stack = this.stack;
          }
          this.name = "AbortError";
          this.message = message;
        }
      };
      var decorateErrorWithCounts = (error, attemptNumber, options) => {
        const retriesLeft = options.retries - (attemptNumber - 1);
        error.attemptNumber = attemptNumber;
        error.retriesLeft = retriesLeft;
        return error;
      };
      var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
      var pRetry = (input, options) => new Promise((resolve, reject) => {
        options = {
          onFailedAttempt: () => {
          },
          retries: 10,
          ...options
        };
        const operation = retry.operation(options);
        operation.attempt(async (attemptNumber) => {
          try {
            resolve(await input(attemptNumber));
          } catch (error) {
            if (!(error instanceof Error)) {
              reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
              return;
            }
            if (error instanceof AbortError) {
              operation.stop();
              reject(error.originalError);
            } else if (error instanceof TypeError && !isNetworkError(error.message)) {
              operation.stop();
              reject(error);
            } else {
              decorateErrorWithCounts(error, attemptNumber, options);
              try {
                await options.onFailedAttempt(error);
              } catch (error2) {
                reject(error2);
                return;
              }
              if (!operation.retry(error)) {
                reject(operation.mainError());
              }
            }
          }
        });
      });
      module2.exports = pRetry;
      module2.exports.default = pRetry;
      module2.exports.AbortError = AbortError;
    }
  });

  // libp2p-package:../package.json
  var require_package2 = __commonJS({
    "libp2p-package:../package.json"(exports2, module2) {
      module2.exports = { name: "libp2p", version: "0.33.0" };
    }
  });

  // node_modules/is-loopback-addr/index.js
  var require_is_loopback_addr = __commonJS({
    "node_modules/is-loopback-addr/index.js"(exports2, module2) {
      "use strict";
      function isLoopbackAddr(ip) {
        return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
      }
      module2.exports = isLoopbackAddr;
    }
  });

  // node_modules/libp2p-utils/src/multiaddr/is-loopback.js
  var require_is_loopback = __commonJS({
    "node_modules/libp2p-utils/src/multiaddr/is-loopback.js"(exports2, module2) {
      "use strict";
      var isLoopbackAddr = require_is_loopback_addr();
      function isLoopback(ma) {
        const { address } = ma.nodeAddress();
        return isLoopbackAddr(address);
      }
      module2.exports = isLoopback;
    }
  });

  // node_modules/libp2p/src/nat-manager.js
  var require_nat_manager = __commonJS({
    "node_modules/libp2p/src/nat-manager.js"(exports2, module2) {
      "use strict";
      var NatAPI = require_nat_api();
      var debug = require_browser2();
      var { promisify } = require_promisify();
      var { Multiaddr: Multiaddr2 } = require_src();
      var log = Object.assign(debug("libp2p:nat"), {
        error: debug("libp2p:nat:err")
      });
      var { isBrowser } = require_src18();
      var retry = require_p_retry();
      var isPrivateIp = require_private_ip();
      var pkg = require_package2();
      var errcode = require_err_code();
      var {
        codes: { ERR_INVALID_PARAMETERS }
      } = require_errors2();
      var isLoopback = require_is_loopback();
      var DEFAULT_TTL = 7200;
      function highPort(min = 1024, max = 65535) {
        return Math.floor(Math.random() * (max - min + 1) + min);
      }
      var NatManager = class {
        constructor({ peerId, addressManager, transportManager, ...options }) {
          this._peerId = peerId;
          this._addressManager = addressManager;
          this._transportManager = transportManager;
          this._enabled = options.enabled;
          this._externalIp = options.externalIp;
          this._options = {
            description: options.description || `${pkg.name}@${pkg.version} ${this._peerId}`,
            ttl: options.ttl || DEFAULT_TTL,
            autoUpdate: options.keepAlive || true,
            gateway: options.gateway,
            enablePMP: Boolean(options.pmp && options.pmp.enabled)
          };
          if (this._options.ttl < DEFAULT_TTL) {
            throw errcode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), ERR_INVALID_PARAMETERS);
          }
        }
        start() {
          if (isBrowser || !this._enabled) {
            return;
          }
          this._start().catch((err) => {
            log.error(err);
          });
        }
        async _start() {
          const addrs = this._transportManager.getAddrs();
          for (const addr of addrs) {
            const { family, host, port, transport } = addr.toOptions();
            if (!addr.isThinWaistAddress() || transport !== "tcp") {
              continue;
            }
            if (isLoopback(addr)) {
              continue;
            }
            if (family !== 4) {
              continue;
            }
            const client = this._getClient();
            const publicIp = this._externalIp || await client.externalIp();
            if (isPrivateIp(publicIp)) {
              throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
            }
            const publicPort = highPort();
            log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
            await client.map({
              publicPort,
              privatePort: port,
              protocol: transport.toUpperCase()
            });
            this._addressManager.addObservedAddr(Multiaddr2.fromNodeAddress({
              family: 4,
              address: publicIp,
              port: publicPort
            }, transport));
          }
        }
        _getClient() {
          if (this._client) {
            return this._client;
          }
          const client = new NatAPI(this._options);
          const map = promisify(client.map.bind(client));
          const destroy = promisify(client.destroy.bind(client));
          const externalIp = promisify(client.externalIp.bind(client));
          this._client = {
            map: (...args) => retry(() => map(...args), { onFailedAttempt: log.error, unref: true }),
            destroy: (...args) => retry(() => destroy(...args), { onFailedAttempt: log.error, unref: true }),
            externalIp: (...args) => retry(() => externalIp(...args), { onFailedAttempt: log.error, unref: true })
          };
          return this._client;
        }
        async stop() {
          if (isBrowser || !this._client) {
            return;
          }
          try {
            await this._client.destroy();
            this._client = null;
          } catch (err) {
            log.error(err);
          }
        }
      };
      module2.exports = NatManager;
    }
  });

  // node_modules/libp2p/src/index.js
  var require_src19 = __commonJS({
    "node_modules/libp2p/src/index.js"(exports2, module2) {
      "use strict";
      var debug = require_browser2();
      var log = Object.assign(debug("libp2p"), {
        error: debug("libp2p:err")
      });
      var { EventEmitter } = require_events();
      var errCode = require_err_code();
      var PeerId2 = require_src8();
      var { Multiaddr: Multiaddr2 } = require_src();
      var PeerRouting = require_peer_routing();
      var ContentRouting = require_content_routing();
      var getPeer = require_get_peer();
      var { validate: validateConfig } = require_config();
      var { codes, messages } = require_errors2();
      var AddressManager = require_address_manager();
      var ConnectionManager = require_connection_manager();
      var Circuit = require_transport();
      var Relay = require_circuit();
      var Dialer = require_dialer();
      var Keychain = require_keychain();
      var Metrics = require_metrics();
      var TransportManager = require_transport_manager();
      var Upgrader = require_upgrader();
      var PeerStore = require_peer_store();
      var PubsubAdapter = require_pubsub_adapter();
      var PersistentPeerStore = require_persistent();
      var Registrar = require_registrar();
      var ping = require_ping();
      var IdentifyService = require_identify();
      var NatManager = require_nat_manager();
      var { updateSelfPeerRecord } = require_utils4();
      var Libp2p = class extends EventEmitter {
        static async create(options) {
          if (options.peerId) {
            return new Libp2p(options);
          }
          const peerId = await PeerId2.create();
          options.peerId = peerId;
          return new Libp2p(options);
        }
        constructor(_options) {
          super();
          this._options = validateConfig(_options);
          this.peerId = this._options.peerId;
          this.datastore = this._options.datastore;
          this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({
            peerId: this.peerId,
            datastore: this.datastore,
            ...this._options.peerStore
          }) : new PeerStore({ peerId: this.peerId });
          this.addresses = this._options.addresses;
          this.addressManager = new AddressManager(this.peerId, this._options.addresses);
          this.addressManager.on("change:addresses", () => {
            updateSelfPeerRecord(this).catch((err) => {
              log.error("Error updating self peer record", err);
            });
          });
          this._modules = this._options.modules;
          this._config = this._options.config;
          this._transport = [];
          this._discovery = /* @__PURE__ */ new Map();
          this.connectionManager = new ConnectionManager(this, {
            autoDial: this._config.peerDiscovery.autoDial,
            ...this._options.connectionManager
          });
          if (this._options.metrics.enabled) {
            this.metrics = new Metrics({
              ...this._options.metrics,
              connectionManager: this.connectionManager
            });
          }
          if (this._options.keychain && this._options.keychain.datastore) {
            log("creating keychain");
            const keychainOpts = Keychain.generateOptions();
            this.keychain = new Keychain(this._options.keychain.datastore, {
              ...keychainOpts,
              ...this._options.keychain
            });
            log("keychain constructed");
          }
          this.upgrader = new Upgrader({
            localPeer: this.peerId,
            metrics: this.metrics,
            onConnection: (connection) => this.connectionManager.onConnect(connection),
            onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)
          });
          this.transportManager = new TransportManager({
            libp2p: this,
            upgrader: this.upgrader,
            faultTolerance: this._options.transportManager.faultTolerance
          });
          this.natManager = new NatManager({
            peerId: this.peerId,
            addressManager: this.addressManager,
            transportManager: this.transportManager,
            ...this._options.config.nat
          });
          this.registrar = new Registrar({
            peerStore: this.peerStore,
            connectionManager: this.connectionManager
          });
          this.handle = this.handle.bind(this);
          this.registrar.handle = this.handle;
          if (!this._modules.connEncryption || !this._modules.connEncryption.length) {
            throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
          }
          const cryptos = this._modules.connEncryption;
          cryptos.forEach((crypto2) => {
            this.upgrader.cryptos.set(crypto2.protocol, crypto2);
          });
          this.dialer = new Dialer({
            transportManager: this.transportManager,
            peerStore: this.peerStore,
            ...this._options.dialer
          });
          this._modules.transport.forEach((Transport) => {
            const key = Transport.prototype[Symbol.toStringTag];
            const transportOptions = this._config.transport[key];
            this.transportManager.add(key, Transport, transportOptions);
          });
          if (this._config.relay.enabled) {
            this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);
            this.relay = new Relay(this);
          }
          if (this._modules.streamMuxer) {
            const muxers = this._modules.streamMuxer;
            muxers.forEach((muxer) => {
              this.upgrader.muxers.set(muxer.multicodec, muxer);
            });
            this.identifyService = new IdentifyService({ libp2p: this });
            this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);
          }
          if (this._modules.connProtector) {
            this.upgrader.protector = this._modules.connProtector;
          } else if (globalThis.process !== void 0 && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {
            throw new Error("Private network is enforced, but no protector was provided");
          }
          if (this._modules.dht) {
            const DHT = this._modules.dht;
            this._dht = DHT.create({
              libp2p: this,
              ...this._config.dht
            });
          }
          if (this._modules.pubsub) {
            const Pubsub = this._modules.pubsub;
            this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);
          }
          this.peerRouting = new PeerRouting(this);
          this.contentRouting = new ContentRouting(this);
          ping.mount(this);
          this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);
        }
        emit(eventName, ...args) {
          if (eventName === "error" && !this._events.error) {
            log.error(args);
            return false;
          } else {
            return super.emit(eventName, ...args);
          }
        }
        async start() {
          log("libp2p is starting");
          try {
            await this._onStarting();
            await this._onDidStart();
            log("libp2p has started");
          } catch (err) {
            this.emit("error", err);
            log.error("An error occurred starting libp2p", err);
            await this.stop();
            throw err;
          }
        }
        async stop() {
          log("libp2p is stopping");
          try {
            this._isStarted = false;
            this.relay && this.relay.stop();
            this.peerRouting.stop();
            for (const service of this._discovery.values()) {
              service.removeListener("peer", this._onDiscoveryPeer);
            }
            await Promise.all(Array.from(this._discovery.values(), (s) => s.stop()));
            this._discovery = /* @__PURE__ */ new Map();
            await this.peerStore.stop();
            await this.connectionManager.stop();
            await Promise.all([
              this.pubsub && this.pubsub.stop(),
              this._dht && this._dht.stop(),
              this.metrics && this.metrics.stop()
            ]);
            await this.natManager.stop();
            await this.transportManager.close();
            ping.unmount(this);
            this.dialer.destroy();
          } catch (err) {
            if (err) {
              log.error(err);
              this.emit("error", err);
            }
          }
          log("libp2p has stopped");
        }
        async loadKeychain() {
          if (!this.keychain) {
            return;
          }
          try {
            await this.keychain.findKeyByName("self");
          } catch (err) {
            await this.keychain.importPeer("self", this.peerId);
          }
        }
        isStarted() {
          return this._isStarted;
        }
        get connections() {
          return this.connectionManager.connections;
        }
        dial(peer, options) {
          return this._dial(peer, options);
        }
        async dialProtocol(peer, protocols, options) {
          if (!protocols || !protocols.length) {
            throw errCode(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
          }
          const connection = await this._dial(peer, options);
          return connection.newStream(protocols);
        }
        async _dial(peer, options) {
          const { id, multiaddrs } = getPeer(peer);
          if (id.equals(this.peerId)) {
            throw errCode(new Error("Cannot dial self"), codes.ERR_DIALED_SELF);
          }
          let connection = this.connectionManager.get(id);
          if (!connection) {
            connection = await this.dialer.connectToPeer(peer, options);
          } else if (multiaddrs) {
            this.peerStore.addressBook.add(id, multiaddrs);
          }
          return connection;
        }
        get multiaddrs() {
          let addrs = this.addressManager.getAnnounceAddrs().map((ma) => ma.toString());
          if (!addrs.length) {
            addrs = this.transportManager.getAddrs().map((ma) => ma.toString());
          }
          addrs = addrs.concat(this.addressManager.getObservedAddrs().map((ma) => ma.toString()));
          const announceFilter = this._options.addresses.announceFilter;
          const addrSet = new Set(addrs);
          return announceFilter(Array.from(addrSet).map((str) => new Multiaddr2(str)));
        }
        async hangUp(peer) {
          const { id } = getPeer(peer);
          const connections = this.connectionManager.connections.get(id.toB58String());
          if (!connections) {
            return;
          }
          await Promise.all(connections.map((connection) => {
            return connection.close();
          }));
        }
        ping(peer) {
          const { id, multiaddrs } = getPeer(peer);
          if (multiaddrs) {
            return ping(this, multiaddrs[0]);
          }
          return ping(this, id);
        }
        handle(protocols, handler) {
          protocols = Array.isArray(protocols) ? protocols : [protocols];
          protocols.forEach((protocol) => {
            this.upgrader.protocols.set(protocol, handler);
          });
          this.peerStore.protoBook.add(this.peerId, protocols);
        }
        unhandle(protocols) {
          protocols = Array.isArray(protocols) ? protocols : [protocols];
          protocols.forEach((protocol) => {
            this.upgrader.protocols.delete(protocol);
          });
          this.peerStore.protoBook.remove(this.peerId, protocols);
        }
        async _onStarting() {
          const addrs = this.addressManager.getListenAddrs();
          await this.transportManager.listen(addrs);
          this.natManager.start();
          await this.peerStore.start();
          if (this._config.pubsub.enabled) {
            this.pubsub && this.pubsub.start();
          }
          if (this._config.dht.enabled) {
            this._dht && await this._dht.start();
            this._dht.on("peer", this._onDiscoveryPeer);
          }
          this.metrics && this.metrics.start();
        }
        async _onDidStart() {
          this._isStarted = true;
          this.peerStore.on("peer", (peerId) => {
            this.emit("peer:discovery", peerId);
            this._maybeConnect(peerId);
          });
          for (const peer of this.peerStore.peers.values()) {
            this.emit("peer:discovery", peer.id);
          }
          this.connectionManager.start();
          await this._setupPeerDiscovery();
          this.relay && this.relay.start();
          this.peerRouting.start();
        }
        _onDiscoveryPeer(peer) {
          if (peer.id.toB58String() === this.peerId.toB58String()) {
            log.error(new Error(codes.ERR_DISCOVERED_SELF));
            return;
          }
          peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);
          peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);
        }
        async _maybeConnect(peerId) {
          if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {
            const minConnections = this._options.connectionManager.minConnections || 0;
            if (minConnections > this.connectionManager.size) {
              log("connecting to discovered peer %s", peerId.toB58String());
              try {
                await this.dialer.connectToPeer(peerId);
              } catch (err) {
                log.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);
              }
            }
          }
        }
        async _setupPeerDiscovery() {
          const setupService = (DiscoveryService) => {
            let config = {
              enabled: true
            };
            if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {
              config = { ...config, ...this._config.peerDiscovery[DiscoveryService.tag] };
            }
            if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {
              let discoveryService;
              if (typeof DiscoveryService === "function") {
                discoveryService = new DiscoveryService(Object.assign({}, config, {
                  peerId: this.peerId,
                  libp2p: this
                }));
              } else {
                discoveryService = DiscoveryService;
              }
              discoveryService.on("peer", this._onDiscoveryPeer);
              this._discovery.set(DiscoveryService.tag, discoveryService);
            }
          };
          for (const DiscoveryService of this._modules.peerDiscovery || []) {
            setupService(DiscoveryService);
          }
          for (const Transport of this.transportManager.getTransports()) {
            if (Transport.discovery) {
              setupService(Transport.discovery);
            }
          }
          await Promise.all(Array.from(this._discovery.values(), (d) => d.start()));
        }
      };
      module2.exports = Libp2p;
    }
  });

  // src/index.ts
  var import_libp2p_websockets = __toModule(require_src3());
  var import_filters = __toModule(require_filters());
  var import_noise = __toModule(require_noise());
  var import_libp2p_mplex = __toModule(require_src10());
  var import_libp2p = __toModule(require_src19());
  var import_multiaddr = __toModule(require_src());
  var import_peer_id = __toModule(require_src8());
  (async () => {
    const libp2p = await (0, import_libp2p.create)({
      modules: {
        transport: [import_libp2p_websockets.default],
        connEncryption: [new import_noise.Noise()],
        streamMuxer: [import_libp2p_mplex.default]
      },
      config: {
        transport: {
          [import_libp2p_websockets.default.prototype[Symbol.toStringTag]]: {
            filter: import_filters.default.all
          }
        },
        peerDiscovery: {
          autoDial: false
        }
      }
    });
    await libp2p.start();
    const peer = new URLSearchParams(window.location.search).get("peer");
    console.log(peer);
    const addr = new import_multiaddr.Multiaddr(peer);
    const id = addr.getPeerId();
    if (!id) {
      throw new Error("invalid addr");
    }
    const pid = import_peer_id.default.createFromB58String(id);
    libp2p.peerStore.addressBook.add(pid, [addr]);
    const t0 = performance.now();
    const { stream } = await libp2p.dialProtocol(pid, "/bencher");
    for await (const _ of stream.source) {
    }
    const t1 = performance.now();
    console.log("transfer took ", t1 - t0);
  })();
})();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! noble-ed25519 - MIT License (c) Paul Miller (paulmillr.com) */
/*! noble-secp256k1 - MIT License (c) Paul Miller (paulmillr.com) */
